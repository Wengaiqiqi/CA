<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CA备考系统</title>
  <style>
    body {
        font-family: 'Microsoft YaHei', Arial, sans-serif;
        line-height: 1.6;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f0f4f8;
        color: #333;
        transition: all 0.3s ease;
    }
    .container {
        background-color: white;
        border-radius: 12px;
        padding: 25px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        position: relative;
        overflow: hidden;
    }
    .container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 5px;
        background: linear-gradient(90deg, #3498db, #2ecc71);
    }
    h1 {
        text-align: center;
        color: #2c3e50;
        margin-bottom: 30px;
        font-size: 2.2rem;
        font-weight: 600;
        position: relative;
        padding-bottom: 15px;
    }
    h1::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 80px;
        height: 3px;
        background: linear-gradient(90deg, #3498db, #2ecc71);
    }
    h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        font-weight: 500;
    }
    .question {
        margin-bottom: 30px;
        padding: 20px;
        border-radius: 10px;
        background-color: #ffffff;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        border-left: 4px solid #3498db;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    .question:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }
    .question-title {
        font-weight: bold;
        margin-bottom: 15px;
        color: #2c3e50;
        font-size: 1.1rem;
        line-height: 1.5;
    }
    .options {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    .option {
        margin-left: 5px;
        padding: 8px 10px;
        border-radius: 6px;
        transition: background-color 0.2s;
    }
    .option:hover {
        background-color: #f7f9fc;
    }
    .option label {
        cursor: pointer;
        display: inline-block;
        width: 100%;
    }
    .option input[type="radio"] {
        margin-right: 10px;
        transform: scale(1.2);
    }
    .btn {
        background: linear-gradient(135deg, #3498db, #2980b9);
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 50px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        display: block;
        margin: 25px auto;
        transition: all 0.3s;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }
    .btn:hover {
        background: linear-gradient(135deg, #2980b9, #3498db);
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
    }
    .btn:active {
        transform: translateY(0);
    }
    .btn-secondary {
        background: linear-gradient(135deg, #2ecc71, #27ae60);
    }
    .btn-secondary:hover {
        background: linear-gradient(135deg, #27ae60, #2ecc71);
    }
    .btn-danger {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
    }
    .btn-danger:hover {
        background: linear-gradient(135deg, #c0392b, #e74c3c);
    }
    #results {
        margin-top: 30px;
        padding: 20px;
        border-radius: 10px;
        background-color: #ffffff;
        box-shadow: 0 3px 15px rgba(0, 0, 0, 0.08);
        display: none;
    }
    .result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #f0f4f8;
    }
    .correct {
        color: #27ae60;
    }
    .incorrect {
        color: #e74c3c;
    }
    .filter-controls {
        margin: 20px 0;
        text-align: center;
    }
    .filter-btn {
        background-color: #f7f9fc;
        border: 1px solid #ddd;
        padding: 8px 15px;
        margin: 0 5px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: 500;
    }
    .filter-btn:hover {
        background-color: #e6f0ff;
    }
    .filter-btn.active {
        background-color: #3498db;
        color: white;
        border-color: #3498db;
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
    }
    .hidden {
        display: none;
    }
    .status {
        font-weight: bold;
        margin-left: 10px;
        padding: 4px 10px;
        border-radius: 20px;
        font-size: 0.9rem;
    }
    .status.correct {
        background-color: rgba(46, 204, 113, 0.15);
    }
    .status.incorrect {
        background-color: rgba(231, 76, 60, 0.15);
    }
    .progress {
        margin: 25px 0;
        height: 8px;
        background-color: #e6eef5;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #3498db, #2ecc71);
        width: 0;
        transition: width 0.5s;
        border-radius: 10px;
    }
    /* 密码保护和题目数量选择样式 */
    .password-container, .mode-selection-container, .question-count-container {
        text-align: center;
        margin: 50px auto;
        max-width: 500px;
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        position: relative;
        overflow: hidden;
    }
    .password-container::before, .mode-selection-container::before, .question-count-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 5px;
        background: linear-gradient(90deg, #3498db, #2ecc71);
    }
    .password-input, .question-count-input {
        width: 100%;
        padding: 15px;
        font-size: 16px;
        border: 2px solid #e6eef5;
        border-radius: 8px;
        margin: 15px 0;
        transition: all 0.3s;
        box-sizing: border-box;
    }
    .password-input:focus, .question-count-input:focus {
        border-color: #3498db;
        outline: none;
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
    }
    .error-message {
        color: #e74c3c;
        margin-top: 15px;
        display: none;
        padding: 10px;
        background-color: rgba(231, 76, 60, 0.1);
        border-radius: 6px;
        font-weight: 500;
    }
    /* 用时显示样式 */
    #timer {
        text-align: center;
        font-size: 18px;
        margin-bottom: 25px;
        color: #2c3e50;
        background: #f7f9fc;
        padding: 10px;
        border-radius: 30px;
        font-weight: 500;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }
    /* 模式选择样式 */
    .mode-btn-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin: 30px 0;
        max-width: 1000px;
        margin-left: auto;
        margin-right: auto;
    }
    .mode-btn {
        padding: 20px 15px;
        font-size: 16px;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        transition: all 0.3s;
        min-height: 120px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        font-weight: 500;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 8px;
        text-align: center;
    }
    .mode-btn i {
        font-size: 28px;
        margin-bottom: 8px;
    }
    .mode-btn small {
        font-size: 12px;
        opacity: 0.9;
        line-height: 1.3;
        margin-top: 5px;
        max-width: 90%;
    }
    .mode-btn.exam-mode {
        background: linear-gradient(135deg, #3498db, #2980b9);
        color: white;
    }
    .mode-btn.practice-mode {
        background: linear-gradient(135deg, #2ecc71, #27ae60);
        color: white;
    }
    .mode-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 7px 20px rgba(0, 0, 0, 0.15);
    }
    .mode-btn:active {
        transform: translateY(-1px);
    }
    /* 答案反馈样式 */
    .answer-feedback {
        margin-top: 10px;
        padding: 12px;
        border-radius: 8px;
        font-weight: 500;
        display: none;
    }
    .answer-feedback.correct {
        background-color: rgba(46, 204, 113, 0.15);
        color: #27ae60;
        border-left: 4px solid #27ae60;
    }
    .answer-feedback.partial {
        background-color: rgba(243, 156, 18, 0.15);
        color: #f39c12;
        border-left: 4px solid #f39c12;
    }
    .answer-feedback.incorrect {
        background-color: rgba(231, 76, 60, 0.15);
        color: #e74c3c;
        border-left: 4px solid #e74c3c;
    }
    
    .answer-feedback.partial {
        background-color: rgba(243, 156, 18, 0.15);
        color: #f39c12;
        border-left: 4px solid #f39c12;
    }
    
    /* 多选题样式 */
    .question-type {
        display: inline-block;
        background-color: #3498db;
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        margin-right: 8px;
        vertical-align: middle;
    }
    
    .answer-summary {
        margin-top: 15px;
        padding: 10px;
        background-color: rgba(52, 152, 219, 0.1);
        border-radius: 6px;
        font-size: 0.9rem;
    }
    
    .answer-summary .user-answer {
        margin-bottom: 5px;
        color: #7f8c8d;
    }
    
    .answer-summary .correct-answer {
        color: #27ae60;
        font-weight: 600;
    }
    
    /* 结果页面题目状态样式 */
    .question.correct {
        border-left: 4px solid #27ae60;
        background-color: rgba(46, 204, 113, 0.05);
    }
    
    .question.partial {
        border-left: 4px solid #f39c12;
        background-color: rgba(243, 156, 18, 0.05);
    }
    
    .question.incorrect {
        border-left: 4px solid #e74c3c;
        background-color: rgba(231, 76, 60, 0.05);
    }
    
    .status.correct {
        color: #27ae60;
        font-weight: 600;
    }
    
    .status.partial {
        color: #f39c12;
        font-weight: 600;
    }
    
    .status.incorrect {
        color: #e74c3c;
        font-weight: 600;
    }
    
    /* 选项状态样式 */
    .option.correct {
        background-color: rgba(46, 204, 113, 0.15);
        color: #27ae60;
        border: 1px solid #27ae60;
    }
    
    .option.incorrect {
        background-color: rgba(231, 76, 60, 0.15);
        color: #e74c3c;
        border: 1px solid #e74c3c;
    }
    
    .option.missed {
        background-color: rgba(243, 156, 18, 0.15);
        color: #f39c12;
        border: 1px solid #f39c12;
        border-style: dashed;
    }
    /* 结果页面样式优化 */
    .result-summary {
        display: flex;
        justify-content: space-around;
        margin: 20px 0 30px;
        padding: 20px;
        background: #f7f9fc;
        border-radius: 10px;
    }
    .result-item {
        text-align: center;
    }
    .result-item .value {
        font-size: 2rem;
        font-weight: bold;
        color: #2c3e50;
        display: block;
        margin-bottom: 5px;
    }
    .result-item .label {
        font-size: 0.9rem;
        color: #7f8c8d;
    }
    /* 图标 */
    .icon {
        display: inline-block;
        width: 24px;
        height: 24px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        vertical-align: middle;
        margin-right: 8px;
    }
    
    /* 章节按钮禁用状态 */
    .chapter-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        filter: grayscale(50%);
    }
    .chapter-btn:disabled:hover {
        transform: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    /* 中等屏幕尺寸优化 */
    @media (max-width: 1024px) and (min-width: 769px) {
        .mode-btn-container {
            grid-template-columns: repeat(2, 1fr);
            gap: 18px;
        }
        #mode-selection .mode-btn-container {
            grid-template-columns: repeat(3, 1fr);
        }
    }
    
    /* 响应式设计 */
    @media (max-width: 768px) {
        body {
            padding: 10px;
        }
        .container {
            padding: 15px;
        }
        .mode-btn-container {
            grid-template-columns: 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        .mode-btn {
            min-height: 100px;
            padding: 15px 10px;
            font-size: 14px;
        }
        .mode-btn i {
            font-size: 24px;
        }
        .mode-btn small {
            font-size: 11px;
        }
        .result-summary {
            flex-direction: column;
            gap: 15px;
        }
    }
    /* 高亮当前题目 */
    .current-question {
        border-left-color: #f39c12;
        background-color: #fffcf5;
    }
    /* 选项选中后的样式 */
    .option.selected {
        background-color: #e6f0ff;
        border-left: 3px solid #3498db;
    }
    /* 阶段性练习顺序选择样式 */
    input[name="stage-order"]:checked + span {
        font-weight: 600;
        color: #3498db;
    }
    input[name="stage-order"]:checked {
        accent-color: #3498db;
    }
    label:has(input[name="stage-order"]:checked) {
        background-color: #e6f0ff;
        border-color: #3498db !important;
    }
    label:has(input[name="stage-order"]):hover {
        border-color: #3498db;
        background-color: #f7f9fc;
    }
    /* 动画效果 */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .fade-in {
        animation: fadeIn 0.5s ease forwards;
    }
    
    /* 主题切换按钮 */
    .theme-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, #3498db, #2980b9);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        transition: all 0.3s;
    }
    .theme-toggle:hover {
        transform: scale(1.1);
    }
    
    /* 中断返回按钮 */
    .interrupt-btn {
        position: fixed;
        top: 80px;
        right: 20px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        z-index: 1000;
        transition: all 0.3s;
        border: none;
        font-size: 20px;
    }
    .interrupt-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6);
    }
    .interrupt-btn.show {
        display: flex;
    }
    .interrupt-btn i {
        pointer-events: none;
    }
    
    /* 暗色主题 */
    body.dark-theme {
        background-color: #1a1a2e;
        color: #f0f0f0;
    }
    body.dark-theme .container,
    body.dark-theme .question,
    body.dark-theme #results,
    body.dark-theme .password-container,
    body.dark-theme .mode-selection-container,
    body.dark-theme .question-count-container {
        background-color: #16213e;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
    }
    body.dark-theme h1,
    body.dark-theme h2,
    body.dark-theme .question-title {
        color: #f0f0f0;
    }
    body.dark-theme .option:hover {
        background-color: #1f3156;
    }
    body.dark-theme .option.selected {
        background-color: #1f3156;
    }
    body.dark-theme .password-input,
    body.dark-theme .question-count-input {
        background-color: #242c48;
        border-color: #2a365c;
        color: #f0f0f0;
    }
    body.dark-theme #timer {
        background-color: #1f3156;
        color: #f0f0f0;
    }
    body.dark-theme .filter-btn {
        background-color: #242c48;
        border-color: #2a365c;
        color: #f0f0f0;
    }
    body.dark-theme .progress {
        background-color: #242c48;
    }
  </style>
  <!-- 添加一些图标 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
  <!-- 主题切换按钮 -->
  <div class="theme-toggle" id="theme-toggle">
    <i class="fas fa-moon"></i>
  </div>
  
  <!-- 中断返回按钮 -->
  <button class="interrupt-btn" id="interrupt-btn" title="中断并返回">
    <i class="fas fa-times"></i>
  </button>

  <!-- 密码保护层 -->
  <div id="password-protection" class="password-container fade-in">
      <h2><i class="fas fa-lock"></i> 请输入密码访问考试系统</h2>
      <input type="password" id="password-input" class="password-input" placeholder="请输入密码" autofocus>
      <button id="password-submit" class="btn"><i class="fas fa-sign-in-alt"></i> 提交</button>
      <div id="error-message" class="error-message"><i class="fas fa-exclamation-circle"></i> 密码错误，请重试！</div>
  </div>

  <!-- 章节选择层 -->
  <div id="chapter-selection" class="mode-selection-container hidden fade-in">
      <h2><i class="fas fa-book-open"></i> 请选择章节题库</h2>
      <p>选择您想要练习的章节</p>
      <div class="mode-btn-container">
          <button class="mode-btn chapter-btn" data-chapter="chapter1" style="background: linear-gradient(135deg, #3498db, #2980b9); color: white;">
              <i class="fas fa-book"></i>
              第一章
              <small id="chapter1-count">共 0 题</small>
          </button>
          <button class="mode-btn chapter-btn" data-chapter="chapter2" style="background: linear-gradient(135deg, #2ecc71, #27ae60); color: white;">
              <i class="fas fa-book"></i>
              第二章
              <small id="chapter2-count">共 0 题</small>
          </button>
          <button class="mode-btn chapter-btn" data-chapter="chapter3" style="background: linear-gradient(135deg, #e74c3c, #c0392b); color: white;">
              <i class="fas fa-book"></i>
              第三章
              <small id="chapter3-count">共 0 题</small>
          </button>
          <button class="mode-btn chapter-btn" data-chapter="chapter4" style="background: linear-gradient(135deg, #f39c12, #e67e22); color: white;">
              <i class="fas fa-book"></i>
              第四章
              <small id="chapter4-count">共 0 题</small>
          </button>
          <button class="mode-btn chapter-btn" data-chapter="chapter5" style="background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white;">
              <i class="fas fa-book"></i>
              第五章
              <small id="chapter5-count">共 0 题</small>
          </button>
          <button class="mode-btn chapter-btn" data-chapter="chapter6" style="background: linear-gradient(135deg, #1abc9c, #16a085); color: white;">
              <i class="fas fa-book"></i>
              第六章
              <small id="chapter6-count">共 0 题</small>
          </button>
          <button class="mode-btn chapter-btn" data-chapter="chapter7" style="background: linear-gradient(135deg, #34495e, #2c3e50); color: white;">
              <i class="fas fa-book"></i>
              第七章
              <small id="chapter7-count">共 0 题</small>
          </button>
      </div>
      <button id="chapter-back-btn" class="btn btn-danger" style="margin-top: 20px;">
          <i class="fas fa-arrow-left"></i> 返回密码页
      </button>
  </div>

  <!-- 模式选择层 -->
  <div id="mode-selection" class="mode-selection-container hidden fade-in">
      <h2><i class="fas fa-tasks"></i> 请选择学习模式</h2>
      <p>选择适合您的学习方式</p>
      <div class="mode-btn-container">
          <button id="practice-mode-btn" class="mode-btn practice-mode">
              <i class="fas fa-book"></i>
              练习模式
              <small>做题后立即查看答案</small>
          </button>
          <button id="exam-mode-btn" class="mode-btn exam-mode">
              <i class="fas fa-clipboard-check"></i>
              考试模式
              <small>提交后统一查看结果</small>
          </button>
          <button id="stage-mode-btn" class="mode-btn practice-mode">
              <i class="fas fa-layer-group"></i>
              阶段性练习/考试
              <small>选择题目区间进行针对性练习</small>
          </button>
          <button id="calibrate-mode-btn" class="mode-btn" style="background: linear-gradient(135deg, #f39c12, #e67e22); color: white;">
              <i class="fas fa-sliders-h"></i>
              答案校准模式
              <small>校准和修正题库答案</small>
          </button>
          <button id="memorize-mode-btn" class="mode-btn" style="background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white;">
              <i class="fas fa-brain"></i>
              背题模式
              <small>直接查看题目和答案</small>
          </button>
      </div>
  </div>

  <!-- 阶段性练习题目区间选择层 -->
  <div id="stage-selection" class="question-count-container hidden fade-in">
      <h2><i class="fas fa-sliders-h"></i> 阶段性练习 - 选择题目区间</h2>
      <p>题库总数：<span id="stage-total-count">955</span>题</p>
      <div style="margin: 20px 0;">
          <div style="margin-bottom: 15px;">
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">起始题号：</label>
              <input type="number" id="stage-start-input" class="question-count-input" min="1" placeholder="请输入起始题号" style="margin: 0;">
          </div>
          <div style="margin-bottom: 15px;">
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">结束题号：</label>
              <input type="number" id="stage-end-input" class="question-count-input" min="1" placeholder="请输入结束题号" style="margin: 0;">
          </div>
          <div style="margin-bottom: 15px;">
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">出题顺序：</label>
              <div style="display: flex; gap: 10px; justify-content: center;">
                  <label style="display: flex; align-items: center; cursor: pointer; padding: 10px 20px; border: 2px solid #e6eef5; border-radius: 8px; transition: all 0.3s;">
                      <input type="radio" name="stage-order" value="sequential" checked style="margin-right: 8px; transform: scale(1.2);">
                      <span><i class="fas fa-sort-numeric-down"></i> 顺序出题</span>
                  </label>
                  <label style="display: flex; align-items: center; cursor: pointer; padding: 10px 20px; border: 2px solid #e6eef5; border-radius: 8px; transition: all 0.3s;">
                      <input type="radio" name="stage-order" value="random" style="margin-right: 8px; transform: scale(1.2);">
                      <span><i class="fas fa-random"></i> 随机打乱</span>
                  </label>
              </div>
          </div>
      </div>
      <div style="margin: 20px 0; padding: 15px; background: #f7f9fc; border-radius: 8px; font-size: 14px; color: #7f8c8d;">
          <i class="fas fa-info-circle"></i> 提示：例如选择 1-10 表示练习第1题到第10题。顺序出题按题号顺序显示，随机打乱则会打乱题目顺序。
      </div>
      <div style="display: flex; gap: 10px; justify-content: center;">
          <button id="stage-practice-submit" class="btn btn-secondary" style="flex: 1; max-width: 200px;">
              <i class="fas fa-book"></i> 练习模式
          </button>
          <button id="stage-exam-submit" class="btn" style="flex: 1; max-width: 200px;">
              <i class="fas fa-clipboard-check"></i> 考试模式
          </button>
      </div>
      <button id="stage-back-btn" class="btn btn-danger" style="margin-top: 10px;">
          <i class="fas fa-arrow-left"></i> 返回模式选择
      </button>
      <div id="stage-error-message" class="error-message"><i class="fas fa-exclamation-circle"></i> 请输入有效的题目区间！</div>
  </div>

  <!-- 题目数量选择层 -->
  <div id="question-count-selection" class="question-count-container hidden fade-in">
      <h2><i class="fas fa-list-ol"></i> 请选择题目数量</h2>
      <p>题库总数：955题</p>
      <input type="number" id="question-count-input" class="question-count-input" min="1" max="955" placeholder="请输入题目数量（1-955）" autofocus>
      
      <!-- 背题模式的顺序选择 -->
      <div id="memorize-order-selection" style="display: none; margin: 15px 0;">
          <label style="display: block; margin-bottom: 5px; font-weight: 500;">出题顺序：</label>
          <div style="display: flex; gap: 10px; justify-content: center;">
              <label style="display: flex; align-items: center; cursor: pointer; padding: 10px 20px; border: 2px solid #e6eef5; border-radius: 8px; transition: all 0.3s;">
                  <input type="radio" name="memorize-order" value="sequential" checked style="margin-right: 8px; transform: scale(1.2);">
                  <span><i class="fas fa-sort-numeric-down"></i> 顺序背题</span>
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; padding: 10px 20px; border: 2px solid #e6eef5; border-radius: 8px; transition: all 0.3s;">
                  <input type="radio" name="memorize-order" value="random" style="margin-right: 8px; transform: scale(1.2);">
                  <span><i class="fas fa-random"></i> 随机乱序</span>
              </label>
          </div>
      </div>
      
      <button id="question-count-submit" class="btn"><i class="fas fa-play"></i> 开始练习</button>
      <div id="count-error-message" class="error-message"><i class="fas fa-exclamation-circle"></i> 请输入有效的题目数量！</div>
  </div>

  <!-- 考试系统内容 -->
  <div id="exam-content" class="hidden fade-in">
      <div class="container">
          <h1>ICT-昇腾AI备考系统</h1>
          
          <!-- 显示当前模式 -->
          <div id="current-mode" style="text-align: center; margin-bottom: 15px; font-weight: bold; color: #3498db;"></div>
          
          <!-- 显示作答用时 -->
          <div id="timer"><i class="fas fa-clock"></i> 已用时: 00:00</div>
          
          <div class="progress">
              <div class="progress-bar" id="progress-bar"></div>
          </div>
          
          <div id="exam-form">
              <!-- 题目由 JavaScript 动态生成 -->
          </div>
          
          <button id="submit-btn" class="btn"><i class="fas fa-paper-plane"></i> 提交答案</button>
          
          <div id="results">
              <div class="result-header">
                  <h2><i class="fas fa-chart-pie"></i> 测试结果</h2>
                  <div>
                      <span id="score">0</span>/<span id="total">0</span>
                      <span>正确率: <span id="accuracy">0%</span></span>
                  </div>
              </div>
              
              <!-- 结果统计卡片 -->
              <div class="result-summary">
                  <div class="result-item">
                      <span class="value" id="summary-score">0</span>
                      <span class="label">得分</span>
                  </div>
                  <div class="result-item">
                      <span class="value" id="summary-total">0</span>
                      <span class="label">总题数</span>
                  </div>
                  <div class="result-item">
                      <span class="value" id="summary-accuracy">0%</span>
                      <span class="label">正确率</span>
                  </div>
                  <div class="result-item">
                      <span class="value" id="summary-time">00:00</span>
                      <span class="label">用时</span>
                  </div>
              </div>
              
              <!-- 显示总作答用时 -->
              <div id="final-time" style="text-align: center; font-size: 16px; margin-bottom: 15px;"></div>
              
              <div class="filter-controls">
                  <button class="filter-btn active" data-filter="all"><i class="fas fa-list"></i> 全部题目</button>
                  <button class="filter-btn" data-filter="incorrect"><i class="fas fa-times"></i> 错题复习</button>
              </div>
              
              <div id="result-details">
                  <!-- 结果详情由 JavaScript 动态生成 -->
              </div>
              
              <div style="text-align: center; margin-top: 30px;">
                  <button id="restart-btn" class="btn btn-secondary"><i class="fas fa-redo"></i> 重新测试</button>
                  <button id="reselect-btn" class="btn"><i class="fas fa-cog"></i> 返回模式选择</button>
                  <button id="retry-incorrect-btn" class="btn btn-danger"><i class="fas fa-times-circle"></i> 错题重新测试</button>
              </div>
          </div>
      </div>
  </div>

  <script>
      // 题库数据 - ICT昇腾AI题库（按章节分类）
      const questionBanks = {
          chapter1: [
    {
        "id": 1,
        "question": "完整的计算机系统应包括（）。",
        "options": ["A) 运算器、存储器、控制器", "B) 外部设备和主机", "C) 主机和应用程序", "D) 配套的硬件设备和软件系统"],
        "answer": "C"
    },
    {
        "id": 2,
        "question": "冯·诺依曼机的基本工作方式是（）。",
        "options": ["A) 控制流驱动方式", "B) 多指令多数据流方式", "C) 微程序控制方式", "D) 数据流驱动方式"],
        "answer": "C"
    },
    {
        "id": 3,
        "question": "下列（）是冯·诺依曼机工作方式的基本特点。",
        "options": ["A) 多指令流单数据流", "B) 按地址访问并顺序执行指令", "C) 堆栈操作", "D) 存储器按内容选择地址"],
        "answer": "C"
    },
    {
        "id": 4,
        "question": "以下说法错误的是（）。",
        "options": ["A) 硬盘是外部设备", "B) 软件的功能与硬件的功能在逻辑上是等价的", "C) 硬件实现的功能一般比软件实现具有更高的执行速度", "D) 软件的功能不能用硬件取代"],
        "answer": "C"
    },
    {
        "id": 5,
        "question": "存放当前执行指令的寄存器是（）。",
        "options": ["A) MAR", "B) PC", "C) MDP", "D) IR"],
        "answer": "C"
    },
    {
        "id": 6,
        "question": "在CPU中，跟踪下一条要执行的指令的地址的寄存器是（）。",
        "options": ["A) PC", "B) MAR", "C) MDR", "D) IR"],
        "answer": "C"
    },
    {
        "id": 7,
        "question": "CPU不包括（）。",
        "options": ["A) 地址寄存器", "B) 指令寄存器", "C) 地址译码器", "D) 通用寄存器"],
        "answer": "C"
    },
    {
        "id": 8,
        "question": "MAR和MDR的位数分别为（）。",
        "options": ["A) 地址码长度、存储字长", "B) 存储字长、存储字长", "C) 地址码长度、地址码长度", "D) 存储字长、地址码长度"],
        "answer": "C"
    },
    {
        "id": 9,
        "question": "在运算器中，不包含（）。",
        "options": ["A) 状态寄存器", "B) 数据总线", "C) ALU", "D) 地址寄存器"],
        "answer": "C"
    },
    {
        "id": 10,
        "question": "下列关于CPU存取速度的比较中，正确的是（）。",
        "options": ["A) Cache > 内存 > 寄存器", "B) Cache > 寄存器 > 内存", "C) 寄存器 > Cache > 内存", "D) 寄存器 > 内存 > Cache"],
        "answer": "C"
    },
    {
        "id": 11,
        "question": "若一个8位的计算机系统以16位来表示地址，则该计算机系统有（）个地址空间。",
        "options": ["A) 256", "B) 65535", "C) 65536", "D) 131072"],
        "answer": "C"
    },
    {
        "id": 12,
        "question": "（）是程序运行时的存储位置，包括所需的数据。",
        "options": ["A) 数据通路", "B) 主存", "C) 硬盘", "D) 操作系统"],
        "answer": "C"
    },
    {
        "id": 13,
        "question": "关于编译程序和解释程序，下列说法中错误的是（）。",
        "options": ["A) 编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序", "B) 编译程序编译时间较长，运行速度较快", "C) 解释程序方法较简单，运行速度也较快", "D) 解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句"],
        "answer": "C"
    },
    {
        "id": 14,
        "question": "可以在计算机中直接执行的语言和用助记符编写的语言分别是（）。",
        "options": ["A) 汇编语言、高级语言", "B) 汇编语言、操作系统原语", "C) 机器语言、汇编语言", "D) 机器语言、正则语言"],
        "answer": "C"
    },
    {
        "id": 15,
        "question": "只有当程序执行时才将源程序翻译成机器语言，并且一次只能翻译一行语句，边翻译边执行的是（）程序。",
        "options": ["A) 编译", "B) 目标", "C) 汇编", "D) 解释"],
        "answer": "C"
    },
    {
        "id": 16,
        "question": "下列关于各种级别语言的描述中，错误的是（）。",
        "options": ["A) 可用高级语言和低级语言编写出功能等价的程序", "B) 低级语言的执行效率一般情况下高于高级语言", "C) 机器语言源程序可在机器上直接执行，而高级语言和汇编语言源程序不可以", "D) 汇编语言与机器结构无关"],
        "answer": "C"
    },
    {
        "id": 17,
        "question": "下列关于机器指令和汇编指令的叙述中，错误的是（）。",
        "options": ["A) 可以直接用机器语言（机器指令）编写程序", "B) 汇编指令和机器指令都能被计算机直接执行", "C) 汇编语言和机器语言都与计算机系统结构相关", "D) 汇编指令和机器指令一一对应，功能相同"],
        "answer": "C"
    },
    {
        "id": 18,
        "question": "下列叙述中，正确的是（）。",
        "options": ["A) 实际应用程序的测试结果能够全面代表计算机的性能", "B) 系列机的基本特性是指令系统向后兼容", "C) 软件和硬件在逻辑功能上是等价的", "D) 以上都正确"],
        "answer": "C"
    },
    {
        "id": 19,
        "question": "在CPU的组成中，不包括（）。",
        "options": ["A) 运算器、寄存器、控制器", "B) 存储器", "C) 控制器", "D) 奇存器"],
        "answer": "C"
    },
    {
        "id": 20,
        "question": "关于相联存储器，下列说法中正确的是（）。",
        "options": ["A) 只可以按地址寻址", "B) 只可以按内容寻址", "C) 既可按地址寻址又可按内容寻址", "D) 以上说法均不完善"],
        "answer": "C"
    },
    {
        "id": 21,
        "question": "计算机硬件能够直接执行的是（）。",
        "options": ["A) 仅机器语言程序", "B) 仅机器语言和汇编语言程序", "C) 仅机器语言和硬件描述语言程序", "D) 汇编语言和硬件描述语言程序"],
        "answer": "C"
    },
    {
        "id": 22,
        "question": "将高级语言源程序转换为机器级目标代码文件的程序是（）。",
        "options": ["A) 汇编程序", "B) 链接程序", "C) 编译程序", "D) 解释程序"],
        "answer": "C"
    },
    {
        "id": 23,
        "question": "下列关于冯·诺依曼计算机基本思想的叙述中，错误的是（）。",
        "options": ["A) 程序的功能都通过中央处理器执行指令实现", "B) 指令和数据都用二进制数表示，形式上无差别", "C) 指令按地址访问，数据都在指令中直接给出", "D) 程序执行前，指令和数据需预先存放在存储器中"],
        "answer": "C"
    },
    {
        "id": 24,
        "question": "将高级语言源程序转换为可执行目标文件的主要过程是（）。",
        "options": ["A) 预处理→编译→汇编→链接", "B) 预处理→汇编→编译→链接", "C) 预处理→编译→链接→汇编", "D) 预处理→汇编→链接→编译"],
        "answer": "C"
    },
    {
        "id": 25,
        "question": "关于CPU主频、CPI、MIPS、MFLOPS，说法正确的是（）。",
        "options": ["A) CPU主频是指CPU系统执行指令的频率，CPI是执行一条指令平均使用的频率", "B) CPI是执行一条指令平均使用CPU时钟的个数，MIPS描述一条CPU指令平均使用的CPU时钟数", "C) MIPS是描述CPU执行指令的频率，MFLOPS是计算机系统的浮点数指令", "D) CPU主频指CPU使用的时钟脉冲频率，CPI是执行一条指令平均使用的CPU时钟数"],
        "answer": "C"
    },
    {
        "id": 26,
        "question": "存储字长是指（）。",
        "options": ["A) 存放在一个存储单元中的二进制代码组合", "B) 存放在一个存储单元中的二进制代码位数", "C) 存储单元的个数", "D) 机器指令的位数"],
        "answer": "C"
    },
    {
        "id": 27,
        "question": "以下说法中，错误的是（）。",
        "options": ["A) 计算机的机器字长是指数据运算的基本单位长度", "B) 寄存器是由触发器构成的", "C) 计算机中一个字的长度都是32位", "D) 磁盘可以永久性存放数据和程序"],
        "answer": "C"
    },
    {
        "id": 28,
        "question": "下列关于机器字长、指令字长和存储字长的说法中，正确的是（）。",
        "options": ["A) 三者在数值上总是相等的", "B) 三者在数值上可能不等", "C) 存储字长是存放在一个存储单元中的二进制代码位数", "D) 机器字长就是MDR的位数"],
        "answer": "C"
    },
    {
        "id": 29,
        "question": "下列关于机器字长的叙述中，错误的是（）。",
        "options": ["A) 机器字长是指CPU中定点运算的数据通路宽度", "B) 机器字长一般与CPU中通用寄存器的位数有关", "C) 机器字长决定了数据的表示范围和表示精度", "D) 机器字长对计算机硬件的造价没有影响"],
        "answer": "C"
    },
    {
        "id": 30,
        "question": "32位微机是指该计算机所用CPU（）。",
        "options": ["A) 具有32位寄存器", "B) 能同时处理32位的二进制数", "C) 具有32个寄存器", "D) 能处理32个字符"],
        "answer": "C"
    },
    {
        "id": 31,
        "question": "在用于科学计算的计算机中，标志系统性能的最有用的参数是（）。",
        "options": ["A) 主时钟频率", "B) 主存容量", "C) MFLOPS", "D) MIPS"],
        "answer": "C"
    },
    {
        "id": 32,
        "question": "在计算机M1和计算机M2上分别运行功能完全相同的高级语言程序，程序在M1和M2上的平均CPI相等，则对于该类程序而言（）。",
        "options": ["A) M1和M2执行速度相等", "B) M1和M2中主频高的计算机执行速度快", "C) M1和M2中主频低的计算机执行速度快", "D) 无法确定哪台机器的执行速度快"],
        "answer": "C"
    },
    {
        "id": 33,
        "question": "若一台计算机的机器字长为4B，则表明该机器（）。",
        "options": ["A) 能处理的数值最大为4位十进制数", "B) 能处理的数值最多为4位二进制数", "C) 在CPU中能够作为一个整体处理32位的二进制代码", "D) 在CPU中运算的结果最大为2^32"],
        "answer": "C"
    },
    {
        "id": 34,
        "question": "在CPU的寄存器中，（）对用户是完全透明的。",
        "options": ["A) 程序计数器", "B) 指令寄存器", "C) 状态寄存器", "D) 通用寄存器"],
        "answer": "C"
    },
    {
        "id": 35,
        "question": "计算机操作的最小单位时间是（）。",
        "options": ["A) 时钟周期", "B) 指令周期", "C) CPU周期", "D) 中断周期"],
        "answer": "C"
    },
    {
        "id": 36,
        "question": "计算机中，CPU的CPI与下列（）因素无关。",
        "options": ["A) 时钟频率", "B) 系统结构", "C) 指令集", "D) 计算机组织"],
        "answer": "C"
    },
    {
        "id": 37,
        "question": "从用户观点看，评价计算机系统性能的综合参数是（）。",
        "options": ["A) 指令系统", "B) 吞吐率", "C) 主存容量", "D) 主频率"],
        "answer": "C"
    },
    {
        "id": 38,
        "question": "当前设计高性能计算机的重要技术途径是（）。",
        "options": ["A) 提高CPU主频", "B) 扩大主存容量", "C) 采用非冯诺依曼体系结构", "D) 采用并行处理技术"],
        "answer": "C"
    },
    {
        "id": 39,
        "question": "下列关于“兼容”的叙述，正确的是（）。",
        "options": ["A) 指计算机软件与硬件之间的通用性，通常在同一系列不同型号的计算机间存在", "B) 指计算机软件或硬件的通用性，即它们在任何计算机间可以通用", "C) 指计算机软件或硬件的通用性，通常在同一系列不同型号的计算机间通用", "D) 指软件在不同系列计算机中可以通用，而硬件不能通用"],
        "answer": "C"
    },
    {
        "id": 40,
        "question": "若某基准测试程序在机器A上运行需要的时间是20s，而在机器B上的运行时间是16s，那么，相对来说，下列给出的结论中，（）是正确的。",
        "options": ["A) 所有程序在机器A上都比在机器B上运行速度慢", "B) 机器B的速度是机器A的1.25倍", "C) 机器A的速度是机器B的1.25倍", "D) 机器A比机器B慢1.25倍"],
        "answer": "C"
    },
    {
        "id": 41,
        "question": "机器A的主频为800MHz，某程序在A上运行需要12s。现在硬件设计人员想设计机器B，希望该程序在B上的运行时间能缩短为8s，使用新技术后可使B的主频大幅度提高，但在B上运行该程序所需的时钟周期数为在A上的1.5倍。则机器B的主频至少应为（）。",
        "options": ["A) 800MHz", "B) 1.2GHz", "C) 1.5GHz", "D) 1.8GHz"],
        "answer": "C"
    },
    {
        "id": 42,
        "question": "下列可用于评价计算机系统性能的指标是（）。",
        "options": ["A) MIPS、CPI", "B) MIPS、CPI、字长", "C) MIPS、IPC、CPI", "D) 全部"],
        "answer": "C"
    },
    {
        "id": 43,
        "question": "计算机的机器字长与下列（）指标最为密切相关。",
        "options": ["A) 运算速度", "B) 存取速度", "C) 内存容量", "D) 运算精确度"],
        "answer": "C"
    },
    {
        "id": 44,
        "question": "假定编译器对高级语言的某条语句可以编译生成两种不同的指令序列，A、B和C三类指令的CPI和两种不同序列所含的三类指令条数如下表所示，两个指令序列都在时钟周期为2ns的机器上运行，则下列结论中正确的是（）。",
        "options": ["A) 序列一的MIPS数比序列二多50，序列一的执行速度比序列二快10ns", "B) 序列一的MIPS数比序列二多50，序列二的执行速度比序列一快10ns", "C) 序列二的MIPS数比序列一多50，序列一的执行速度比序列二快10ns", "D) 序列二的MIPS数比序列一多50，序列二的执行速度比序列一快10ns"],
        "answer": "C"
    },
    {
        "id": 45,
        "question": "下列给出的改善计算机性能的4种措施中，能缩短其执行时间的措施是（）。",
        "options": ["A) 用更快的处理器来替换原来的慢速处理器", "B) 增加同类处理器个数，使得不同的处理器同时执行程序", "C) 优化编译生成的代码，使得程序执行的总时钟周期数减少", "D) 减少指令执行过程中访问内存的时间"],
        "answer": "C"
    },
    {
        "id": 46,
        "question": "下列选项中，能缩短程序执行时间的措施是（）。",
        "options": ["A) 提高CPU时钟频率", "B) 优化数据通路结构", "C) 对程序进行编译优化", "D) 以上全部"],
        "answer": "C"
    },
    {
        "id": 47,
        "question": "下列选项中，描述浮点数操作速度指标的是（）。",
        "options": ["A) MIPS", "B) CPI", "C) IPC", "D) MFLOPS"],
        "answer": "C"
    },
    {
        "id": 48,
        "question": "假定基准程序A在某计算机上的运行时间为100s，其中90s为CPU时间，其余为I/O时间。若CPU速度提高50%，I/O速度不变，则运行基准程序A所耗费的时间是（）。",
        "options": ["A) 55s", "B) 60s", "C) 65s", "D) 70s"],
        "answer": "C"
    },
    {
        "id": 49,
        "question": "某计算机的主频为1.2GHz，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示。该机的MIPS数是（）。",
        "options": ["A) 100", "B) 200", "C) 400", "D) 600"],
        "answer": "C"
    },
    {
        "id": 50,
        "question": "程序P在机器M上的执行时间是20s，编译优化后，P执行的指令数减少到原来的70%，而CPI增加到原来的1.2倍，则P在M上的执行时间是（）。",
        "options": ["A) 8.4s", "B) 11.7s", "C) 14s", "D) 16.8s"],
        "answer": "C"
    },
    {
        "id": 51,
        "question": "假定计算机M1和M2具有相同的指令集体系结构(ISA)，主频分别为1.5GHz和1.2GHz。在M1和M2上运行某基准程序P平均CPI分别为2和1，则程序P在M1和M2上运行时间的比值是（）。",
        "options": ["A) 0.4", "B) 0.625", "C) 1.6", "D) 2.5"],
        "answer": "C"
    },
    {
        "id": 52,
        "question": "下列给出的部件中，其位数（宽度）一定与机器字长相同的是（）。",
        "options": ["A) ALU、指令寄存器", "B) ALU、通用寄存器", "C) 指令寄存器、通用寄存器", "D) ALU、指令寄存器、通用寄存器、浮点寄存器"],
        "answer": "C"
    },
    {
        "id": 53,
        "question": "2017年公布的全球超级计算机TOP500排名中，我国“神威·太湖之光”超级计算机蝉联第一，其浮点运算速度为93.0146PFLOPS，说明该计算机每秒完成的浮点操作次数约为（）。",
        "options": ["A) 9.3×10^13次", "B) 9.3×10^15次", "C) 9.3千万亿次", "D) 9.3亿亿次"],
        "answer": "C"
    },
    {
        "id": 54,
        "question": "某计算机主频为1GHz，程序P运行过程中，共执行了10000条指令，其中，80%的指令执行平均需1个时钟周期，20%的指令执行平均需10个时钟周期。程序P的平均CPI和CPU执行时间分别是（）。",
        "options": ["A) 8, 28μs", "B) 28, 28μs", "C) 2.8, 28μs", "D) 28, 28ms"],
        "answer": "C"
    },
    {
        "id": 55,
        "question": "若机器M的主频为1.5GHz，在M上执行程序P的指令条数为5×10^5，P的平均CPI为1.2，则P在M上的指令执行速度和用户CPU时间分别为（）。",
        "options": ["A) 0.8GIPS, 0.4ms", "B) 0.8GIPS, 0.4μs", "C) 1.25GIPS, 0.4ms", "D) 1.25GIPS, 0.4μs"],
        "answer": "C"
    }
]
              // 第一章题目，等待添加
          ,
          chapter2: [
    {
        "id": 1,
        "question": "若十进制数为137.5，则其八进制数为（）。",
        "options": ["A) 89.8", "B) 211.4", "C) 211.5", "D) 1011111.101"],
        "answer": "C"
    },
    {
        "id": 2,
        "question": "一个16位无符号二进制数的表示范围是（）。",
        "options": ["A) 0~65536", "B) 0~65535", "C) -32768~32767", "D) -32768~32768"],
        "answer": "B"
    },
    {
        "id": 3,
        "question": "下列说法有误的是（）。",
        "options": ["A) 任何二进制整数都可以用十进制表示", "B) 任何二进制小数都可以用十进制表示", "C) 任何十进制整数都可以用二进制表示", "D) 任何十进制小数都可以用二进制表示"],
        "answer": "D"
    },
    {
        "id": 4,
        "question": "对真值0表示形式唯一的机器数是（）。",
        "options": ["A) 原码", "B) 补码和移码", "C) 反码", "D) 以上都不对"],
        "answer": "B"
    },
    {
        "id": 5,
        "question": "若[x]补=1.1101010，则[x]原为（）。",
        "options": ["A) 1.0010101", "B) 1.0010110", "C) 0.0010110", "D) 0.1101010"],
        "answer": "B"
    },
    {
        "id": 6,
        "question": "若X为负数，则由[x]补求[-x]补是将（）。",
        "options": ["A) [x]补各值保持不变", "B) [x]补符号位变反，其他各位不变", "C) [x]补除符号位外，各位变反，末位加1", "D) [x]补连同符号位一起变反，末位加1"],
        "answer": "C"
    },
    {
        "id": 7,
        "question": "8位原码能表示的不同数据有（）个。",
        "options": ["A) 15", "B) 16", "C) 255", "D) 256"],
        "answer": "C"
    },
    {
        "id": 8,
        "question": "一个n+1位整数x原码的数值范围是（）。",
        "options": ["A) -2^n+1 < x < 2^n-1", "B) -2^n+1 ≤ x < 2^n-1", "C) -2^n+1 < x ≤ 2^n-1", "D) -2^n+1 ≤ x ≤ 2^n-1"],
        "answer": "B"
    },
    {
        "id": 9,
        "question": "n位定点整数（有符号）表示的最大值是（）。",
        "options": ["A) 2^n", "B) 2^n-1", "C) 2^(n-1)", "D) 2^(n-1)-1"],
        "answer": "B"
    },
    {
        "id": 10,
        "question": "对于相同位数（设为N位，不考虑符号位）的二进制补码小数和十进制小数，二进制小数能表示的数的个数/十进制小数所能表示数的个数为（）。",
        "options": ["A) 0.2^N", "B) 0.2^(N-1)", "C) 0.02^N", "D) 0.02^(N-1)"],
        "answer": "C"
    },
    {
        "id": 11,
        "question": "若定点整数为64位，含1位符号位，则采用补码表示的绝对值最大的负数为（）。",
        "options": ["A) -2^64", "B) -(2^64-1)", "C) -2^63", "D) -(2^63-1)"],
        "answer": "C"
    },
    {
        "id": 12,
        "question": "下列关于补码和移码关系的叙述中，不正确的是（）。",
        "options": ["A) 相同位数的补码和移码表示具有相同的数据表示范围", "B) 0的补码和移码表示相同", "C) 同一个数的补码和移码表示，其数值部分相同，而符号相反", "D) 一般用移码表示浮点数的阶码，而补码表示定点整数"],
        "answer": "B"
    },
    {
        "id": 13,
        "question": "若[x]补=1,X1X2X3X4X5X6，其中Xi取0或1，若要x>-32，应当满足（）。",
        "options": ["A) x1为0，其他各位任意", "B) x1为1，其他各位任意", "C) x1为1，x2~x6中至少有一位为1", "D) x1为0，x2~x6中至少有一位为1"],
        "answer": "C"
    },
    {
        "id": 14,
        "question": "设x为整数，[x]补=1,X1X2X3X4X5，若要x<-16，应满足的条件是（）。",
        "options": ["A) x1~x5至少有一个为1", "B) x1必须为0，x2~x5至少有一个为1", "C) x1必须为0，x2~x5任意", "D) x1必须为1，x2~x5任意"],
        "answer": "C"
    },
    {
        "id": 15,
        "question": "设x为真值，x*为其绝对值，满足[-x]补=[-x*]补，当且仅当（）。",
        "options": ["A) x任意", "B) x为正数", "C) x为负数", "D) 以上说法都不对"],
        "answer": "C"
    },
    {
        "id": 16,
        "question": "假定一个十进制数为-66，按补码形式存放在一个8位寄存器中，该寄存器的内容用十六进制表示为（）。",
        "options": ["A) C2H", "B) BEH", "C) BDH", "D) 42H"],
        "answer": "B"
    },
    {
        "id": 17,
        "question": "设机器数采用补码表示（含1位符号位），若寄存器内容为9BH，则对应的十进制数为（）。",
        "options": ["A) -27", "B) -97", "C) -101", "D) 155"],
        "answer": "C"
    },
    {
        "id": 18,
        "question": "若寄存器内容为10000000，若它等于-0，则为（）。",
        "options": ["A) 原码", "B) 补码", "C) 反码", "D) 移码"],
        "answer": "C"
    },
    {
        "id": 19,
        "question": "若寄存器内容为11111111，若它等于+127，则为（）。",
        "options": ["A) 反码", "B) 补码", "C) 原码", "D) 移码"],
        "answer": "C"
    },
    {
        "id": 20,
        "question": "若寄存器内容为11111111，若它等于-1，则为（）。",
        "options": ["A) 原码", "B) 补码", "C) 反码", "D) 移码"],
        "answer": "B"
    },
    {
        "id": 21,
        "question": "若寄存器内容为00000000，若它等于-128，则为（）。",
        "options": ["A) 原码", "B) 补码", "C) 反码", "D) 移码"],
        "answer": "D"
    },
    {
        "id": 22,
        "question": "若二进制定点小数真值是-0.1101，机器表示为1.0010，则为（）。",
        "options": ["A) 原码", "B) 补码", "C) 反码", "D) 移码"],
        "answer": "C"
    },
    {
        "id": 23,
        "question": "下列为8位移码机器数[x]移，求[-x]移时，将会发生溢出的是（）。",
        "options": ["A) 11111111", "B) 00000000", "C) 10000000", "D) 01111111"],
        "answer": "B"
    },
    {
        "id": 24,
        "question": "一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则下列说法中正确的是（）。",
        "options": ["A) 若采用移码表示，偏置值为127，则此整数最小为-64", "B) 若采用移码表示，偏置值为128，则此整数最大为123", "C) 若采用补码表示，则此整数最小为-96", "D) 若采用补码表示，则此整数最大为252"],
        "answer": "C"
    },
    {
        "id": 25,
        "question": "计算机内部的定点数大多用补码表示，以下叙述中，（）是补码表示的特点。",
        "options": ["A) Ⅰ和Ⅱ", "B) Ⅰ和Ⅲ", "C) Ⅰ、Ⅱ和Ⅲ", "D) Ⅰ、Ⅱ和Ⅳ"],
        "answer": "D"
    },
    {
        "id": 26,
        "question": "在计算机中，通常用来表示主存地址的是（）。",
        "options": ["A) 移码", "B) 补码", "C) 原码", "D) 无符号数"],
        "answer": "D"
    },
    {
        "id": 27,
        "question": "16位补码Ox8FA0扩展为32位应该是（）。",
        "options": ["A) 0x0000 8FA0", "B) 0xFFFF 8FA0", "C) 0xFFFF FFA0", "D) 0x8000 8FA0"],
        "answer": "C"
    },
    {
        "id": 28,
        "question": "假定编译器规定int型和short型长度分别为32位和16位，执行下列代码：unsigned short x=65530; unsigned int y=x; 得到y的机器数为（）。",
        "options": ["A) 0000 7FFAH", "B) 0000 FFFAH", "C) FFFF 7FFAH", "D) FFFF FFFAH"],
        "answer": "B"
    },
    {
        "id": 29,
        "question": "由3个“1”和5个“0”组成的8位二进制补码，能表示的最小整数是（）。",
        "options": ["A) -126", "B) -125", "C) -32", "D) -3"],
        "answer": "B"
    },
    {
        "id": 30,
        "question": "unsigned short usi = si; 执行后，usi的值为（）。",
        "options": ["A) 43767", "B) 32767", "C) 32768", "D) 32769"],
        "answer": "C"
    },
    {
        "id": 31,
        "question": "冯·诺依曼结构计算机中的数据采用二进制编码表示，其主要原因是（）。",
        "options": ["A) 仅Ⅰ、Ⅱ", "B) 仅Ⅰ、Ⅲ", "C) 仅Ⅱ、Ⅲ", "D) Ⅰ、Ⅱ和Ⅲ"],
        "answer": "D"
    },
    {
        "id": 32,
        "question": "unsigned short usi = 65535; short si = usi; 执行后，si的值是（）。",
        "options": ["A) -1", "B) -32767", "C) -32768", "D) -65535"],
        "answer": "A"
    },
    {
        "id": 33,
        "question": "已知有符号整数用补码表示，变量x,y,z的机器数分别为FFFDH、FFDFH、7FFCH，下列结论中正确的是（）。",
        "options": ["A) 若为无符号整数，则z<x<y", "B) 若为无符号整数，则x<y<z", "C) 若为有符号整数，则x<y<z", "D) 若为有符号整数，则y<x<z"],
        "answer": "D"
    },
    {
        "id": 34,
        "question": "32位补码所能表示的整数范围是（）。",
        "options": ["A) -2^32 ~ 2^32-1", "B) -2^31 ~ 2^31-1", "C) -2^32 ~ 2^31-1", "D) -2^31 ~ 2^32-1"],
        "answer": "B"
    },
    {
        "id": 35,
        "question": "ALU作为运算器的核心部件，其属于（）。",
        "options": ["A) 时序逻辑电路", "B) 组合逻辑电路", "C) 控制器", "D) 寄存器"],
        "answer": "B"
    },
    {
        "id": 36,
        "question": "组成一个运算器需要多个部件，但下面的（）不是组成运算器的部件。",
        "options": ["A) 状态寄存器", "B) 数据总线", "C) ALU", "D) 地址寄存器"],
        "answer": "D"
    },
    {
        "id": 37,
        "question": "算术逻辑单元（ALU）的功能一般包括（）。",
        "options": ["A) 算术运算", "B) 逻辑运算", "C) 算术运算和逻辑运算", "D) 加法运算"],
        "answer": "C"
    },
    {
        "id": 38,
        "question": "补码定点整数01010101算术左移两位后的值为（）。",
        "options": ["A) 0100011", "B) 01010100", "C) 01000110", "D) 01010101"],
        "answer": "C"
    },
    {
        "id": 39,
        "question": "下列四个补码整数存放于8位寄存器中，算术左移不会发生溢出的是（）。",
        "options": ["A) 80H", "B) 90H", "C) B0H", "D) C0H"],
        "answer": "B"
    },
    {
        "id": 40,
        "question": "补码定点整数10010101右移一位后的值为（）。",
        "options": ["A) 1001010", "B) 10010101", "C) 10001010", "D) 溢位"],
        "answer": "A"
    },
    {
        "id": 41,
        "question": "两个机器数7E5H和4D3H相加，得（）。",
        "options": ["A) BD8H", "B) CD8H", "C) CB8H", "D) CC8H"],
        "answer": "B"
    },
    {
        "id": 42,
        "question": "设机器数字长8位（含1位符号位），若机器数BAH为补码，算术左移1位和算术右移1位分别得（）。",
        "options": ["A) F4H, EDH", "B) B4H, 6DH", "C) 74H, DDH", "D) B5H, EDH"],
        "answer": "B"
    },
    {
        "id": 43,
        "question": "在定点运算器中，无论是采用双符号位还是采用单符号位，必须有（）。",
        "options": ["A) 译码电路", "B) 编码电路", "C) 溢出判断电路", "D) 移位电路"],
        "answer": "C"
    },
    {
        "id": 44,
        "question": "机器运算发生溢出的根本原因是（）。",
        "options": ["A) 寄存器的位数有限", "B) 运算中将符号位的进位丢弃", "C) 运算中将符号位的借位丢弃", "D) 数据运算中发生错误"],
        "answer": "A"
    },
    {
        "id": 45,
        "question": "假定有两个整数用8位补码分别表示为r1=F5H，r2=EEH。若将运算结果存放在一个8位寄存器中，则下列运算会发生溢出的是（）。",
        "options": ["A) r1+r2", "B) r1-r2", "C) r1*r2", "D) r1/r2"],
        "answer": "A"
    },
    {
        "id": 46,
        "question": "关于模4补码，下列说法正确的是（）。",
        "options": ["A) 模4补码和模2补码不同，它更容易检查乘除运算中的溢出问题", "B) 比每个模4补码存储时只需一个符号位", "C) 存储每个模4补码需要两个符号位", "D) 模4补码在算术与逻辑单元中为一个符号位"],
        "answer": "C"
    },
    {
        "id": 47,
        "question": "若采用双符号位，则两个正数相加产生溢出的特征时，双符号位为（）。",
        "options": ["A) 00", "B) 01", "C) 10", "D) 11"],
        "answer": "B"
    },
    {
        "id": 48,
        "question": "判断加减法溢出时，可采用判断进位的方式，若符号位的进位为C0，最高位的进位为C1，则产生溢出的条件是（）。",
        "options": ["A) C0产生进位", "B) C1产生进位", "C) C0、C1都产生进位", "D) C0产生进位，C1不产生进位或 c0不产生进位，c1产生进位"],
        "answer": "D"
    },
    {
        "id": 49,
        "question": "在补码的加减法中，用两位符号位判断溢出，两位符号位SsS=10时，表示（）。",
        "options": ["A) 结果为正数，无溢出", "B) 结果正溢出", "C) 结果负溢出", "D) 结果为负数，无溢出"],
        "answer": "C"
    },
    {
        "id": 50,
        "question": "若[x]补=X0X1X2...Xn，其中X0为符号位，X1为最高数位，若（）则当补码左移时，将会发生溢出。",
        "options": ["A) X0=X1", "B) X0≠X1", "C) X0=0", "D) X1=1"],
        "answer": "B"
    },
    {
        "id": 51,
        "question": "原码乘法是（）。",
        "options": ["A) 先取操作数绝对值相乘，符号位单独处理", "B) 用原码表示操作数，然后直接相乘", "C) 被乘数用原码表示，乘数取绝对值，然后相乘", "D) 乘数用原码表示，被乘数取绝对值，然后相乘"],
        "answer": "A"
    },
    {
        "id": 52,
        "question": "在原码乘法中，（）。",
        "options": ["A) 符号位参加运算", "B) 符号位不参加运算", "C) 符号位参加运算，并根据运算结果改变结果中的符号位", "D) 符号位不参加运算，并根据运算结果确定结果中的符号"],
        "answer": "D"
    },
    {
        "id": 53,
        "question": "原码乘法时，符号位单独处理乘积的方式是（）。",
        "options": ["A) 两个操作数的符号相“与”", "B) 两个操作数的符号相“或”", "C) 两个操作数的符号相“异或”", "D) 两个操作数中绝对值较大数的符号"],
        "answer": "C"
    },
    {
        "id": 54,
        "question": "下列关于移位运算的说法中，正确的是（）。",
        "options": ["A) Ⅰ、Ⅲ", "B) 仅Ⅱ", "C) 只有Ⅲ", "D) Ⅰ、Ⅱ、Ⅲ"],
        "answer": "D"
    },
    {
        "id": 55,
        "question": "某计算机字长为8位，CPU中有一个8位加法器。已知无符号数x=69，y=38，若在该加法器中计算x-y，则加法器的两个输入端信息和输入的低位进位信息分别为（）。",
        "options": ["A) 01000101、00100110、0", "B) 01000101、11011001、1", "C) 01000101、11011010、0", "D) 01000101、11011010、1"],
        "answer": "D"
    },
    {
        "id": 56,
        "question": "某计算机中有一个8位加法器，有符号整数x和y的机器数用补码表示，[x]补=F5H，[y]补=7EH，若在该加法器中计算x-y，则加法器的低位进位输入信息和运算后的溢出标志OF分别是（）。",
        "options": ["A) 1、1", "B) 1、0", "C) 0、1", "D) 0、0"],
        "answer": "B"
    },
    {
        "id": 57,
        "question": "某8位计算机中，x和y是两个有符号整数，用补码表示，[x]补=44H，[y]补=DCH，则x/2+2y的机器数及相应的溢出标志OF分别是（）。",
        "options": ["A) CAH、0", "B) CAH、1", "C) DAH、0", "D) DAH、1"],
        "answer": "A"
    },
    {
        "id": 58,
        "question": "某8位计算机中，x和y是两个有符号整数，用补码表示，[x]补=44H，[y]补=DCH，则x-2y的机器数及相应的溢出标志OF分别是（）。",
        "options": ["A) 8CH、1", "B) 8CH、0", "C) 68H、1", "D) 68H、0"],
        "answer": "B"
    },
    {
        "id": 59,
        "question": "一个C语言程序在一台32位机器上运行。程序中定义了三个变量x、y、z，其中x和z为int型，y为short型。当x=127，y=-9时，执行赋值语句z=x+y后，x、y、z的值分别是（）。",
        "options": ["A) X=0000007FH,y=FFF9H,z=00000076H", "B) X=0000007FH,y=FFF9H,z=FFFF0076H", "C) X=0000007FH,y=FFF7H,z=FFFF0076H", "D) X=0000007FH,y=FFF7H,z=00000076H"],
        "answer": "C"
    },
    {
        "id": 60,
        "question": "假定有四个整数用8位补码分别表示：r1=FEH，r2=F2H，r3=90H，r4=F8H，若将运算结果存放在一个8位寄存器中，则下列运算会发生溢出的是（）。",
        "options": ["A) r1*r2", "B) r2*r3", "C) r1*r4", "D) r2*r4"],
        "answer": "B"
    },
    {
        "id": 61,
        "question": "某字长为8位的计算机中，已知整型变量x、y的机器数分别为[x]补=11110100，[y]补=10110000。若整型变量z=2x+y/2，则z的机器数为（）。",
        "options": ["A) 11000000", "B) 10010000", "C) 10101010", "D) 11000000"],
        "answer": "A"
    },
    {
        "id": 62,
        "question": "若x=103，y=-25，则下列表达式采用8位定点补码运算实现时，会发生溢出的是（）。",
        "options": ["A) x+y", "B) -x+y", "C) x-y", "D) -x-y"],
        "answer": "C"
    },
    {
        "id": 63,
        "question": "假定有符号整数采用补码表示，若int型变量x和y的机器数分别是FFFFFFDFH和00000041H，则x、y的值及x-y的机器数分别是（）。",
        "options": ["A) x=-65,y=41,x-y的机器数溢出", "B) x=-33,y=65,x-y的机器数为FFFF FF9DH", "C) x=-33,y=65,x-y的机器数为FFFFFF9EH", "D) x=-65,y=41,x-y的机器数为FFFFFF96H"],
        "answer": "B"
    },
    {
        "id": 64,
        "question": "整数x的机器数为11011000，分别对x进行逻辑右移1位和算术右移1位操作，得到的机器数各是（）。",
        "options": ["A) 11101100、11101100", "B) 01101100、11101100", "C) 11101100、01101100", "D) 01101100、01101100"],
        "answer": "B"
    },
    {
        "id": 65,
        "question": "减法指令“sub R1,R2,R3”的功能为“(R1)-(R2)→R3”，该指令执行后将生成进位/借位标志CF和溢出标志OF。若(R1)=FFFFFFFFH，(R2)=FFFFFFF0H，则该减法指令执行后，CF与OF分别为（）。",
        "options": ["A) CF=0,OF=0", "B) CF=1,OF=0", "C) CF=0,OF=1", "D) CF=1,OF=1"],
        "answer": "B"
    },
    {
        "id": 66,
        "question": "已知x,y为int类型，当x=100,y=200时，执行“x减y”指令得到的溢出标志OF和借位标志CF分别为0,1，那么当x=10,y=-20时，执行该指令得到的OF和CF分别为（）。",
        "options": ["A) OF=0,CF=0", "B) OF=0,CF=1", "C) OF=1,CF=0", "D) OF=1,CF=1"],
        "answer": "A"
    },
    {
        "id": 67,
        "question": "在C语言的不同类型的数据混合运算中，要先转换成同一类型后进行运算。设一表达式中包含有int型、long型、char型和double型的变量与数据，则表达式最后的运算结果是（）。",
        "options": ["A) long,int→char→double→long", "B) long,char→int→long→double", "C) double,char→int→long→double", "D) double,char→int→double→long"],
        "answer": "C"
    },
    {
        "id": 68,
        "question": "长度相同但格式不同的两种浮点数，假设前者阶码长、尾数短，后者阶码短、尾数长，其他规定均相同，则它们可表示的数的范围和精度为（）。",
        "options": ["A) 两者可表示的数的范围和精度相同", "B) 前者可表示的数的范围大但精度低", "C) 后者可表示的数的范围大且精度高", "D) 前者可表示的数的范围大且精度高"],
        "answer": "B"
    },
    {
        "id": 69,
        "question": "长度相同、格式相同的两种浮点数，假设前者基数大，后者基数小，其他规定均相同，则它们可表示的数的范围和精度为（）。",
        "options": ["A) 两者可表示的数的范围和精度相同", "B) 前者可表示的数的范围大但精度低", "C) 后者可表示的数的范围大且精度高", "D) 前者可表示的数的范围大且精度高"],
        "answer": "B"
    },
    {
        "id": 70,
        "question": "下列说法中正确的是（）。",
        "options": ["A) 采用变形补码进行加减法运算可以避免溢出", "B) 只有定点数运算才可能溢出，浮点数运算不会产生溢出", "C) 定点数和浮点数运算都可能产生溢出", "D) 两个正数相加时一定产生溢出"],
        "answer": "C"
    },
    {
        "id": 71,
        "question": "在规格化浮点运算中，若某浮点数为2^5×1.10101，其中尾数为补码表示，则该数（）。",
        "options": ["A) 不需规格化", "B) 需右移规格化", "C) 需将尾数左移一位规格化", "D) 需将尾数左移两位规格化"],
        "answer": "C"
    },
    {
        "id": 72,
        "question": "某浮点机，采用规格化浮点数表示，阶码用移码表示（最高位代表符号位），尾数用原码表示。下列（）的表示不是规格化浮点数。",
        "options": ["A) 11111111,1.1000...00", "B) 0011111,1.011...01", "C) 1000001,0.1111...01", "D) 0111111,0.1000...10"],
        "answer": "B"
    },
    {
        "id": 73,
        "question": "下列关于对阶操作说法正确的是（）。",
        "options": ["A) 在浮点加减运算的对阶操作中，若阶码减小，则尾数左移", "B) 在浮点加减运算的对阶操作中，若阶码增大，则尾数右移；若阶码减小，则尾数左移", "C) 在浮点加减运算的对阶操作中，若阶码增大，则尾数右移", "D) 以上都不对"],
        "answer": "C"
    },
    {
        "id": 74,
        "question": "浮点数的IEEE754标准对尾数编码采用的是（）。",
        "options": ["A) 原码", "B) 反码", "C) 补码", "D) 移码"],
        "answer": "A"
    },
    {
        "id": 75,
        "question": "在IEEE754标准规定的64位浮点数格式中，符号位为1位，阶码为11位，尾数为52位，则它所能表示的最小规格化负数为（）。",
        "options": ["A) -(2-2^(-52))×2^(-1023)", "B) -(2-2^(-52))×2^1023", "C) -1×2^1024", "D) -(1-2^(-52))×2^2047"],
        "answer": "B"
    },
    {
        "id": 76,
        "question": "按照IEEE754标准规定的32位单精度浮点数41A4C000H对应的十进制数是（）。",
        "options": ["A) 4.59375", "B) -20.59375", "C) -4.59375", "D) 20.59375"],
        "answer": "D"
    },
    {
        "id": 77,
        "question": "在浮点数编码表示中，（）在机器数中不出现，是隐含的。",
        "options": ["A) 阶码", "B) 符号", "C) 尾数", "D) 基数"],
        "answer": "D"
    },
    {
        "id": 78,
        "question": "若某单精度浮点数、某原码、某补码、某移码的32位机器数均为0xF0000000，则这些数从大到小的顺序是（）。",
        "options": ["A) 浮>原>补>移", "B) 浮>移>补>原", "C) 移>原>补>浮", "D) 移>补>原>浮"],
        "answer": "D"
    },
    {
        "id": 79,
        "question": "采用规格化的浮点数最主要是为了（）。",
        "options": ["A) 增加数据的表示范围", "B) 方便浮点运算", "C) 防止运算时数据溢出", "D) 增加数据的表示精度"],
        "answer": "D"
    },
    {
        "id": 80,
        "question": "下列说法中，正确的是（）。",
        "options": ["A) Ⅰ", "B) Ⅰ和Ⅱ", "C) Ⅰ、Ⅱ和Ⅲ", "D) Ⅰ、Ⅱ"],
        "answer": "D"
    },
    {
        "id": 81,
        "question": "在浮点运算中，下溢指的是（）。",
        "options": ["A) 运算结果的绝对值小于机器所能表示的最小绝对值", "B) 运算的结果小于机器所能表示的最小负数", "C) 运算的结果小于机器所能表示的最小正数", "D) 运算结果的最低有效位产生的错误"],
        "answer": "A"
    },
    {
        "id": 82,
        "question": "判断浮点数运算是否溢出，取决于（）。",
        "options": ["A) 尾数是否上溢", "B) 尾数是否下溢", "C) 阶码是否上溢", "D) 阶码是否下溢"],
        "answer": "C"
    },
    {
        "id": 83,
        "question": "假定采用IEEE754标准中的单精度浮点数格式表示一个数为45100000H，则该数的值是（）。",
        "options": ["A) (+1.125)×2^10", "B) (+1.125)×2^11", "C) (+0.125)×2^11", "D) (+0.125)×2^10"],
        "answer": "B"
    },
    {
        "id": 84,
        "question": "已知float型采用IEEE754单精度浮点格式，若x、y为float型变量，且x=-126，y=15.75，则执行语句z=x+y时，在浮点运算单元中进行对阶操作后的结果是（）。",
        "options": ["A) x不变，y为010000101,0.001111110...0", "B) x不变，y为010000110,0.001111110...0", "C) y不变，x为110000101,0.001111110...0", "D) y不变，x为110000110,0.001111110...0"],
        "answer": "A"
    },
    {
        "id": 85,
        "question": "在IEEE754标准浮点格式中，非规格化浮点数表示为（）。",
        "options": ["A) 阶码为0，尾数为任意非0的二进制数", "B) 阶码为255，尾数全为0", "C) 阶码为255，尾数为任意非0的二进制数", "D) 阶码为0，尾数全为0"],
        "answer": "A"
    },
    {
        "id": 86,
        "question": "在规格化的浮点数中，将阶码部分的n位移码表示改为n位补码表示，其他不变，则浮点数的表示范围（）。",
        "options": ["A) 增大", "B) 减小", "C) 不变", "D) 都不对"],
        "answer": "B"
    },
    {
        "id": 87,
        "question": "设浮点数共12位，其中阶码含1位阶符共4位，以2为底，补码表示；尾数含1位符号共8位，补码表示，规格化。则该浮点数所能表示的最大正数是（）。",
        "options": ["A) 2^7", "B) 2^8", "C) 2^8-1", "D) 2^7-1"],
        "answer": "A"
    },
    {
        "id": 88,
        "question": "计算机在进行浮点数的加减运算之前先进行对阶操作，若x的阶码大于y的阶码，则应将（）。",
        "options": ["A) x的阶码缩小至与y的阶码相同，且使x的尾数部分进行算术左移", "B) x的阶码缩小至与y的阶码相同，且使x的尾数部分进行算术右移", "C) y的阶码扩大至与x的阶码相同，且使y的尾数部分进行算术左移", "D) y的阶码扩大至与x的阶码相同，且使y的尾数部分进行算术右移"],
        "answer": "D"
    },
    {
        "id": 89,
        "question": "若浮点数的尾数用补码表示，则下列（）中的尾数是规格化数形式。",
        "options": ["A) 1.1100", "B) 0.01110", "C) 0.01010", "D) 1.00010"],
        "answer": "D"
    },
    {
        "id": 90,
        "question": "设浮点数的基数为4，尾数用原码表示，则以下（）是规格化的数。",
        "options": ["A) 1.001101", "B) 0.001101", "C) 1.011011", "D) 0.0010"],
        "answer": "A"
    },
    {
        "id": 91,
        "question": "下列关于舍入的说法，正确的是（）。",
        "options": ["A) Ⅰ、Ⅱ、Ⅴ", "B) Ⅰ、Ⅱ、Ⅴ", "C) Ⅴ", "D) Ⅰ、Ⅳ"],
        "answer": "D"
    },
    {
        "id": 92,
        "question": "计算机中的信息按边界对齐方式存储的含义是（）。",
        "options": ["A) 信息的字节长度必须是整数", "B) 信息单元的字节长度必须是整数", "C) 信息单元的存储地址必须是整数", "D) 信息单元的存储地址是其字节长度的整数倍"],
        "answer": "D"
    },
    {
        "id": 93,
        "question": "假设已定义三个int型变量x、y和z，sizeof(int)=4，double型采用IEEE754双精度浮点数格式，变量dx、dy和dz的声明和初始化如下：double dx=(double)x；double dy=(double)y；double dz=(double)z；则下列关系表达式中永远为真的是（）。",
        "options": ["A) Ⅰ和Ⅱ", "B) Ⅱ和Ⅲ", "C) Ⅲ和Ⅳ", "D) Ⅱ和Ⅳ"],
        "answer": "D"
    },
    {
        "id": 94,
        "question": "在按字节编址的计算机中，采用小端方式存储数据，某静态二维数组b的声明如下：static short b[2][4]={{1,2,9,-1},{5,3,1,-6}}；若b的首地址为0x8049820，采用按行优先存储，地址0x804982c中的内容是（）。",
        "options": ["A) FAH", "B) FFH", "C) 00H", "D) 05H"],
        "answer": "B"
    },
    {
        "id": 95,
        "question": "在按字节编址的计算机中，数据在存储器中以小端方式存放。假定int型变量i的地址为08000000H，i的机器数为01234567H，地址08000000H单元的内容是（）。",
        "options": ["A) 01H", "B) 23H", "C) 45H", "D) 67H"],
        "answer": "D"
    },
    {
        "id": 96,
        "question": "在按字节编址的32位计算机中，按边界对齐方式为以下结构型变量x分配存储空间：struct cont_info {char id；unsigned post；char phone；}x；若x的首地址为0x8049820，则成员变量phone的起始地址为（）。",
        "options": ["A) 0x8049828", "B) 0x8049826", "C) 0x8049825", "D) 0x8049822"],
        "answer": "A"
    },
    {
        "id": 97,
        "question": "在按字节编址、采用大端方式的16位计算机中，执行完下列C语言程序片段后，m的低字节地址的内容为（）。int n=0xA1B6；unsigned int m=n；m=m>>1；",
        "options": ["A) 50H", "B) A1H", "C) B6H", "D) DBH"],
        "answer": "B"
    },
    {
        "id": 98,
        "question": "假定变量i、f的数据类型分别是int、float。已知i=12345，f=1.2345×10^3，则在一个32位机器中执行下列表达式时，结果为“假”的是（）。",
        "options": ["A) i==(int)(double)i", "B) f==(float)(double)f", "C) i==(int)(float)i", "D) f==(float)(int)f"],
        "answer": "D"
    },
    {
        "id": 99,
        "question": "有以下C语言代码：int m=13；float a=12.6，x；x=m/2+a/2；printf(\"%f\\n\",x)；执行上述代码后，输出的x值为（）。",
        "options": ["A) 12.000", "B) 12.300000", "C) 12.800000", "D) 12"],
        "answer": "B"
    },
    {
        "id": 100,
        "question": "浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为5和7（均含2位符号位）。若有两个数X=2^7×29/32和Y=2^5×5/8，则用浮点加法计算X+Y的最终结果是（）。",
        "options": ["A) 001111100010", "B) 001110100010", "C) 010000010001", "D) 发生溢出"],
        "answer": "D"
    },
    {
        "id": 101,
        "question": "假定变量i、f和d的数据类型分别为int、float和double（int型用补码表示，float型和double型分别用IEEE754单精度和双精度浮点数格式表示）。已知i=785、f=1.5678E3、d=1.5E100，若在32位机器中执行下列关系表达式，则结果为“真”的是（）。",
        "options": ["A) 仅Ⅰ和Ⅱ", "B) 仅Ⅰ和Ⅲ", "C) 仅Ⅱ和Ⅲ", "D) 仅Ⅲ和Ⅳ"],
        "answer": "B"
    },
    {
        "id": 102,
        "question": "float型数据通常用IEEE754单精度格式表示。若编译器将float型变量x分配在一个32位浮点寄存器FR1中，且x=-8.25，则FR1的内容是（）。",
        "options": ["A) C1040000H", "B) C2420000H", "C) C1840000H", "D) C10C2000H"],
        "answer": "A"
    },
    {
        "id": 103,
        "question": "float型（即IEEE754单精度浮点数格式）能表示的最大正整数是（）。",
        "options": ["A) 2^126-2^103", "B) 2^127-2^107", "C) 2^127-2^103", "D) 2^128-2^104"],
        "answer": "C"
    },
    {
        "id": 104,
        "question": "某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定int型和short型长度分别为32位和16位，并且数据按边界对齐存储。某C语言程序段如下：struct t {int a；char b；short c；}record；record.a=273；若record变量的首地址为0xC008，地址0xC008中的内容及record.c的地址分别为（）。",
        "options": ["A) 0x00、0xC00D", "B) 0x00、0xC00E", "C) 0x11、0xC00D", "D) 0x11、0xC00E"],
        "answer": "D"
    },
    {
        "id": 105,
        "question": "某数采用IEEE754单精度浮点数格式表示为C6400000H，则该数的值是（）。",
        "options": ["A) -1.5×2^13", "B) -1.5×2^11", "C) -0.5×2^13", "D) -0.5×2^12"],
        "answer": "A"
    },
    {
        "id": 106,
        "question": "float型数据常用IEEE754单精度浮点格式表示。假设两个float型变量x和y分别存放在32位寄存器f1和f2中，若(f1)=CC900000H，(f2)=BOC00000H，则x和y之间的关系为（）。",
        "options": ["A) x<y且符号相同", "B) x<y且符号不同", "C) x>y且符号相同", "D) x>y且符号不同"],
        "answer": "B"
    },
    {
        "id": 107,
        "question": "下列有关浮点数加减运算的叙述中，正确的是（）。",
        "options": ["A) 仅Ⅱ、Ⅲ", "B) 仅Ⅰ、Ⅱ、Ⅳ", "C) 仅Ⅰ、Ⅲ、Ⅳ", "D) Ⅰ、Ⅱ、Ⅲ、Ⅳ"],
        "answer": "D"
    },
    {
        "id": 108,
        "question": "某计算机字长为32位，按字节编址，采用小端方式存放数据。假定有一个double型变量，其机器数表示为1122334455667788H，存放在以00008040H开始的连续存储单元中，则存储单元00008046H中存放的是（）。",
        "options": ["A) 22H", "B) 33H", "C) 77H", "D) 66H"],
        "answer": "B"
    },
    {
        "id": 109,
        "question": "IEEE754单精度浮点格式表示的数中，最小的规格化正数是（）。",
        "options": ["A) 1.0×2^(-126)", "B) 1.0×2^(-127)", "C) 1.0×2^(-128)", "D) 1.0×2^(-149)"],
        "answer": "A"
    },
    {
        "id": 110,
        "question": "某32位计算机按字节编址，采用小端方式。若语句“int i=0；”对应指令的机器代码为“C7 45 FC 00 00 00 00”，则语句“int i=-64；”对应指令的机器代码是（）。",
        "options": ["A) C7 45 FC C0 FF FF FF", "B) C7 45 FC 0C FF FF FF", "C) C7 45 FC FF FF FF C0", "D) C7 45 FC FF FF FF 0C"],
        "answer": "A"
    },
    {
        "id": 111,
        "question": "在按字节编址、采用小端方式的32位计算机中，按边界对齐方式为以下C语言结构型变量a分配存储空间：struct record {short x1；int x2；}a；若a的首地址为2020FE00H，a的成员变量x2的机器数为12340000H，则其中34H所在存储单元的地址是（）。",
        "options": ["A) 2020 FE03H", "B) 2020 FE04H", "C) 2020 FE05H", "D) 2020 FE06H"],
        "answer": "C"
    },
    {
        "id": 112,
        "question": "已知有符号整数用补码表示，float型数据用IEEE754标准表示，假定变量x的类型只可能是int或float，当x的机器数为C8000000H时，x的值可能是（）。",
        "options": ["A) -7×2^22", "B) -2^16", "C) 2^7", "D) 2.5×2^27"],
        "answer": "A"
    },
    {
        "id": 113,
        "question": "下列数值中，不能用IEEE754浮点格式精确表示的是（）。",
        "options": ["A) 1.2", "B) 1.25", "C) 2", "D) 2.5"],
        "answer": "A"
    },
    {
        "id": 114,
        "question": "-0.4375的IEEE754单精度浮点数表示为（）。",
        "options": ["A) BEE00000H", "B) B60000H", "C) BF700000H", "D) C0E0000H"],
        "answer": "A"
    },
    {
        "id": 115,
        "question": "若short型变量x=-8190，则x的机器数是（）。",
        "options": ["A) E002H", "B) E001H", "C) 9FFCH", "D) 9FFEH"],
        "answer": "B"
    },
    {
        "id": 116,
        "question": "已知float型变量用IEEE754单精度浮点数格式表示。若float型变量x的机器数为80200000H，则x的值是（）。",
        "options": ["A) -2^(-128)", "B) -1.01×2^(-127)", "C) -1.01×2^(-126)", "D) 非数(NaN)"],
        "answer": "B"
    },
    {
        "id": 117,
        "question": "某C语言代码段如下：int si=65536；short i=si；unsigned j=0；if(i<=j-1) printf(\"王道\")；else printf(\"计算机教育\")；当上述代码段执行到if分支条件的判断时，会根据标志寄存器中的（）决定执行顺序。最终的输出结果是（）。",
        "options": ["A) CF，王道", "B) CF，计算机教育", "C) OF，王道", "D) OF，计算机教育"],
        "answer": "B"
    },
    {
        "id": 118,
        "question": "C语言代码段如下，执行该代码段后，si的值是（）。int i=32777；short si=i；int j=si；",
        "options": ["A) -32777", "B) -32759", "C) 32759", "D) 32777"],
        "answer": "C"
    },
    {
        "id": 119,
        "question": "下列关于整数乘法运算的叙述中，错误的是（）。",
        "options": ["A) 用阵列乘法器实现的乘运算可以在一个时钟周期内完成", "B) 用ALU和移位器实现的乘运算无法在一个时钟周期内完成", "C) 变量与常数的乘运算可编译优化为若干移位及加/减运算指令", "D) 两个变量的乘运算无法编译转换为移位及加法等指令的循环实现"],
        "answer": "D"
    },
    {
        "id": 120,
        "question": "某科学实验中，需要使用大量的整型参数，为了在保证表数精度的基础上提高运算速度，需要选择合理的数据表示方法。若整型参数α、β的取值范围分别为-2^2～2^2、-2^4～2^4，则在下列选项中，α、β最适合采用的数据表示方法分别是（）。",
        "options": ["A) 32位整数、32位整数", "B) 单精度浮点数、单精度浮点数", "C) 32位整数、双精度浮点数", "D) 单精度浮点数、双精度浮点数"],
        "answer": "A"
    }
]        ,
          chapter3: [
    {
        "id": 1,
        "question": "磁盘属于（）类型的存储器。",
        "options": ["A) 随机存储器(RAM)", "B) 只读存储器(ROM)", "C) 顺序存取存储器(SAM)", "D) 直接存取存储器(DAM)"],
        "answer": "C"
    },
    {
        "id": 2,
        "question": "存储器的存取周期是指（）",
        "options": ["A) 存储器的读出时间", "B) 存储器的写入时间", "C) 存储器进行连续读或写操作所允许的最短时间间隔", "D) 存储器进行一次读或写操作所需的平均时间"],
        "answer": "C"
    },
    {
        "id": 3,
        "question": "设机器字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其可寻址的单元数是（）。",
        "options": ["A) 2^24", "B) 2^23", "C) 2^22", "D) 2^21"],
        "answer": "C"
    },
    {
        "id": 4,
        "question": "相联存储器是按（）进行寻址的存储器。",
        "options": ["A) 地址指定方式", "B) 堆栈存储方式", "C) 内容指定方式和堆栈存储方式相结合", "D) 内容指定方式和地址指定方式相结合"],
        "answer": "C"
    },
    {
        "id": 5,
        "question": "在下列几种存储器中，CPU不能直接访问的是（）",
        "options": ["A) 硬盘", "B) 内存", "C) Cache", "D) 寄存器"],
        "answer": "C"
    },
    {
        "id": 6,
        "question": "若某存储器存储周期为250ns，每次读出16位，该存储器的数据传输速率是（）。",
        "options": ["A) 4×10^6 B/s", "B) 16MB/s", "C) 8×10^6 B/s", "D) 8×2^20 B/s"],
        "answer": "C"
    },
    {
        "id": 7,
        "question": "设机器字长为64位，存储容量为128MB，若按字编址，它可寻址的单元个数是（）。",
        "options": ["A) 16MB", "B) 16M", "C) 32M", "D) 32MB"],
        "answer": "C"
    },
    {
        "id": 8,
        "question": "计算机的存储器采用分级方式是为了（）",
        "options": ["A) 方便编程", "B) 解决容量、速度、价格三者之间的矛盾", "C) 保存大量数据方便", "D) 操作方便"],
        "answer": "C"
    },
    {
        "id": 9,
        "question": "计算机的存储系统是指（）",
        "options": ["A) RAM", "B) ROM", "C) 主存储器", "D) 寄存器、Cache、主存储器和外存储器"],
        "answer": "C"
    },
    {
        "id": 10,
        "question": "在多级存储体系中，“Cache-主存”结构的作用是解决（）的问题。",
        "options": ["A) 主存容量不足", "B) 主存与辅存速度不匹配", "C) 辅存与CPU速度不匹配", "D) 主存与CPU速度不匹配"],
        "answer": "C"
    },
    {
        "id": 11,
        "question": "存储器分层体系结构中，存储器从速度最快到最慢的排列顺序是（）",
        "options": ["A) 寄存器-主存-Cache-辅存", "B) 寄存器-主存-辅存-Cache", "C) 寄存器-Cache-辅存-主存", "D) 寄存器-Cache-主存-辅存"],
        "answer": "C"
    },
    {
        "id": 12,
        "question": "在Cache和主存构成的两级存储体系中，主存与Cache同时访问，Cache的存取时间是100ns，主存的存取时间是1000ns，若希望有效（平均）存取时间不超过Cache存取时间的115%，则Cache的命中率至少应为（）",
        "options": ["A) 0.9", "B) 0.98", "C) 0.95", "D) 0.99"],
        "answer": "C"
    },
    {
        "id": 13,
        "question": "下列关于多级存储系统的说法中，正确的有（）\nI. 多级存储系统是为了降低存储成本\nII. 虚拟存储器中主存和辅存之间的数据调动对任何程序员是透明的\nIII. CPU只能与Cache直接交换信息，CPU与主存交换信息也需要经过Cache",
        "options": ["A) 仅I", "B) 仅I和II", "C) I、II和III", "D) 仅II"],
        "answer": "C"
    },
    {
        "id": 14,
        "question": "下列各类存储器中，不采用随机存取方式的是（）",
        "options": ["A) EPROM", "B) CD-ROM", "C) DRAM", "D) SRAM"],
        "answer": "C"
    },
    {
        "id": 15,
        "question": "某一SRAM芯片，容量为1024×8位，该芯片的地址引脚和数据引脚总数至少是（）",
        "options": ["A) 8", "B) 10", "C) 18", "D) 12"],
        "answer": "C"
    },
    {
        "id": 16,
        "question": "某存储器容量为32K×16位，则（）",
        "options": ["A) 地址线为16根，数据线为32根", "B) 地址线为32根，数据线为16根", "C) 地址线为15根，数据线为16根", "D) 地址线为15根，数据线为32根"],
        "answer": "C"
    },
    {
        "id": 17,
        "question": "DRAM的刷新是以（）为单位的",
        "options": ["A) 存储单元", "B) 行", "C) 列", "D) 存储字"],
        "answer": "C"
    },
    {
        "id": 18,
        "question": "DRAM采用下列哪种刷新方式时，不存在死时间（）",
        "options": ["A) 集中刷新", "B) 分散刷新", "C) 异步刷新", "D) 都不对"],
        "answer": "C"
    },
    {
        "id": 19,
        "question": "下面是有关DRAM和SRAM存储器芯片的叙述，通常情况下，错误的是（）\nI. DRAM芯片的集成度比SRAM芯片的高\nII. DRAM芯片的成本比SRAM芯片的高\nIII. DRAM芯片的速度比SRAM芯片的快\nIV. DRAM芯片工作时需要刷新，SRAM芯片工作时不需要刷新",
        "options": ["A) I和II", "B) II和III", "C) III和IV", "D) I和IV"],
        "answer": "C"
    },
    {
        "id": 20,
        "question": "下列关于随机存储器的说法中，正确的是（）",
        "options": ["A) 半导体RAM信息可读可写，且断电后仍能保持记忆", "B) DRAM是易失性RAM，而SRAM中的存储信息是不易失的", "C) 半导体RAM是易失性RAM，但只要电源不断电，所存信息是不丢失的", "D) 半导体RAM是非易失性RAM"],
        "answer": "C"
    },
{
    "id": 21,
    "question": "下列关于存储器的说法中，不正确的是（）",
    "options": ["A) 随机存储器和只读存储器不可以统一编址", "B) 在访问随机存储器时，访问时间与存储单元的物理位置无关", "C) 随机存储器RAM芯片可随机存取信息，掉电后信息会丢失", "D) 只读存储器ROM芯片可随机存取信息，掉电后信息不会丢失"],
    "answer": "C"
  },
  {
    "id": 22,
    "question": "关于半导体存储器的组织，下列选项中（）是不正确的。",
    "options": ["A) 在同一个存储器中，每个存储单元的宽度可以不同", "B) 所谓“编址”，是指给每个存储单元一个编号", "C) 存储器的核心部分是存储阵列，由若干存储单元构成", "D) 每个存储单元由若干存储元件构成，每个存储元件存储一个比特位"],
    "answer": "C"
  },
  {
    "id": 23,
    "question": "关于SRAM和DRAM，下列叙述中正确的是（）",
    "options": ["A) 通常SRAM依靠电容暂存电荷来存储信息，电容上有电荷为1，无电荷为0", "B) DRAM依靠双稳态电路的两个稳定状态来分别存储0和1", "C) SRAM速度较快，但集成度稍低；DRAM速度稍慢，但集成度高", "D) SRAM速度较慢，但集成度稍高；DRAM速度稍快，但集成度低"],
    "answer": "C"
  },
  {
    "id": 24,
    "question": "某一DRAM芯片，采用地址复用技术，容量为1024×8位，该芯片的地址引脚和数据引脚总数至少是（）",
    "options": ["A) 18", "B) 13", "C) 8", "D) 17"],
    "answer": "C"
  },
  {
    "id": 25,
    "question": "下列几种存储器中，（）是易失性存储器。",
    "options": ["A) Cache", "B) EPROM", "C) Flash存储器", "D) CD-ROM"],
    "answer": "C"
  },
  {
    "id": 26,
    "question": "U盘属于（）类型的存储器。",
    "options": ["A) 高速缓存", "B) 主存", "C) 只读存储器", "D) 随机存储器"],
    "answer": "C"
  },
  {
    "id": 27,
    "question": "某计算机系统，其操作系统保存于硬盘上，其内存储器应该采用（）",
    "options": ["A) RAM", "B) ROM", "C) RAM和ROM", "D) 均不完善"],
    "answer": "C"
  },
  {
    "id": 28,
    "question": "下列说法正确的是（）",
    "options": ["A) EPROM是可改写的，因此可以作为随机存储器", "B) EPROM是可改写的，但不能作为随机存储器", "C) EPROM是不可改写的，因此不能作为随机存储器", "D) EPROM只能改写一次，因此不能作为随机存储器"],
    "answer": "C"
  },
  {
    "id": 29,
    "question": "下列（）是动态半导体存储器的特点",
    "options": ["A) 在工作中存储器内容会产生变化", "B) 每隔一定时间，需要根据原存内容重新写入一遍", "C) 一次完整的刷新过程需要占用两个存储周期", "D) 一次完整的刷新过程只需要占用一个存储周期"],
    "answer": "C"
  },
  {
    "id": 30,
    "question": "采用64K×1位的DRAM芯片构成256K×8位的存储器，若采用异步刷新方式，每单元刷新间隔不超过2ms，则生成的刷新信号间隔时间是（）",
    "options": ["A) 7.8μs, 256", "B) 1.9μs, 256", "C) 7.8μs, 128", "D) 1.9μs, 256"],
    "answer": "C"
  },
  {
    "id": 31,
    "question": "DRAM具有破坏性读出的特性，需要定时刷新，下列说法中不正确的是（）",
    "options": ["A) 刷新是以行为单位的", "B) 刷新是为了给DRAM存储单元中的存储电容重新充电", "C) 刷新是通过对存储单元进行“读但不输出数据”，即“假读”的操作来实现的", "D) DRAM内部设有专门的刷新电路，不会影响到CPU的正常访存"],
    "answer": "C"
  },
  {
    "id": 32,
    "question": "下列关于DRAM和SDRAM的说法中，不正确的是（）",
    "options": ["A) 传统DRAM芯片与CPU采用异步方式交换数据", "B) SDRAM芯片与CPU采用同步方式交换数据", "C) DRAM需要定期刷新，而SDRAM不需要定期刷新", "D) SDRAM的行缓冲器通常用SRAM实现"],
    "answer": "C"
  },
  {
    "id": 33,
    "question": "每推出新一代DRAM芯片，地址线至少增1根，则容量至少提高到原来的（）倍。",
    "options": ["A) 2", "B) 4", "C) 8", "D) 16"],
    "answer": "C"
  },
  {
    "id": 34,
    "question": "若一个内存条中有16个DRAM芯片，每个芯片中有4个位平面，每个位平面的存储阵列为4096行×4096列，则内存条的总容量为（）MB。",
    "options": ["A) 64", "B) 128", "C) 256", "D) 512"],
    "answer": "C"
  },
  {
    "id": 35,
    "question": "已知单个存储体的存储周期为110ns，总线传输周期为10ns，采用低位交叉编址的多模块存储器时，存储体数应（）。",
    "options": ["A) 小于11", "B) 等于11", "C) 大于11", "D) 大于或等于11"],
    "answer": "C"
  },
  {
    "id": 36,
    "question": "一个四体并行低位交叉存储器，每个模块的容量是64K×32位，存取周期为200ns，总线周期为50ns，在200ns内，存储器能向CPU提供（）位二进制信息。",
    "options": ["A) 256", "B) 128", "C) 64", "D) 以上都不对"],
    "answer": "C"
  },
  {
    "id": 37,
    "question": "某机器采用四体低位交叉存储器，现分别执行下述操作：①读取6个连续地址单元中存放的存储字，重复80次；②读取8个连续地址单元中存放的存储字，重复60次。则①、②所花费的时间之比为（）。",
    "options": ["A) 1:1", "B) 2:1", "C) 4:3", "D) 3:4"],
    "answer": "C"
  },
  {
    "id": 38,
    "question": "假定用若干16K×8位的存储芯片组成一个64K×8位的存储器，芯片各单元采用交叉编址方式，则地址BFFFH所在的芯片的最小地址为（）。",
    "options": ["A) 0000H", "B) 0001H", "C) 0002H", "D) 0003H"],
    "answer": "C"
  },
  {
    "id": 39,
    "question": "下列关于单体多字存储器的说法中，不正确的是（）",
    "options": ["A) 单体多字存储器主要解决主存容量太小的问题", "B) 单体多字存储器中，每个存储单元存储多个字", "C) 指令与数据的连续存放有利于单体多字存储器提高主存的读/写速度", "D) 过多的跳转指令会严重影响单体多字存储器的工作效率"],
    "answer": "C"
  },
  {
    "id": 40,
    "question": "多模块存储器之所以能提高存储器的访问速度，是因为（）",
    "options": ["A) 采用了高速元器件", "B) 各模块有独立的读/写电路", "C) 采用了信息预读技术", "D) 模块内各单元地址连续"],
    "answer": "C"
  },
  {
    "id": 41,
    "question": "下列有关RAM和ROM的叙述中，正确的是（）",
    "options": ["A) RAM是易失性存储器，ROM是非易失性存储器", "B) RAM和ROM都采用随机存取方式进行信息访问", "C) RAM和ROM都可用作Cache", "D) RAM和ROM都需要进行刷新"],
    "answer": "C"
  },
  {
    "id": 42,
    "question": "下列关于闪存的叙述中，错误的是（）",
    "options": ["A) 信息可读可写，并且读、写速度一样快", "B) 存储元由MOS管组成，是一种半导体存储器", "C) 掉电后信息不丢失，是一种非易失性存储器", "D) 采用随机访问方式，可替代计算机外部存储器"],
    "answer": "C"
  },
  {
    "id": 43,
    "question": "某容量为256MB的存储器由若干4M×8位的DRAM芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（）。",
    "options": ["A) 19", "B) 22", "C) 30", "D) 36"],
    "answer": "C"
  },
  {
    "id": 44,
    "question": "下列存储器中，在工作期间需要周期性刷新的是（）。",
    "options": ["A) SRAM", "B) SDRAM", "C) ROM", "D) Flash"],
    "answer": "C"
  },
  {
    "id": 45,
    "question": "某计算机使用四体交叉编址存储器，假定在存储器总线上出现的主存地址（十进制）序列为8005,8006,8007,8008,8001,8002,8003,8004,8000，则可能发生访存冲突的地址对是（）。",
    "options": ["A) 8004和8008", "B) 8002和8007", "C) 8001和8008", "D) 8000和8004"],
    "answer": "C"
  },
  {
    "id": 46,
    "question": "某计算机主存按字节编址，由4个64M×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储器总线相连，主存每次最多读/写32位数据。若double型变量x的主存地址为804001AH，则读取x需要的存储周期数是（）。",
    "options": ["A) 1", "B) 2", "C) 3", "D) 4"],
    "answer": "C"
  },
  {
    "id": 47,
    "question": "假定DRAM芯片中存储阵列的行数为r、列数为c，对于一个2K×1位的DRAM芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则r、c的取值分别是（）。",
    "options": ["A) 2048,1", "B) 64,32", "C) 32,64", "D) 1,2048"],
    "answer": "C"
  },
  {
    "id": 48,
    "question": "某内存条包含8个8192×8192×8位的DRAM芯片，按字节编址，支持突发传送方式，对应存储器总线宽度为64位，每个DRAM芯片内有一个行缓冲区。下列关于该内存条的叙述中，不正确的是（）。",
    "options": ["A) 内存条的容量为512MB", "B) 采用多模块交叉编址方式", "C) 芯片的地址引脚为26位", "D) 芯片内行缓冲有8192×8位"],
    "answer": "C"
  },
  {
    "id": 49,
    "question": "用存储容量为16K×1位的存储器芯片来组成一个64K×8位的存储器，则在字方向和位方向分别扩展了（）倍。",
    "options": ["A) 4,2", "B) 8,4", "C) 2,4", "D) 4,8"],
    "answer": "C"
  },
  {
    "id": 50,
    "question": "80386DX是32位系统，以4B为编址单位，当在该系统中用8KB（8K×8位）的存储芯片构造32KB的存储体时，应完成存储器的（）设计。",
    "options": ["A) 位扩展", "B) 字扩展", "C) 字位扩展", "D) 字位均不扩展"],
    "answer": "C"
  },
  {
    "id": 51,
    "question": "某计算机字长为16位，存储器容量为256KB，CPU按字寻址，其寻址范围是（）。",
    "options": ["A) 0~2^17-1", "B) 0~2^18-1", "C) 0~2^19-1", "D) 0~2^20-1"],
    "answer": "C"
  },
  {
    "id": 52,
    "question": "4个16K×8位的存储芯片，可设计为（）容量的存储器。",
    "options": ["A) 32K×16位", "B) 16K×16位", "C) 32K×8位", "D) 8K×16位"],
    "answer": "C"
  },
  {
    "id": 53,
    "question": "16片2K×4位的存储器可以设计为（）存储容量的16位存储器。",
    "options": ["A) 16K", "B) 32K", "C) 8K", "D) 2K"],
    "answer": "C"
  },
  {
    "id": 54,
    "question": "设CPU地址总线有24根，数据总线有32根，用512K×8位的RAM芯片构成该机的主存储器，则该机主存最多需要（）片这样的存储芯片。",
    "options": ["A) 256", "B) 512", "C) 64", "D) 128"],
    "answer": "C"
  },
  {
    "id": 55,
    "question": "地址总线A19（高位）～A0（低位），用4K×4位的存储芯片组成16KB存储器，则产生片选信号的译码器的输入地址线应该是（）。",
    "options": ["A) A2A3", "B) A0A1", "C) A12A13", "D) A14A15"],
    "answer": "C"
  },
  {
    "id": 56,
    "question": "若内存地址区间为4000H～43FFH，每个存储单元可存储16位二进制数，该内存区域用4片存储器芯片构成，构成该内存所用的存储器芯片的容量是（）。",
    "options": ["A) 512×16bit", "B) 256×8bit", "C) 256×16bit", "D) 1024×8bit"],
    "answer": "C"
  },
  {
    "id": 57,
    "question": "内存按字节编址，地址从90000H到CFFFFH，若用存储容量为16K×8位芯片构成该内存，至少需要的芯片数是（）。",
    "options": ["A) 2", "B) 4", "C) 8", "D) 16"],
    "answer": "C"
  },
  {
    "id": 58,
    "question": "若片选地址为111时，选定某一32K×16位的存储芯片工作，则该芯片在存储器中的首地址和末地址分别为（）。",
    "options": ["A) 00000H,01000H", "B) 38000H,3FFFFH", "C) 3800H,3FFFH", "D) 0000H,0100H"],
    "answer": "C"
  },
  {
    "id": 59,
    "question": "某计算机主存容量为64KB，其中ROM区为4KB，其余为RAM区，按字节编址。现要用2K×8位的ROM芯片和4K×4位的RAM芯片来设计该存储器，需要上述规格的ROM芯片数和RAM芯片数分别是（）。",
    "options": ["A) 1,15", "B) 2,15", "C) 1,30", "D) 2,30"],
    "answer": "C"
  },
  {
    "id": 60,
    "question": "假定用若干2K×4位的芯片组成一个8K×8位的存储器，则地址0B1FH所在芯片的最小地址是（）。",
    "options": ["A) 0000H", "B) 0600H", "C) 0700H", "D) 0800H"],
    "answer": "C"
  },
  {
    "id": 61,
    "question": "某计算机存储器按字节编址，主存地址空间大小为64MB，现用4M×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（）。",
    "options": ["A) 22位", "B) 23位", "C) 25位", "D) 26位"],
    "answer": "C"
  },
  {
    "id": 62,
    "question": "某存储器容量为64KB，按字节编址，地址4000H～5FFFH为ROM区，其余为RAM区。若采用8K×4位的SRAM芯片进行设计，则需要该芯片的数量是（）。",
    "options": ["A) 7", "B) 8", "C) 14", "D) 16"],
    "answer": "C"
  },
  {
    "id": 63,
    "question": "某计算机的存储器总线中有24位地址线和32位数据线，按字编址，字长为32位。若000000H～3FFFFFH为RAM区，则需要512K×8位的RAM芯片数为（）。",
    "options": ["A) 8", "B) 16", "C) 32", "D) 64"],
    "answer": "C"
  },
  {
    "id": 64,
    "question": "某计算机的CPU有30根地址线，按字节编址，CPU和主存连接时，要求主存芯片占满所有可能的存储地址空间，并且RAM区和ROM区所分配的空间大小比是3:1。若RAM在低地址区，ROM在高地址区，则ROM的地址范围是（）。",
    "options": ["A) 00000000H~0FFFFFFFH", "B) 10000000H~2FFFFFFFH", "C) 30000000H~3FFFFFFFH", "D) 40000000H~4FFFFFFFH"],
    "answer": "C"
  },
  {
    "id": 65,
    "question": "下列关于磁盘的说法中，错误的是（）。",
    "options": ["A) 本质上，U盘（闪存）是一种只读存储器", "B) RAID技术可以提高磁盘的磁记录密度和磁盘利用率", "C) 未格式化的硬盘容量要大于格式化后的实际容量", "D) 计算磁盘的存取时间时，“寻道时间”和“旋转等待时间”常取其平均值"],
    "answer": "C"
  },
  {
    "id": 66,
    "question": "下列关于磁盘驱动器的叙述中，错误的是（）。",
    "options": ["A) 送到磁盘驱动器的地址由磁头号、盘面号和扇区号组成", "B) 能控制磁头移动到指定磁道，并发回“寻道结束”信号", "C) 能控制磁盘片转过指定的扇区，并发回“扇区符合”信号", "D) 能控制对指定盘面的指定扇区进行数据的读或写操作"],
    "answer": "C"
  },
  {
    "id": 67,
    "question": "下列有关磁盘存储器读/写操作的叙述中，错误的是（）。",
    "options": ["A) 最小读/写单位可以是一个扇区", "B) 采用直接存储器存取DMA方式进行输入/输出", "C) 按批处理方式进行一个数据块的读/写", "D) 磁盘存储器可与CPU交换盘面上的存储信息"],
    "answer": "C"
  },
  {
    "id": 68,
    "question": "若磁盘的转速提高一倍，则（）。",
    "options": ["A) 平均寻道时间减少一半", "B) 存取速度也提高一倍", "C) 平均旋转延迟时间减少一半", "D) 不影响磁盘传输速率"],
    "answer": "C"
  },
  {
    "id": 69,
    "question": "下列关于固态硬盘（SSD）的叙述中，不正确的是（）。",
    "options": ["A) 固态硬盘的读/写是以页为单位的", "B) 固态硬盘的擦除是以页为单位的", "C) 固态硬盘的写入速度比读取速度慢很多", "D) 固态硬盘的写入次数有限，引入磨损均衡可以延长使用寿命"],
    "answer": "C"
  },
  {
    "id": 70,
    "question": "下列关于固态硬盘（SSD）的说法中，错误的是（）。",
    "options": ["A) 基于闪存的存储技术", "B) 随机读/写性能明显高于磁盘", "C) 随机写比较慢", "D) 读/写速度快，常用作主存"],
    "answer": "C"
  },
  {
    "id": 71,
    "question": "一个磁盘的转速为7200转/分，每个磁道有160个扇区，每个扇区有512字节，则在理想情况下，磁盘每秒传输的数据量是（）。",
    "options": ["A) 7200×160KB", "B) 7200KB/s", "C) 9600KB/s", "D) 19200KB/s"],
    "answer": "C"
  },
  {
    "id": 72,
    "question": "某磁盘盘面共有200个磁道，盘面总存储容量为60MB，磁盘旋转一周的时间为25ms，每个磁道有8个扇区，各扇区之间有一间隙，磁头通过每个间隙需1.25ms。则磁盘接口所需的最大传输速率是（）。",
    "options": ["A) 10MB/s", "B) 60MB/s", "C) 60MB/s", "D) 20MB/s"],
    "answer": "C"
  },
  {
    "id": 73,
    "question": "某磁盘的转速为10000转/分，平均寻道时间是6ms，磁盘传输速率是20MB/s，磁盘控制器延迟为0.2ms，读取一个4KB的扇区所需的平均时间约为（）。",
    "options": ["A) 9ms", "B) 9.4ms", "C) 12ms", "D) 12.4ms"],
    "answer": "C"
  },
  {
    "id": 74,
    "question": "下列选项中，用于提高RAID可靠性的措施有（）。",
    "options": ["A) 仅I、II", "B) 仅I、III", "C) 仅I、III和IV", "D) 仅II、III和IV"],
    "answer": "C"
  },
  {
    "id": 75,
    "question": "若磁盘转速为7200转/分，平均寻道时间为8ms，每个磁道包含1000个扇区，则访问一个扇区的平均存取时间大约是（）。",
    "options": ["A) 8.1ms", "B) 12.2ms", "C) 16.3ms", "D) 20.5ms"],
    "answer": "C"
  },
  {
    "id": 76,
    "question": "下列关于磁盘存储器的叙述中，错误的是（）。",
    "options": ["A) 磁盘的格式化容量比非格式化容量小", "B) 扇区中包含数据、地址和校验等信息", "C) 磁盘存储器的最小读/写单位为1字节", "D) 磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成"],
    "answer": "C"
  },
  {
    "id": 77,
    "question": "在高速缓存系统中，主存容量为12MB，Cache容量为400KB，则该存储系统的容量为（）。",
    "options": ["A) 12MB+400KB", "B) 12MB", "C) 12MB-12MB+400KB", "D) 12MB-400KB"],
    "answer": "C"
  },
  {
    "id": 78,
    "question": "访问Cache系统失效时，通常不仅主存向CPU传送信息，同时还需要将信息写入Cache，在此过程中传送和写入信息的数据宽度各为（）。",
    "options": ["A) 块，页", "B) 字，字", "C) 字，块", "D) 块，块"],
    "answer": "C"
  },
  {
    "id": 79,
    "question": "假定用作Cache的SRAM的存取时间为2ns，用作主存的SDRAM的存取时间为40ns。为使存储系统的平均存取时间达到3ns，则Cache命中率应达到（）左右。",
    "options": ["A) 0.925", "B) 0.85", "C) 0.975", "D) 0.999"],
    "answer": "C"
  },
  {
    "id": 80,
    "question": "关于Cache的更新策略，下列说法中正确的是（）。",
    "options": ["A) 读操作时，全写法和回写法在命中时应用", "B) 写操作时，回写法和写分配法在命中时应用", "C) 读操作时，全写法和写分配法在失效时应用", "D) 写操作时，写分配法、非写分配法在失效时应用"],
    "answer": "C"
  },
{
    "id": 81,
    "question": "在不同的情况下，需要采用适合的Cache写策略。对于下面两种情况：①主要运行访问密集型应用，其中包含写操作；②安全性要求很高，不允许有任何数据不一致的情况发生。适合它们的写策略分别是（）。",
    "options": ["A) 回写法，全写法", "B) 全写法，回写法", "C) 回写法，回写法", "D) 全写法，全写法"],
    "answer": "C"
  },
  {
    "id": 82,
    "question": "局部性通常有两种不同的形式：时间局部性和空间局部性。程序员是否编写出高速缓存友好的代码，就取决于这两方面的问题。对于下面这个函数，说法正确的是（）。\nint sumvec(int v[N]) { int i, sum = 0; for(i = 0; i < N; i++) sum += v[i]; return sum; }",
    "options": ["A) 对于变量i和sum，循环体具有良好的空间局部性", "B) 对于变量i、sum和v[N]，循环体具有良好的空间局部性", "C) 对于变量i和sum，循环体具有良好的时间局部性", "D) 对于变量i、sum和v[N]，循环体具有良好的时间局部性"],
    "answer": "C"
  },
  {
    "id": 83,
    "question": "对于下列代码，以下哪种变化将使其具有更好的空间局部性（）。\nfor(i = 0; i < n; i++) for(j = 0; j < n; j++) for(k = 0; k < n; k++) sum += a[k][j][i];",
    "options": ["A) 将第2行与第3行互换", "B) 将第2行与第4行互换", "C) 将第5行改为 sum += a[i][j][k];", "D) 将第5行改为 sum += a[j][i][k];"],
    "answer": "C"
  },
  {
    "id": 84,
    "question": "下列关于高速缓存Cache的描述中，正确的是（）。",
    "options": ["A) Cache的功能全部由硬件实现", "B) Cache替换时的单位为字", "C) Cache与主存统一编址，即主存地址空间的某一部分属于Cache", "D) 无论何时，Cache中的信息一定与主存中的信息一致"],
    "answer": "C"
  },
  {
    "id": 85,
    "question": "下列关于Cache的描述中，比较合理的是（）。\nI. 指令Cache通常比数据Cache具有更好的空间局部性\nII. 由于空间局部性，适当增加Cache块大小通常会提高命中率\nIII. 回写法的写主存操作次数少于写直达法",
    "options": ["A) I和II", "B) II和III", "C) I、II和III", "D) 仅II"],
    "answer": "C"
  },
  {
    "id": 86,
    "question": "某虚拟存储器系统采用页式内存管理，使用LRU页面替换算法，考虑下面的页面访问地址流（每次访问在一个时间单位中完成）：1 8 1 7 8 2 7 2 1 8 3 8 3 2 3 7 1 3 7。假定内存容量为4个页面，开始时是空的，则页面失效率是（）。",
    "options": ["A) 30%", "B) 5%", "C) 15%", "D) 50%"],
    "answer": "C"
  },
  {
    "id": 87,
    "question": "某个具有两级Cache的存储系统中，访存时依次通过两级Cache，某程序在执行过程中访存1000次，其中访问第一级Cache时有40次不命中，接着访问第二级Cache，仍有10次不命中，则总命中率是（）。",
    "options": ["A) 0.99", "B) 0.96", "C) 0.95", "D) 0.97"],
    "answer": "C"
  },
  {
    "id": 88,
    "question": "假设一个Cache中共有M块，每K块组成一个组，则下列描述中正确的是（）。",
    "options": ["A) 若K=1，则该Cache是直接映射Cache", "B) 若K=1，则该Cache是全相联映射Cache", "C) 若K=M，则该Cache是直接映射Cache", "D) 若K>1且K<M，则该Cache是M/K-路组相联映射Cache"],
    "answer": "C"
  },
  {
    "id": 89,
    "question": "在Cache中，常用的替换策略有随机法（RAND）、先进先出法（FIFO）、近期最少使用法（LRU），其中与局部性原理有关的是（）。",
    "options": ["A) 随机法（RAND）", "B) 先进先出法（FIFO）", "C) 近期最少使用法（LRU）", "D) 都不是"],
    "answer": "C"
  },
  {
    "id": 90,
    "question": "某存储系统中，主存容量是Cache容量的4096倍，Cache被分为64个块，当主存地址和Cache地址采用直接映像方式时，地址映射表的大小应为（）。（假设不考虑一致维护和替换算法位。）",
    "options": ["A) 64×4097bit", "B) 64×12bit", "C) 64×4096bit", "D) 64×13bit"],
    "answer": "C"
  },
  {
    "id": 91,
    "question": "有效容量为128KB的Cache，每块16B，采用8路组相联。字节地址为1234567H的单元调入该Cache，则其Tag应为（）。",
    "options": ["A) 1234H", "B) 2468H", "C) 048DH", "D) 12345H"],
    "answer": "C"
  },
  {
    "id": 92,
    "question": "有一主存-Cache层次的存储器，其主存容量为1MB，Cache容量为16KB，每块有8个字，每字32位，采用直接地址映像方式，Cache起始字块为第0块，若主存地址为35301H，且CPU访问Cache命中，则在Cache的第（）字块中。",
    "options": ["A) 152", "B) 153", "C) 154", "D) 151"],
    "answer": "C"
  },
  {
    "id": 93,
    "question": "对于由高速缓存、主存、硬盘构成的三级存储体系，CPU直接根据（）进行访问。",
    "options": ["A) 高速缓存地址", "B) 虚拟地址", "C) 主存物理地址", "D) 磁盘地址"],
    "answer": "C"
  },
  {
    "id": 94,
    "question": "设有8页的逻辑空间，每页有1024B，它们被映射到32块的物理存储区中，则按字节编址逻辑地址的有效位是（），物理地址至少是（）位。",
    "options": ["A) 10,12", "B) 10,15", "C) 13,15", "D) 13,12"],
    "answer": "C"
  },
  {
    "id": 95,
    "question": "对于n-路组相联映射Cache，在保持n及主存和Cache总容量不变的前提下，将主存块大小和Cache块大小都增加一倍，则下列描述中正确的是（）。",
    "options": ["A) 字块内地址的位数增加1位，主存tag字段的位数增加1位", "B) 块内地址的位数增加1位，主存tag字段的位数不变", "C) 字块内地址的位数减少1位，主存tag字段的位数增加1位", "D) 字块内地址的位数增加1倍，主存tag字段的位数减少一半"],
    "answer": "C"
  },
  {
    "id": 96,
    "question": "某计算机的Cache有16行，块大小为16B，其映射方式可配置为直接映射或2-路组相联映射，主存按字节编址，主存单元从0开始编号。若依次访问下列主存单元，则不论采取上述哪种映射方式都可能引起Cache冲突的是（）。",
    "options": ["A) 52号和102号单元", "B) 48号和308号单元", "C) 60号和160号单元", "D) 46号和236号单元"],
    "answer": "C"
  },
  {
    "id": 97,
    "question": "假设主存地址位数为32位，按字节编址，主存和Cache之间采用全相联映射方式，主存块大小为1个字，每字32位，采用回写（write back）方式和随机替换策略，则能存放32K字数据的Cache的总容量至少应有（）位。",
    "options": ["A) 1536K", "B) 1568K", "C) 2016K", "D) 2048K"],
    "answer": "C"
  },
  {
    "id": 98,
    "question": "假设主存按字节编址，Cache共有64行，采用四路组相联映射方式，主存块大小为32字节，所有编号都从0开始。则第2593号存储单元所在主存块的Cache组号是（）。",
    "options": ["A) 1", "B) 15", "C) 14", "D) 4"],
    "answer": "C"
  },
  {
    "id": 99,
    "question": "假定CPU通过存储器总线读取数据的过程为：发送地址和读命令需1个时钟周期，存储器准备一个数据需8个时钟周期，总线上每传送1个数据需1个时钟周期。若主存和Cache之间交换的主存块大小为64B，存取宽度和总线宽度都为8B，则Cache的一次缺失损失至少为（）个时钟周期。",
    "options": ["A) 64", "B) 72", "C) 80", "D) 160"],
    "answer": "C"
  },
  {
    "id": 100,
    "question": "假定8个存储器模块采用交叉方式组织，存储器芯片和总线支持突发传送，CPU通过存储器总线读取数据的过程为：发送首地址和读命令需1个时钟周期，存储器准备第一个数据需8个时钟周期，随后每个时钟周期总线上传送1个数据，可连续传送8个数据（即突发长度为8）。若主存和Cache之间交换的主存块大小为64B，存取宽度和总线宽度都为8B，则Cache的一次缺失损失至少为（）个时钟周期。",
    "options": ["A) 17", "B) 20", "C) 33", "D) 80"],
    "answer": "C"
  },
  {
    "id": 101,
    "question": "下列关于Cache替换算法的叙述中，错误的是（）。",
    "options": ["A) 组相联映射和全相联映射都必须考虑如何进行替换", "B) 先进先出算法无须对每个Cache行记录替换信息", "C) 直接映射是多对一的映射，无须考虑替换问题", "D) LRU算法需要对每个Cache行记录替换信息"],
    "answer": "C"
  },
  {
    "id": 102,
    "question": "下列关于Cache大小、主存块大小和Cache缺失率之间关系的叙述中，错误的是（）。",
    "options": ["A) 主存块大小和Cache容量无直接关系", "B) Cache容量越大，Cache缺失率越低", "C) 主存块大小通常为几十到上百字节", "D) 主存块越大，Cache缺失率越低"],
    "answer": "C"
  },
  {
    "id": 103,
    "question": "假设某计算机的存储系统由Cache和主存组成，某程序执行过程中访存1000次，其中访问Cache缺失（未命中）50次，则Cache的命中率是（）。",
    "options": ["A) 0.05", "B) 0.095", "C) 0.95", "D) 0.5"],
    "answer": "C"
  },
  {
    "id": 104,
    "question": "某计算机的Cache共有16块，采用二路组相联映射方式（即每组2块）。每个主存块大小为32B，按字节编址，主存129号单元所在主存块应装入的Cache组号是（）。",
    "options": ["A) 0", "B) 2", "C) 4", "D) 6"],
    "answer": "C"
  },
  {
    "id": 105,
    "question": "假设某计算机按字编址，Cache有4行，Cache和主存之间交换的块大小为1个字。若Cache的内容初始为空，采用二路组相联映射方式和LRU替换策略，则访问的主存地址依次为0，4，8，2，0，6，8，6，4，8时，命中Cache的次数是（）。",
    "options": ["A) 1", "B) 2", "C) 3", "D) 4"],
    "answer": "C"
  },
  {
    "id": 106,
    "question": "有如下C语言程序段：for(k = 0; k < 1000; k++) a[k] = a[k] + 32; 若数组a和变量k均为int型，int型数据占4B，数据Cache采用直接映射方式，数据区大小为1KB、块大小为16B，该程序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为（）。",
    "options": ["A) 0.0125", "B) 0.025", "C) 0.125", "D) 0.25"],
    "answer": "C"
  },
  {
    "id": 107,
    "question": "某C语言程序段如下：for(i = 0; i <= 9; i++) { temp = 1; for(j = 0; j <= i; j++) temp *= a[j]; sum += temp; } 下列关于数组a的访问局部性的描述中，正确的是（）。",
    "options": ["A) 时间局部性和空间局部性皆有", "B) 无时间局部性，有空间局部性", "C) 有时间局部性，无空间局部性", "D) 时间局部性和空间局部性皆无"],
    "answer": "C"
  },
  {
    "id": 108,
    "question": "若计算机主存地址为32位，按字节编址，Cache数据区大小为32KB，主存块大小为32B，采用直接映射方式和回写（Write Back）策略，则Cache行的位数至少是（）。",
    "options": ["A) 275", "B) 274", "C) 258", "D) 257"],
    "answer": "C"
  },
  {
    "id": 109,
    "question": "若计算机主存地址为32位，按字节编址，某Cache的数据区容量为32KB，主存块大小为64B，采用8路组相联映射方式，该Cache中比较器的个数和位数分别为（）。",
    "options": ["A) 8, 20", "B) 8, 23", "C) 64, 20", "D) 64, 23"],
    "answer": "C"
  },
  {
    "id": 110,
    "question": "为使虚拟存储系统有效地发挥其预期的作用，所运行程序应具有的特性是（）。",
    "options": ["A) 不应含有过多的I/O操作", "B) 大小不应小于实际的内存容量", "C) 应具有较好的局部性", "D) 顺序执行的指令不应过多"],
    "answer": "C"
  },
  {
    "id": 111,
    "question": "虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是（）。",
    "options": ["A) 在程序的执行过程中，程序对主存的访问是不均匀的", "B) 空间局部性", "C) 时间局部性", "D) 代码的顺序执行"],
    "answer": "C"
  },
  {
    "id": 112,
    "question": "虚拟存储器的常用管理方式有段式、页式、段页式，对于它们在与主存交换信息时的单位，以下表述正确的是（）。",
    "options": ["A) 段式采用“页”", "B) 页式采用“块”", "C) 段页式采用“段”和“页”", "D) 页式和段页式均仅采用“页”"],
    "answer": "C"
  },
  {
    "id": 113,
    "question": "下列关于虚存的叙述中，正确的是（）。",
    "options": ["A) 对应用程序员透明，对系统程序员不透明", "B) 对应用程序员不透明，对系统程序员透明", "C) 对应用程序员、系统程序员都不透明", "D) 对应用程序员、系统程序员都透明"],
    "answer": "C"
  },
  {
    "id": 114,
    "question": "在虚拟存储器中，当程序正在执行时，由（）完成地址映射。",
    "options": ["A) 程序员", "B) 编译器", "C) 装入程序", "D) 操作系统"],
    "answer": "C"
  },
  {
    "id": 115,
    "question": "采用虚拟存储器的主要目的是（）。",
    "options": ["A) 提高主存储器的存取速度", "B) 扩大主存储器的存储空间", "C) 提高外存储器的存取速度", "D) 扩大外存储器的存储空间"],
    "answer": "C"
  },
  {
    "id": 116,
    "question": "下列关于Cache与虚拟存储器的说法中，错误的有（）。",
    "options": ["A) 一次访存时，页表不命中，则Cache一定也不命中", "B) Cache不命中的损失要大于页表不命中的损失", "C) CPU只能与Cache直接交换信息，CPU与主存交换信息也需要经过Cache", "D) 虚拟存储器的实际容量可以大于主存和辅存的容量之和"],
    "answer": "C"
  },
  {
    "id": 117,
    "question": "下列有关页式存储管理的叙述中，错误的是（）。",
    "options": ["A) 进程地址空间被划分成等长的页，内存被划分成同样大小的页框", "B) 采用全相联映射，每页可以映射到任何一个空闲的页框中", "C) 当从磁盘装入的信息不足一页时会产生页内碎片", "D) 相对于段式存储管理，分页式更利于存储保护"],
    "answer": "C"
  },
  {
    "id": 118,
    "question": "下列有关虚拟存储管理机制中地址转换的叙述，错误的是（）。",
    "options": ["A) 地址转换是指把逻辑地址转换为物理地址", "B) 通常逻辑地址的位数比物理地址的位数少", "C) 地址转换过程中会发现是否“缺页”", "D) 内存管理单元（MMU）在地址转换过程中要访问页表项"],
    "answer": "C"
  },
  {
    "id": 119,
    "question": "下列有关虚拟存储管理机制的页表的叙述中，错误的是（）。",
    "options": ["A) 系统中每个进程有一个页表", "B) 页表中每个表项与一个虚页对应", "C) 每个页表项中都包含装入位（有效位）", "D) 所有进程都可以访问页表"],
    "answer": "C"
  },
  {
    "id": 120,
    "question": "下列有关缺页处理的叙述中，错误的是（）。",
    "options": ["A) 若对应页表项中的有效位为0，则发生缺页", "B) 缺页是一种外部中断，需要调用操作系统提供的中断服务程序来处理", "C) 缺页处理过程中需根据页表中给出的磁盘地址去读磁盘数据", "D) 缺页处理完后要重新执行发生缺页的指令"],
    "answer": "C"
  },
  {
    "id": 121,
    "question": "下列关于段式虚拟存储管理的叙述中，错误的是（）。",
    "options": ["A) 段是逻辑结构上相对独立的程序块，因此段是可变长的", "B) 按程序中实际的段来分配主存，所以分配后的存储块是可变长的", "C) 每个段表项必须记录对应段在主存的起始位置和段的长度", "D) 分段方式对低级语言程序员和编译器来说是透明的"],
    "answer": "C"
  },
  {
    "id": 122,
    "question": "虚拟存储器中的页表有快表和慢表之分，下面关于页表的叙述中正确的是（）。",
    "options": ["A) 快表与慢表都存储在主存中，但快表比慢表容量小", "B) 快表采用了优化的搜索算法，因此查找速度快", "C) 快表比慢表的命中率高，因此快表可以得到更多的搜索结果", "D) 快表采用相联存储器件组成，按照查找内容访问，因此比慢表查找速度快"],
    "answer": "C"
  },
  {
    "id": 123,
    "question": "下列命令组合的一次访存过程中，不可能发生的是（）。",
    "options": ["A) TLB未命中，Cache未命中，Page未命中", "B) TLB未命中，Cache命中，Page命中", "C) TLB命中，Cache未命中，Page命中", "D) TLB命中，Cache命中，Page未命中"],
    "answer": "C"
  },
  {
    "id": 124,
    "question": "假定编译器将赋值语句“x = x + 3;”转换为指令“add xaddr, 3”，其中xaddr是x对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的TLB，且Cache使用直写方式，则完成该指令功能需要访问主存的次数至少是（）。",
    "options": ["A) 0", "B) 1", "C) 2", "D) 3"],
    "answer": "C"
  },
  {
    "id": 125,
    "question": "假定主存地址为32位，按字节编址，主存和Cache之间采用直接映射方式，主存块大小为4个字，每字32位，采用回写方式，则能存放4K字数据的Cache的总容量的位数至少是（）。",
    "options": ["A) 146K", "B) 147K", "C) 148K", "D) 158K"],
    "answer": "C"
  },
  {
    "id": 126,
    "question": "下列关于缺页处理的叙述中，错误的是（）。",
    "options": ["A) 缺页是在地址转换时CPU检测到的一种异常", "B) 缺页处理由操作系统提供的缺页处理程序来完成", "C) 缺页处理程序根据页故障地址从外存读入所缺失的页", "D) 缺页处理完成后回到发生缺页的指令的下一条指令执行"],
    "answer": "C"
  },
  {
    "id": 127,
    "question": "下列关于TLB和Cache的叙述中，错误的是（）。",
    "options": ["A) 命中率都与程序局部性有关", "B) 缺失后都需要去访问主存", "C) 缺失处理都可以由硬件实现", "D) 都由DRAM存储器组成"],
    "answer": "C"
  },
  {
    "id": 128,
    "question": "某计算机主存地址空间大小为256MB，按字节编址。虚拟地址空间大小为4GB，采用页式存储管理，页面大小为4KB，TLB（快表）采用全相联映射，有4个页表项，内容如下表所示。\n有效位 | 标记 | 页框号\n   1   | FF180H | 0002H\n   1   | 0035H  | 3FFF1H\n   1   | 02FF3H | 0351H\n   1   | 03FFFH | 0153H\n则对虚拟地址03FFF180H进行虚实地址变换的结果是（）。",
    "options": ["A) 0153180H", "B) 0035180H", "C) TLB缺失", "D) 缺页"],
    "answer": "C"
  },
  {
    "id": 129,
    "question": "某计算机主存地址为24位，采用分页虚拟存储管理方式，虚拟地址空间大小为4GB，页大小为4KB，按字节编址。某个进程的页表部分内容如下表所示。\n虚页号 | 实页号（页框号） | 存在位\n  024H |       82        |   0\n  129  |      180H       |   1\n  130  |      018H       |   1\n当CPU访问虚拟地址00082840H时，虚-实地址转换的结果是（）。",
    "options": ["A) 得到主存地址024840H", "B) 得到主存地址180840H", "C) 得到主存地址018840H", "D) 检测到缺页异常"],
    "answer": "C"
  },
  {
    "id": 130,
    "question": "某存储器总线的宽度是64位，若用8个16M×8位的DRAM芯片扩展构成16M×64位的内存条，按字节编址，支持突发传送方式，某double型的变量x的主存地址为20260000H，某int型的变量y的主存地址为20261006H，则下列叙述中错误的是（）。",
    "options": ["A) 该内存条可不采用多模块交叉编址", "B) DRAM芯片的行缓冲采用的是SRAM", "C) 读取变量x只需要一个存取周期", "D) 读取变量y需要两个存取周期"],
    "answer": "C"
  },
  {
    "id": 131,
    "question": "如下图所示，若低位地址（A0～A11）接在内存芯片地址引脚上，高位地址（A12～A19）进行片选译码（其中A14和A16未参加译码），且片选信号低电平有效，则对图中所示的译码电路，不属于译码空间的地址是（）。",
    "options": ["A) AB000H~ABFFFH", "B) BB000H~BBFFFH", "C) EF000H~EFFFFH", "D) FE000H~FEFFFH"],
    "answer": "C"
  },
  {
    "id": 132,
    "question": "若计算机按字编址，Cache数据区容量为8K字，主存块大小为512字，主存地址空间为1M字，采用2路组相联映射方式。每次根据主存地址访问Cache时，需要同时进行（）次tag位的比较，每次需要比较的位数是（）。",
    "options": ["A) 2,8", "B) 2,16", "C) 4,8", "D) 4,16"],
    "answer": "C"
  },
  {
    "id": 133,
    "question": "在某虚拟存储系统中，访问TLB和Cache的时间为10ns，访问主存的时间为100ns，TLB的命中率为90%，TLB命中时Cache的命中率为90%，并假设访问主存不会缺页，Cache缺失时的处理时间为100ns，忽略其他所有时间。则从CPU给出虚拟地址开始，到最终获取到数据，平均需要花费的时间约为（）。",
    "options": ["A) 48ns", "B) 50ns", "C) 52ns", "D) 54ns"],
    "answer": "C"
  },
  {
    "id": 134,
    "question": "对于页式虚拟存储管理系统，下列关于存储器层次结构的叙述中，错误的是（）。",
    "options": ["A) Cache-主存层次的交换单位为主存块，主存-外存层次的交换单位为页", "B) Cache-主存层次替换算法由硬件实现，主存-外存层次替换算法由软件实现", "C) Cache-主存层次可采用回写法，主存-外存层次通常采用回写法", "D) Cache-主存层次可采用直接映射方式，主存-外存层次通常采用直接映射方式"],
    "answer": "C"
  },
  {
    "id": 135,
    "question": "某计算机按字节编址，采用页式虚拟存储管理系统，虚拟地址为32位，主存地址为30位，页大小为1KB。若TLB共有32个表项，采用4路组相联映射方式，则TLB表项中标记字段的位数至少是（）。",
    "options": ["A) 17", "B) 18", "C) 19", "D) 20"],
    "answer": "C"
  },
  {
    "id": 136,
    "question": "下列事件中，不是在MMU地址转换过程中检测的是（）。",
    "options": ["A) 访问越权", "B) Cache缺失", "C) 页面缺失", "D) TLB缺失"],
    "answer": "C"
  }
]

              
          ,
          chapter4: [
    {
        "id": 1,
        "question": "程序P中有两个变量i和j，被分别分配在寄存器eax和edx中，P中语句“if(i<j)”对应的指令序列如下：804846a 39c2 cmp dword ptr edx,eax；804846c 7e0d jle xxxxxxxx。若执行到804846aH处的cmp指令时，i=105，j=100，则jle指令执行后将会转到哪处的指令执行？",
        "options": [
            "A) 8048461H",
            "B) 804846eH",
            "C) 8048479H",
            "D) 804847bH"
        ],
        "answer": "C"
    },
    {
        "id": 2,
        "question": "假设R[ax]=FFE8H，R[bx]=7FE6H，执行指令“add ax,bx”后，寄存器的内容和各标志的变化为？",
        "options": [
            "A) R[ax]=7FCEH, OF=1, SF=0, CF=0, ZF=0",
            "B) R[bx]=7FCEH, OF=1, SF=0, CF=0, ZF=0",
            "C) R[ax]=7FCEH, OF=0, SF=0, CF=1, ZF=0",
            "D) R[bx]=7FCEH, OF=0, SF=0, CF=1, ZF=0"
        ],
        "answer": "C"
    },
    {
        "id": 3,
        "question": "假设R[ax]=7FE6H，R[bx]=FFE8H，执行指令“sub bx,ax”后，寄存器的内容和各标志的变化为？",
        "options": [
            "A) R[ax]=8002H, OF=0, SF=1, CF=1, ZF=0",
            "B) R[bx]=8002H, OF=0, SF=1, CF=0, ZF=0",
            "C) R[ax]=8002H, OF=1, SF=1, CF=0, ZF=0",
            "D) R[bx]=8002H, OF=1, SF=1, CF=0, ZF=0"
        ],
        "answer": "C"
    },
    {
        "id": 4,
        "question": "某计算机的数据采用小端方式存储，减法指令“sub ax,imm”的功能为(ax)-imm→ax，imm表示立即数，该指令对应的十六进制机器码为2dxxxx，若imm=-3，(ax)=7，则该指令对应的机器码和执行后OF标志位的值分别为？",
        "options": [
            "A) 2DFFFDH, 0",
            "B) 2DFFFDH, 1",
            "C) 2DFDFFH, 0",
            "D) 2DFDFFH, 1"
        ],
        "answer": "C"
    },
    {
        "id": 5,
        "question": "C语言程序中对数组变量b的声明为“int b[10][5]”，有一条for语句如下：for(i=0;i<10;i++) for(j=0;j<5;j++) sum+=b[i][j]; 假设执行到“sum+=b[i][j];”时，sum的值在eax中，b[i][j]所在的地址在edx中，j在esi中，则该语句对应的指令可以是？",
        "options": [
            "A) add dword ptr eax, [edx+esi*4]",
            "B) add dword ptr eax, [edx+esi*4]",
            "C) add dword ptr eax, [edx+esi*2]",
            "D) add dword ptr eax, [esi+edx*2]"
        ],
        "answer": "C"
    },
    {
        "id": 6,
        "question": "假设R[eax]=080480B4H，R[ebx]=00000011H，M[080480F8H]=000000B0H，执行指令“imul eax,[eax+ebx*4],-16”后，寄存器或存储单元的内容变为？",
        "options": [
            "A) R[eax]=00000B00H",
            "B) M[080480F8H]=00000B00H",
            "C) R[eax]=FFFFF500H",
            "D) M[080480F8H]=FFFFF500H"
        ],
        "answer": "C"
    },
    {
        "id": 7,
        "question": "假定全局数组a的声明为double *a[8]，a的首地址为80498c0H，变量i被分配在寄存器ecx中，现要将a[i]取到eax相应宽度的寄存器中，则所用的汇编指令是？",
        "options": [
            "A) mov eax, [ecx*4+80498c0H]",
            "B) mov eax, ecx*4+80498c0H",
            "C) mov eax, [ecx*8+80498c0H]",
            "D) mov eax, ecx*8+80498c0H"
        ],
        "answer": "C"
    },
    {
        "id": 8,
        "question": "子程序调用指令的完整功能是？",
        "options": [
            "A) 改变堆栈指针SP的值",
            "B) 改变程序计数器PC的值",
            "C) 改变程序计数器PC的值和堆栈指针SP的值",
            "D) 改变地址寄存器的值"
        ],
        "answer": "C"
    },
    {
        "id": 9,
        "question": "下列关于选择结构语句“if(comp_A) then statement_B; else statement_C”对应的机器级代码表示的叙述中，错误的是？",
        "options": [
            "A) 一定包含一条无条件转移指令",
            "B) 一定包含一条条件转移指令",
            "C) 计算comp_A的代码段一定在条件转移指令之前",
            "D) 对应statement_B的代码一定在对应statement_C的代码之前"
        ],
        "answer": "C"
    },
    {
        "id": 10,
        "question": "下列关于循环结构语句的机器级代码表示的叙述中，错误的是？",
        "options": [
            "A) 一定至少包含一条条件转移指令",
            "B) 不一定包含无条件转移指令",
            "C) 循环结束条件可以用一条比较指令CMP来实现",
            "D) 循环体内执行的指令不包含条件转移指令"
        ],
        "answer": "C"
    },
    {
        "id": 11,
        "question": "下列有关调用指令（转子指令）的叙述中，错误的是？",
        "options": [
            "A) 与高级语言源程序中的过程调用相对应",
            "B) 指令执行时必须保留返回地址",
            "C) 嵌套调用时返回地址通常保存在栈中",
            "D) 指令执行时转移目标地址无须在指令中明显给出"
        ],
        "answer": "C"
    },
    {
        "id": 12,
        "question": "假设P为调用过程，Q为被调用过程，程序在32位x86处理器上执行，以下是C语言程序中过程调用所涉及的操作：①Q保存P的现场；②P将实参存放到Q能访问的地方；③P将返回地址存放到特定处并转跳到Q；④Q取出返回地址并转跳回P；⑤Q恢复P的现场并释放局部变量空间；⑥执行Q的函数体。过程调用的正确执行步骤是？",
        "options": [
            "A) ②→③→④→①→⑥→⑤",
            "B) ②→③→①→④→⑥→⑤",
            "C) ②→③→①→⑥→⑤→④",
            "D) ②→③→①→⑥→④→⑤"
        ],
        "answer": "C"
    },
    {
        "id": 13,
        "question": "下列关于RISC的叙述中，正确的是？",
        "options": [
            "A) RISC机一定采用流水技术",
            "B) 采用流水技术的机器一定是RISC机",
            "C) RISC机的兼容性优于CISC机",
            "D) CPU配备很少的通用寄存器"
        ],
        "answer": "C"
    },
    {
        "id": 14,
        "question": "下列描述中，不符合RISC指令系统特点的是？",
        "options": [
            "A) 指令长度固定，指令种类少",
            "B) 寻址方式种类尽量减少，指令功能尽可能强",
            "C) 增加寄存器的数目，以尽量减少访存次数",
            "D) 选取使用频率最高的一些简单指令"
        ],
        "answer": "C"
    },
    {
        "id": 15,
        "question": "以下有关RISC的描述中，正确的是？",
        "options": [
            "A) 新设计的RISC是从CISC系统中挑选一部分实现的",
            "B) 采用RISC技术后，计算机体系结构恢复到了早期情况",
            "C) RISC的主要目标是减少指令数，因此允许增加每条指令的功能",
            "D) 以上说法都不对"
        ],
        "answer": "C"
    },
    {
        "id": 16,
        "question": "下列关于RISC和CISC的说法中，不正确的是？",
        "options": [
            "A) RISC指令格式种类少，寻址方式少，指令长度固定",
            "B) CISC指令功能强大，寻址方式多，便于汇编程序员编程",
            "C) CISC指令格式种类多，所以更有利于编译优化",
            "D) RISC多数指令能在一个时钟周期内完成，适合流水线"
        ],
        "answer": "C"
    },
    {
        "id": 17,
        "question": "下列关于RISC的说法中，错误的是？",
        "options": [
            "A) RISC普遍采用微程序控制器",
            "B) RISC大多数指令在一个时钟周期内完成",
            "C) RISC的内部通用寄存器数量相对CISC多",
            "D) RISC的指令数、寻址方式和指令格式种类相对CISC少"
        ],
        "answer": "C"
    },
    {
        "id": 18,
        "question": "下列关于指令集体系结构和指令系统的说法中，错误的是？",
        "options": [
            "A) 指令集体系结构位于计算机软/硬件的交界面上",
            "B) 指令集体系结构是指低级语言程序员所看到的概念结构和功能特性",
            "C) 任何程序运行前都要先转换为机器语言程序",
            "D) 指令系统和机器语言是无关的"
        ],
        "answer": "C"
    },
    {
        "id": 19,
        "question": "下列有关指令集体系结构（ISA）的叙述中，错误的是？",
        "options": [
            "A) ISA规定了执行每条指令时所包含的控制信号",
            "B) ISA规定了指令获取操作数的方式，即寻址方式",
            "C) ISA规定了所有指令的集合，包括指令格式和操作类型",
            "D) ISA规定了程序可访问的寄存器个数、存储空间大小、编址方式和大端/小端方式"
        ],
        "answer": "C"
    },
    {
        "id": 20,
        "question": "在CPU执行指令的过程中，指令的地址由（）给出？",
        "options": [
            "A) 程序计数器 (PC)",
            "B) 指令的地址码字段",
            "C) 操作系统",
            "D) 程序员"
        ],
        "answer": "C"
    },
    {
        "id": 21,
        "question": "运算型指令的寻址与转移型指令的寻址的不同点在于？",
        "options": [
            "A) 前者取操作数，后者决定程序转移地址",
            "B) 后者取操作数，前者决定程序转移地址",
            "C) 前者是短指令，后者是长指令",
            "D) 前者是长指令，后者是短指令"
        ],
        "answer": "C"
    },
    {
        "id": 22,
        "question": "程序控制类指令的功能是？",
        "options": [
            "A) 进行算术运算和逻辑运算",
            "B) 进行主存与CPU之间的数据传送",
            "C) 进行CPU和I/O设备之间的数据传送",
            "D) 改变程序执行的顺序"
        ],
        "answer": "C"
    },
    {
        "id": 23,
        "question": "下列指令中不属于程序控制指令的是？",
        "options": [
            "A) 无条件转移指令",
            "B) 条件转移指令",
            "C) 中断隐指令",
            "D) 循环指令"
        ],
        "answer": "C"
    },
    {
        "id": 24,
        "question": "下列指令中应用程序不准使用的指令是？",
        "options": [
            "A) 循环指令",
            "B) 转换指令",
            "C) 特权指令",
            "D) 条件转移指令"
        ],
        "answer": "C"
    },
    {
        "id": 25,
        "question": "堆栈计算机中，有些堆栈零地址的运算类指令在指令格式中不给出操作数的地址，参加的两个操作数来自？",
        "options": [
            "A) 累加器和寄存器",
            "B) 累加器和暂存器",
            "C) 堆栈的栈顶和次栈顶单元",
            "D) 堆栈的栈顶单元和暂存器"
        ],
        "answer": "C"
    },
    {
        "id": 26,
        "question": "以下叙述错误的是？",
        "options": [
            "A) 为了便于取指令，指令的长度通常为存储字长的整数倍",
            "B) 单地址指令是固定长度的指令",
            "C) 单字长指令可加快取指令的速度",
            "D) 单地址指令可能有一个操作数，也可能有两个操作数"
        ],
        "answer": "C"
    },
    {
        "id": 27,
        "question": "能够完成两个数的算术运算的单地址指令，地址码指明一个操作数，另一个操作数来自（）方式？",
        "options": [
            "A) 立即寻址",
            "B) 隐含寻址",
            "C) 间接寻址",
            "D) 基址寻址"
        ],
        "answer": "C"
    },
    {
        "id": 28,
        "question": "设机器字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其寻址单元数是？",
        "options": [
            "A) 2^24",
            "B) 2^23",
            "C) 2^22",
            "D) 2^21"
        ],
        "answer": "C"
    },
    {
        "id": 29,
        "question": "某指令系统有200条指令，对操作码采用固定长度二进制编码，最少需要用（）位？",
        "options": [
            "A) 4",
            "B) 8",
            "C) 16",
            "D) 32"
        ],
        "answer": "C"
    },
    {
        "id": 30,
        "question": "在指令格式中，采用扩展操作码设计方案的目的是？",
        "options": [
            "A) 减少指令字长度",
            "B) 增加指令字长度",
            "C) 保持指令字长度不变而增加寻址空间",
            "D) 保持指令字长度不变而增加指令的数量"
        ],
        "answer": "C"
    },
    {
        "id": 31,
        "question": "一个计算机系统采用32位单字长指令，地址码为12位，若定义了250条二地址指令，则还可以有（）条单地址指令？",
        "options": [
            "A) 2^12",
            "B) 2^13",
            "C) 2^14",
            "D) 3×2^13"
        ],
        "answer": "C"
    },
    {
        "id": 32,
        "question": "某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令29条、二地址指令107条，每个地址字段为6位，则指令字长至少应该是（）？",
        "options": [
            "A) 24位",
            "B) 26位",
            "C) 28位",
            "D) 32位"
        ],
        "answer": "C"
    },
    {
        "id": 33,
        "question": "下列选项中，属于指令集体系结构（ISA）规定的内容是？",
        "options": [
            "A) 仅I、II",
            "B) 仅I、III",
            "C) 仅II、IV",
            "D) 仅I、III、IV"
        ],
        "answer": "C"
    },
    {
        "id": 34,
        "question": "设计某指令系统时，假设采用16位定长指令字格式，操作码使用扩展编码方式，地址码为6位，包含零地址、一地址和二地址3种格式的指令。若二地址指令有12条，一地址指令有254条，则零地址指令的条数最多为（）？",
        "options": [
            "A) 0",
            "B) 2",
            "C) 64",
            "D) 128"
        ],
        "answer": "C"
    },
    {
        "id": 35,
        "question": "指令系统中采用不同寻址方式的目的是？",
        "options": [
            "A) 提供扩展操作码的可能并降低指令译码难度",
            "B) 可缩短指令字长，扩大寻址空间，提高编程的灵活性",
            "C) 实现程序控制",
            "D) 三者都正确"
        ],
        "answer": "C"
    },
    {
        "id": 36,
        "question": "采用直接转移的无条件转移指令的功能是将指令中的地址码送入（）？",
        "options": [
            "A) 程序计数器(PC)",
            "B) 累加器(ACC)",
            "C) 指令寄存器(IR)",
            "D) 地址寄存器(MAR)"
        ],
        "answer": "C"
    },
    {
        "id": 37,
        "question": "为了缩短指令中某个地址段的位数，有效的方法是采取（）？",
        "options": [
            "A) 立即寻址",
            "B) 变址寻址",
            "C) 间接寻址",
            "D) 寄存器寻址"
        ],
        "answer": "C"
    },
    {
        "id": 38,
        "question": "简化地址结构的基本方法是尽量采用（）？",
        "options": [
            "A) 寄存器寻址",
            "B) 隐含寻址",
            "C) 直接寻址",
            "D) 间接寻址"
        ],
        "answer": "C"
    },
    {
        "id": 39,
        "question": "在指令寻址的各种方式中，获取操作数最快的方式是（）？",
        "options": [
            "A) 直接寻址",
            "B) 立即寻址",
            "C) 寄存器寻址",
            "D) 间接寻址"
        ],
        "answer": "C"
    },
    {
        "id": 40,
        "question": "假定指令中地址码所给出的是操作数的有效地址，则该指令采用（）？",
        "options": [
            "A) 直接寻址",
            "B) 立即寻址",
            "C) 寄存器寻址",
            "D) 间接寻址"
        ],
        "answer": "C"
    },
    {
        "id": 41,
        "question": "设指令中的地址码为A，变址寄存器为X，程序计数器为PC，则变址间址寻址方式的操作数的有效地址EA是（）？",
        "options": [
            "A) (PC)+A",
            "B) (X)+A",
            "C) (X+(A))",
            "D) (X)+A"
        ],
        "answer": "C"
    },
    {
        "id": 42,
        "question": "（）便于处理数组问题？",
        "options": [
            "A) 间接寻址",
            "B) 变址寻址",
            "C) 相对寻址",
            "D) 基址寻址"
        ],
        "answer": "C"
    },
    {
        "id": 43,
        "question": "堆栈寻址方式中，设A为累加器，SP为堆栈指示器，M为SP指示的栈顶单元。若进栈操作的动作是(A)→M,(SP)-1→SP，则出栈操作的动作应为（）？",
        "options": [
            "A) (Msp)→A,(SP)+1→SP",
            "B) (SP)+1→SP,(Msp)→A",
            "C) (SP)-1→SP,(Msp)→A",
            "D) (Msp)→A,(SP)-1→SP"
        ],
        "answer": "C"
    },
    {
        "id": 44,
        "question": "相对寻址方式中，指令所提供的相对地址实质上是一种（）？",
        "options": [
            "A) 立即数",
            "B) 内存地址",
            "C) 以本条指令在内存中首地址为基准位置的偏移量",
            "D) 以下条指令在内存中首地址为基准位置的偏移量"
        ],
        "answer": "C"
    },
    {
        "id": 45,
        "question": "下列关于堆栈寻址的描述中，错误的是（）？",
        "options": [
            "A) 可以用内存来实现堆栈",
            "B) 堆栈寻址要求计算机中设有堆栈",
            "C) 可以用硬盘来实现堆栈，称为硬堆栈",
            "D) 可以用寄存器组来实现堆栈"
        ],
        "answer": "C"
    },
    {
        "id": 46,
        "question": "指令寻址方式有顺序和跳跃两种，采用跳跃寻址方式可以实现（）？",
        "options": [
            "A) 程序浮动",
            "B) 程序的无条件浮动和条件浮动",
            "C) 程序的无条件转移和条件转移",
            "D) 程序的调用"
        ],
        "answer": "C"
    },
    {
        "id": 47,
        "question": "寄存器R1、R2均为16位，指令MOV R1,[R2]的功能是把内存数据传送至寄存器R1，寻址方式为寄存器间接寻址。R2的值为1234H，内存单元1234H存放数据56H，内存单元1235H存放数据78H，采用小端方式存储。则执行指令后R1的值为（）？",
        "options": [
            "A) 5678H",
            "B) 7856H",
            "C) 8765H",
            "D) 6587H"
        ],
        "answer": "C"
    },
    {
        "id": 48,
        "question": "某计算机的字长为16位，主存按字编址。转移指令由两个字节组成，采用相对寻址，第一个字节为操作码字段，第二个字节为相对偏移量字段。若某转移指令所在的主存地址为4000H，相对偏移量字段的内容为06H，则该转移指令执行后的PC值为（）？",
        "options": [
            "A) 4002H",
            "B) 4004H",
            "C) 4007H",
            "D) 4008H"
        ],
        "answer": "C"
    },
    {
        "id": 49,
        "question": "某计算机的指令字长为16位，由低到高第0～7位是形式地址D，第8～9位为寻址特征位X，第10～15位为操作码。当X=00时为直接寻址；当X=01时使用X1进行变址寻址；当X=10时使用X2进行变址寻址；当X=11时为相对寻址。设(PC)=1234H，(X1)=0005H，(X2)=1188H，则指令2222H的有效地址是（）？",
        "options": [
            "A) 1256H",
            "B) 0027H",
            "C) 2222H",
            "D) 11AAH"
        ],
        "answer": "C"
    },
    {
        "id": 50,
        "question": "某机器指令字长为16位，主存按字节编址，取指令时，每取一字节，PC自动加1。当前指令地址为2000H，指令内容为相对寻址的无条件转移指令，指令中的形式地址为40H。则取指令后及指令执行后PC的内容为（）？",
        "options": [
            "A) 2000H,2042H",
            "B) 2002H,2040H",
            "C) 2002H,2042H",
            "D) 2000H,2040H"
        ],
        "answer": "C"
    },
    {
        "id": 51,
        "question": "某计算机的主存容量为4M×16位，且存储字长等于指令字长，若该机能完成97种操作，操作码位数固定，且有直接、间接、基址、变址、相对、立即六种寻址方式，则相对寻址的偏移量范围为（）？",
        "options": [
            "A) (-32,+31)",
            "B) (-64,+63)",
            "C) (-128,+127)",
            "D) (-256,+255)"
        ],
        "answer": "C"
    },
    {
        "id": 52,
        "question": "对按字寻址的机器，程序计数器和指令寄存器的位数各取决于（）？",
        "options": [
            "A) 机器字长，存储器的字数",
            "B) 存储器的字数，指令字长",
            "C) 指令字长，机器字长",
            "D) 地址总线宽度，存储器的字数"
        ],
        "answer": "C"
    },
    {
        "id": 53,
        "question": "假设寄存器R中的数值为200，主存地址为200和300的地址单元中存放的内容分别是300和400，则（）方式下访问到的操作数为200？",
        "options": [
            "A) 直接寻址200",
            "B) 寄存器间接寻址 (R)",
            "C) 存储器间接寻址(200)",
            "D) 寄存器寻址R"
        ],
        "answer": "C"
    },
    {
        "id": 54,
        "question": "假设某条指令的第一个操作数采用寄存器间接寻址方式，指令中给出的寄存器编号为8，8号寄存器的内容为1200H，地址为1200H的单元中的内容为12FCH，地址为12FCH的单元中的内容为38D8H，而地址为38D8H的单元中的内容为88F9H，则该操作数的有效地址为（）？",
        "options": [
            "A) 1200H",
            "B) 12FCH",
            "C) 38D8H",
            "D) 88F9H"
        ],
        "answer": "C"
    },
    {
        "id": 55,
        "question": "某计算机按字节编址，采用大端方式，某指令的一个操作数的机器数为ABCD00FFH，该操作数采用基址寻址方式，指令中形式地址（用补码表示）为FF00H，当前基址寄存器的内容为C0000000H，则该操作数的LSB（即FFH）存放的地址是（）？",
        "options": [
            "A) C000FF00H",
            "B) C000FF03H",
            "C) BFFFFF00H",
            "D) BFFFFF03H"
        ],
        "answer": "C"
    },
    {
        "id": 56,
        "question": "关于指令的功能及分类，下列叙述中正确的是（）？",
        "options": [
            "A) 算术与逻辑运算指令，通常完成算术运算或逻辑运算，都需要两个数据",
            "B) 移位操作指令，通常用于把指定的两个操作数左移或右移一位",
            "C) 转移指令、子程序调用与返回指令，用于解决数据调用次序的需求",
            "D) 特权指令，通常仅用于实现系统软件，这类指令一般不提供给用户"
        ],
        "answer": "C"
    },
    {
        "id": 57,
        "question": "某机器有一个标志寄存器，其中有进位/借位标志CF、零标志ZF、符号标志SF和溢出标志OF，条件转移指令bgt（无符号整数比较大于时转移）的转移条件是（）？",
        "options": [
            "A) CF+OF=1",
            "B) SF+ZF=1",
            "C) CF+ZF=1",
            "D) CF+SF=1"
        ],
        "answer": "C"
    },
    {
        "id": 58,
        "question": "某计算机字长为16位，标志寄存器中存在ZF、SF、OF和CF标志位，采用双字节字长指令字。假定bgt（大于零转移）指令的第一个字节指明操作码和寻址方式，第二个字节为立即数lmm8，用补码表示。指令功能是：若跳转条件成立，则PC=PC+2+lmm8×2；否则，PC=PC+2。则下列叙述中错误的是（）？",
        "options": [
            "A) 该计算机按字节编址",
            "B) 若bgt指令是无符号整数的比较，则跳转条件可以是ZF+CF=0",
            "C) 若bgt指令是有符号整数的比较，则跳转条件可以是SF⊕OF=0",
            "D) 转移目标地址的范围是相对于bgt指令的前127条指令到后128条指令之间"
        ],
        "answer": "C"
    },
    {
        "id": 59,
        "question": "【2011统考真题】某机器字长为16位，主存按字节编址，转移指令采用相对寻址，由2字节组成，第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一字节PC自动加1。若某转移指令所在主存地址为2000H，相对位移量字段的内容为06H，则该转移指令成功转移后的目标地址是（）？",
        "options": [
            "A) 2006H",
            "B) 2007H",
            "C) 2008H",
            "D) 2009H"
        ],
        "answer": "C"
    },
    {
        "id": 60,
        "question": "【2011统考真题】偏移寻址通过将某个寄存器的内容与一个形式地址相加来生成有效地址。下列寻址方式中，不属于偏移寻址方式的是（）？",
        "options": [
            "A) 间接寻址",
            "B) 基址寻址",
            "C) 相对寻址",
            "D) 变址寻址"
        ],
        "answer": "C"
    },
    {
        "id": 61,
        "question": "【2013统考真题】假设变址寄存器R的内容为1000H，指令中的形式地址为2000H；地址1000H中的内容为2000H，地址2000H中的内容为3000H，地址3000H中的内容为4000H，则变址寻址方式下访问到的操作数是（）？",
        "options": [
            "A) 1000H",
            "B) 2000H",
            "C) 3000H",
            "D) 4000H"
        ],
        "answer": "C"
    },
    {
        "id": 62,
        "question": "【2014统考真题】某计算机有16个通用寄存器，采用32位定长指令字，操作码字段（含寻址方式位）为8位，STORE指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任意一个通用寄存器，且偏移量用补码表示，则STORE指令中偏移量的取值范围是（）？",
        "options": [
            "A) -32768~+32767",
            "B) -32767~+32768",
            "C) -65536~+65535",
            "D) -65535~+65536"
        ],
        "answer": "C"
    },
    {
        "id": 63,
        "question": "【2016统考真题】某指令格式如下所示。OP | M | I | D | 其中M为寻址方式，I为变址寄存器编号，D为形式地址。若采用先变址后间址的寻址方式，则操作数的有效地址是（）？",
        "options": [
            "A) (I)+D",
            "B) (I+D)",
            "C) ((I)+D)",
            "D) (I)+D"
        ],
        "answer": "C"
    },
    {
        "id": 64,
        "question": "【2017统考真题】下列寻址方式中，最适合按下标顺序访问一维数组元素的是（）？",
        "options": [
            "A) 相对寻址",
            "B) 寄存器寻址",
            "C) 直接寻址",
            "D) 变址寻址"
        ],
        "answer": "C"
    },
    {
        "id": 65,
        "question": "【2018统考真题】按字节编址的计算机中，某double型数组A的首地址为2000H，使用变址寻址和循环结构访问数组A，保存数组下标的变址寄存器的初值为0，每次循环取一个数组元素，其偏移地址为变址值乘以sizeof(double)，取完后变址寄存器的内容自动加1。若某次循环所取元素的地址为2100H，则进入该次循环时变址寄存器的内容是（）？",
        "options": [
            "A) 25",
            "B) 32",
            "C) 64",
            "D) 100"
        ],
        "answer": "C"
    },
    {
        "id": 66,
        "question": "【2019统考真题】某计算机采用大端方式，按字节编址。某指令中操作数的机器数为1234FF00H，该操作数采用基址寻址方式，形式地址（用补码表示）为FF12H，基址寄存器的内容为F0000000H，则该操作数的LSB（最低有效字节）所在的地址是（）？",
        "options": [
            "A) F000FF12H",
            "B) F000FF15H",
            "C) EFFFFF12H",
            "D) EFFFFF15H"
        ],
        "answer": "C"
    },
    {
        "id": 67,
        "question": "【2020统考真题】某计算机采用16位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有48条指令，支持直接、间接、立即、相对4种寻址方式。在单地址指令中，直接寻址方式的可寻址范围是（）？",
        "options": [
            "A) 0~255",
            "B) 0~1023",
            "C) -128~127",
            "D) -512~511"
        ],
        "answer": "C"
    },
    {
        "id": 68,
        "question": "【2023统考真题】某运算类指令中有一个地址码为通用寄存器编号，对应通用寄存器中存放的是操作数或操作数的地址，CPU区分两者的依据是（）？",
        "options": [
            "A) 操作数的寻址方式",
            "B) 操作数的编码方式",
            "C) 通用寄存器的编号",
            "D) 通用寄存器的内容"
        ],
        "answer": "C"
    }
]
          ,
          chapter5: [
  {
    "id": 1,
    "question": "下列部件不属于控制器的是()。",
    "options": ["A) 指令寄存器", "B) 程序计数器", "C) 程序状态字寄存器", "D) 时序电路"],
    "answer": "C"
  },
  {
    "id": 2,
    "question": "通用寄存器是()。",
    "options": ["A) 可存放指令的寄存器", "B) 可存放程序状态字的寄存器", "C) 本身具有计数逻辑与移位逻辑的寄存器", "D) 可编程指定多种功能的寄存器"],
    "answer": "C"
  },
  {
    "id": 3,
    "question": "CPU中保存当前正在执行指令的寄存器是()。",
    "options": ["A) 指令寄存器", "B) 指令译码器", "C) 数据寄存器", "D) 地址寄存器"],
    "answer": "C"
  },
  {
    "id": 4,
    "question": "在CPU中，跟踪后继指令地址的寄存器是()。",
    "options": ["A) 指令寄存器", "B) 程序计数器", "C) 地址寄存器", "D) 状态寄存器"],
    "answer": "C"
  },
  {
    "id": 5,
    "question": "条件转移指令执行时所依据的条件来自()。",
    "options": ["A) 指令寄存器", "B) 标志寄存器", "C) 程序计数器", "D) 地址寄存器"],
    "answer": "C"
  },
  {
    "id": 6,
    "question": "在所谓的n位CPU中，n是指()。",
    "options": ["A) 地址总线线数", "B) 数据总线线数", "C) 控制总线线数", "D) I/O线数"],
    "answer": "C"
  },
  {
    "id": 7,
    "question": "在CPU的寄存器中，()对用户是透明的。",
    "options": ["A) 程序计数器", "B) 状态寄存器", "C) 指令寄存器", "D) 通用寄存器"],
    "answer": "C"
  },
  {
    "id": 8,
    "question": "指令()从主存储器中读出。",
    "options": ["A) 总是根据程序计数器", "B) 有时根据程序计数器，有时根据转移指令", "C) 根据地址寄存器", "D) 有时根据程序计数器，有时根据地址寄存器"],
    "answer": "C"
  },
  {
    "id": 9,
    "question": "程序计数器(PC)属于()。",
    "options": ["A) 运算器", "B) 控制器", "C) 存储器", "D) ALU"],
    "answer": "C"
  },
  {
    "id": 10,
    "question": "下面有关程序计数器(PC)的叙述中，错误的是()。",
    "options": ["A) PC中总是存放指令地址", "B) PC的值由CPU在执行指令过程中进行修改", "C) 执行转移指令时，PC的值总是修改为转移指令的目标地址", "D) PC的位数一般和存储器地址寄存器(MAR)的位数一样"],
    "answer": "C"
  },
  {
    "id": 11,
    "question": "程序计数器(PC)可以使用字节地址或字地址，其位数取决于()。",
    "options": ["A) 存储器的容量", "B) 机器字长", "C) 指令字长", "D) 存储器地址寄存器位数"],
    "answer": "C"
  },
  {
    "id": 12,
    "question": "下列关于程序计数器(PC)的叙述中，错误的是()。",
    "options": ["A) 机器指令中不能显式地使用PC", "B) 指令顺序执行时，PC值总是自动加1", "C) 调用指令执行后，PC值一定是被调用过程的入口地址", "D) 无条件转移指令执行后，PC值一定是转移目标地址"],
    "answer": "C"
  },
  {
    "id": 13,
    "question": "指令寄存器(IR)的位数取决于()。",
    "options": ["A) 存储器的容量", "B) 机器字长", "C) 指令字长", "D) 存储字长"],
    "answer": "C"
  },
  {
    "id": 14,
    "question": "CPU中通用寄存器的位数取决于()。",
    "options": ["A) 存储器的容量", "B) 指令的长度", "C) 机器字长", "D) 都不对"],
    "answer": "C"
  },
  {
    "id": 15,
    "question": "CPU中的通用寄存器，()。",
    "options": ["A) 只能存放数据，不能存放地址", "B) 可以存放数据和地址", "C) 既不能存放数据，又不能存放地址", "D) 可以存放数据和地址，还可以替代指令寄存器"],
    "answer": "C"
  },
  {
    "id": 16,
    "question": "在计算机系统中表示程序和机器运行状态的部件是()。",
    "options": ["A) 程序计数器", "B) 累加寄存器", "C) 中断寄存器", "D) 程序状态字寄存器"],
    "answer": "C"
  },
  {
    "id": 17,
    "question": "状态寄存器用来存放()。",
    "options": ["A) 算术运算结果", "B) 逻辑运算结果", "C) 运算类型", "D) 算术、逻辑运算及测试指令的结果状态"],
    "answer": "C"
  },
  {
    "id": 18,
    "question": "下列关于标志寄存器(EFLAGS寄存器或PSW寄存器)的叙述中，错误的是()。",
    "options": ["A) 不需要像通用寄存器那样，对标志寄存器进行编号", "B) 条件转移指令根据其中的一些标志位来确定PC的值", "C) 可以通过指令直接访问标志寄存器并修改它的值", "D) 可以用它来存放执行指令得到的各种标志信息"],
    "answer": "C"
  },
  {
    "id": 19,
    "question": "控制器的全部功能是()。",
    "options": ["A) 产生时序信号", "B) 从主存储器中取出指令并完成指令操作码译码", "C) 从主存储器中取出指令、分析指令并产生有关的操作控制信号", "D) 都不对"],
    "answer": "C"
  },
  {
    "id": 20,
    "question": "指令译码是指对()进行译码。",
    "options": ["A) 整条指令", "B) 指令的操作码字段", "C) 指令的地址码字段", "D) 指令的地址"],
    "answer": "C"
  },
  {
    "id": 21,
    "question": "CPU中不包括()。",
    "options": ["A) 存储器地址寄存器", "B) 指令寄存器", "C) 地址译码器", "D) 程序计数器"],
    "answer": "C"
  },
  {
    "id": 22,
    "question": "以下关于计算机系统的概念中，正确的是()。",
    "options": ["A) CPU不包括地址译码器", "B) CPU的程序计数器中存放的是操作数地址", "C) CPU中决定指令执行顺序的是程序计数器", "D) CPU的状态寄存器对用户是完全透明的"],
    "answer": "C"
  },
  {
    "id": 23,
    "question": "间址周期结束后，CPU内寄存器MDR中的内容为()。",
    "options": ["A) 指令", "B) 操作数地址", "C) 操作数", "D) 无法确定"],
    "answer": "C"
  },
  {
    "id": 24,
    "question": "一台32位计算机的主存储器容量为4GB，按字节编址，存储字长和指令字长都是32位。若指令按字边界对齐存放，则程序计数器(PC)的宽度至少是()。",
    "options": ["A) 32位", "B) 30位", "C) 8位", "D) 34位"],
    "answer": "C"
  },
  {
    "id": 25,
    "question": "【2010统考真题】下列寄存器中，汇编语言程序员可见的是()。",
    "options": ["A) 存储器地址寄存器(MAR)", "B) 程序计数器(PC)", "C) 存储器数据寄存器(MDR)", "D) 指令寄存器(IR)"],
    "answer": "C"
  },
  {
    "id": 26,
    "question": "【2016统考真题】某计算机的主存储器空间为4GB，字长为32位，按字节编址，采用32位字长指令字格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是()。",
    "options": ["A) 30,30", "B) 30,32", "C) 32,30", "D) 32,32"],
    "answer": "C"
  },
  {
    "id": 27,
    "question": "计算机工作的最小时间周期是()。",
    "options": ["A) 时钟周期", "B) 指令周期", "C) CPU周期", "D) 总线周期"],
    "answer": "C"
  },
  {
    "id": 28,
    "question": "采用DMA方式传递数据时，每传送一个数据就要占用()。",
    "options": ["A) 指令周期", "B) 时钟周期", "C) 机器周期", "D) 存取周期"],
    "answer": "C"
  },
  {
    "id": 29,
    "question": "指令周期是指()。",
    "options": ["A) CPU从主存取出一条指令的时间", "B) CPU执行一条指令的时间", "C) CPU从主存取出一条指令加上执行这条指令的时间", "D) 时钟周期时间"],
    "answer": "C"
  },
  {
    "id": 30,
    "question": "在一条无条件跳转指令的指令周期内，程序计数器(PC)的值被修改了()次。",
    "options": ["A) 1", "B) 2", "C) 3", "D) 不能确定"],
    "answer": "C"
  },
  {
    "id": 31,
    "question": "取指操作后，程序计数器中存放的是()。",
    "options": ["A) 当前指令的地址", "B) 程序中指令的数量", "C) 已执行的指令数量", "D) 下一条指令的地址"],
    "answer": "C"
  },
  {
    "id": 32,
    "question": "下列关于指令执行的叙述中，错误的是()。",
    "options": ["A) 指令周期的第一个操作是取指令", "B) 为了进行取指操作，控制器需要得到相应的指令", "C) 取指操作是控制器自动进行的", "D) 指令执行时有些操作是相同或相似的"],
    "answer": "C"
  },
  {
    "id": 33,
    "question": "下列关于指令执行过程的叙述中，错误的是()。",
    "options": ["A) 取指操作是控制器固有的功能，不需要在操作码控制下完成", "B) 所有指令的取指操作是相同的", "C) 在指令长度相同的情况下，所有指令的取指操作是相同的", "D) 中断周期是在指令执行完成后出现的"],
    "answer": "C"
  },
  {
    "id": 34,
    "question": "指令周期由一个到几个机器周期组成，第一个机器周期是()。",
    "options": ["A) 从主存中取出指令字", "B) 从主存中取出指令操作码", "C) 从主存中取出指令地址码", "D) 从主存中取出指令的地址"],
    "answer": "C"
  },
  {
    "id": 35,
    "question": "由于CPU内部操作的速度较快，而CPU访问一次存储器的时间较长，因此机器周期通常由()来确定。",
    "options": ["A) 指令周期", "B) 存取周期", "C) 间址周期", "D) 中断周期"],
    "answer": "C"
  },
  {
    "id": 36,
    "question": "下列有关机器周期的叙述中，错误的是()。",
    "options": ["A) 通常把通过一次总线事务访问一次主存或I/O的时间定为一个机器周期", "B) 一个指令周期通常包含多个机器周期", "C) 不同的指令周期所包含的机器周期数可能不同", "D) 每个指令周期都包含一个中断响应机器周期"],
    "answer": "C"
  },
  {
    "id": 37,
    "question": "下列关于多周期CPU的说法中，合理的是()。",
    "options": ["A) 执行各条指令的机器周期数相同，各机器周期的长度均匀", "B) 执行各条指令的机器周期数相同，各机器周期的长度可变", "C) 执行各条指令的机器周期数可变，各机器周期的长度均匀", "D) 执行各条指令的机器周期数可变，各机器周期的长度可变"],
    "answer": "C"
  },
  {
    "id": 38,
    "question": "以下关于间址周期的描述中，正确的是()。",
    "options": ["A) 所有指令的间址操作都是相同的", "B) 凡是存储器间接寻址的指令，它们的操作都是相同的", "C) 对于存储器间接寻址和寄存器间接寻址，它们的操作是不同的", "D) 都不对"],
    "answer": "C"
  },
  {
    "id": 39,
    "question": "()可区分存储单元中存放的是指令还是数据。",
    "options": ["A) 控制器", "B) 运算器", "C) 存储器", "D) 数据通路"],
    "answer": "C"
  },
  {
    "id": 40,
    "question": "下列关于各种字长的说法中，正确的是()。",
    "options": ["A) 指令字长等于机器字长的前提下，取指周期等于机器周期", "B) 指令字长等于存储字长的前提下，取指周期等于机器周期", "C) 指令字长和机器字长的长度没有任何关系", "D) 为了硬件设计方便，指令字长都和存储字长一样大"],
    "answer": "C"
  },
  {
    "id": 41,
    "question": "下列关于单周期CPU和多周期CPU的描述中，错误的是()。",
    "options": ["A) 执行任何指令，单周期CPU的时间都要小于多周期CPU", "B) 单周期CPU部件冗余大，时间利用率低，多周期CPU则刚好相反", "C) 单周期CPU在1个时钟周期内执行一条指令，CPI=1", "D) 多周期CPU至少需要2个时钟周期才能执行一条指令，CPI>1"],
    "answer": "C"
  },
  {
    "id": 42,
    "question": "【2009统考真题】冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是()。",
    "options": ["A) 指令操作码的译码结果", "B) 指令和数据的寻址方式", "C) 指令周期的不同阶段", "D) 指令和数据所在的存储单元"],
    "answer": "C"
  },
  {
    "id": 43,
    "question": "【2011统考真题】假定不采用Cache和指令预取技术，且机器处于“开中断”状态，则在下列有关指令执行的叙述中，错误的是()。",
    "options": ["A) 每个指令周期中CPU都至少访存一次", "B) 每个指令周期一定大于或等于一个CPU时钟周期", "C) 空操作指令的指令周期中任何寄存器的内容都不会被改变", "D) 当前程序在每条指令执行结束时都可能被外部中断打断"],
    "answer": "C"
  },
  {
    "id": 44,
    "question": "下列不属于CPU数据通路结构的是()。",
    "options": ["A) 单总线结构", "B) 多总线结构", "C) 部件内总线结构", "D) 专用数据通路结构"],
    "answer": "C"
  },
  {
    "id": 45,
    "question": "下列有关数据通路的叙述中，错误的是()。",
    "options": ["A) 数据通路由若干组合逻辑元件和时序逻辑元件连接而成", "B) 数据通路的功能由控制部件送出的控制信号决定", "C) ALU属于操作元件，用于执行各类算术和逻辑运算", "D) 通用寄存器属于状态元件，但不包含在数据通路中"],
    "answer": "C"
  },
  {
    "id": 46,
    "question": "在单总线的CPU中，()。",
    "options": ["A) ALU的两个输入端及输出端都可与总线相连", "B) ALU的两个输入端可以与总线相连，但输出端需通过暂存器与总线相连", "C) ALU的一个输入端可以与总线相连，其输出端也可与总线相连", "D) ALU只能有一个输入端可以与总线相连，另一输入端需通过暂存器与总线相连"],
    "answer": "C"
  },
  {
    "id": 47,
    "question": "CPU内部如果多个部件共享一条总线，则每个部件与总线之间需设置一个常用的器件，CPU控制该器件的状态，实现某个部件与总线的连接或断开。该器件是()。",
    "options": ["A) 触发器", "B) 多路选择器", "C) 三态门", "D) 与非门"],
    "answer": "C"
  },
  {
    "id": 48,
    "question": "CPU内部电路通常采用总线连接方式，总线上信号流动的原则是()。",
    "options": ["A) 每个时刻只有一个器件发出信息，每个时刻只有一个器件接收信息", "B) 每个时刻有一个或多个器件发出信息，每个时刻有一个或多个器件接收信息", "C) 每个时刻只有一个器件发出信息，每个时刻有一个或多个器件接收信息", "D) 每个时刻有一个或多个器件发出信息，每个时刻只有一个器件接收信息"],
    "answer": "C"
  },
  {
    "id": 49,
    "question": "下列关于单周期数据通路和多周期数据通路的说法中，正确的是()。",
    "options": ["A) 单周期CPU的CPI总比多周期CPU的CPI大", "B) 单周期CPU的时钟周期通常比多周期CPU的时钟周期短", "C) 在一条指令执行过程中，单周期CPU中的每个控制信号取值一直不变，而多周期CPU中的控制信号可能会发生改变", "D) 在一条指令执行过程中，单周期数据通路和多周期数据通路中的每个部件都可使用多次"],
    "answer": "C"
  },
  {
    "id": 50,
    "question": "采用CPU内部总线的数据通路与不采用CPU内部总线的数据通路相比，()。",
    "options": ["A) 前者性能较高", "B) 后者的数据冲突问题较严重", "C) 前者的硬件量大，实现难度高", "D) 以上说法都不对"],
    "answer": "C"
  },
  {
    "id": 51,
    "question": "CPU的读/写控制信号的作用是()。",
    "options": ["A) 决定数据总线上的数据流方向", "B) 控制存储器操作的读/写类型", "C) 控制流入、流出存储器信息的方向", "D) 以上都是"],
    "answer": "C"
  },
  {
    "id": 52,
    "question": "【2016统考真题】单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是()。",
    "options": ["A) 可以采用单总线结构数据通路", "B) 处理器时钟频率较低", "C) 在指令执行过程中控制信号不变", "D) 每条指令的CPI为1"],
    "answer": "C"
  },
  {
    "id": 53,
    "question": "【2021统考真题】下列关于数据通路的叙述中，错误的是()。",
    "options": ["A) 数据通路包含ALU等组合逻辑（操作）元件", "B) 数据通路包含寄存器等时序逻辑（状态）元件", "C) 数据通路不包含用于异常事件检测及响应的电路", "D) 数据通路中的数据流动路径由控制信号进行控制"],
    "answer": "C"
  },
  {
    "id": 54,
    "question": "【2023统考真题】数据通路由组合逻辑元件（操作元件）和时序逻辑元件（状态元件）组成。下列给出的元件中，属于操作元件的是()。",
    "options": ["A) 仅I、Ⅱ", "B) 仅Ⅳ", "C) 仅Ⅱ、Ⅲ", "D) 仅I、Ⅱ、Ⅳ"],
    "answer": "C"
  },
  {
    "id": 55,
    "question": "取指令操作()。",
    "options": ["A) 受到上一条指令的操作码控制", "B) 受到当前指令的操作码控制", "C) 受到下一条指令的操作码控制", "D) 是控制器固有的功能，不需要在操作码控制下进行"],
    "answer": "C"
  },
  {
    "id": 56,
    "question": "在组合逻辑控制器中，操作控制信号的形成主要与()信号有关。",
    "options": ["A) 指令操作码和地址码", "B) 指令译码信号和时钟", "C) 操作码和条件码", "D) 状态信息和条件"],
    "answer": "C"
  },
  {
    "id": 57,
    "question": "在微程序控制器中，形成微程序入口地址的是()。",
    "options": ["A) 机器指令的地址码字段", "B) 微指令的微地址码字段", "C) 机器指令的操作码字段", "D) 微指令的微操作码字段"],
    "answer": "C"
  },
  {
    "id": 58,
    "question": "下列不属于微指令结构设计所追求目标的是()。",
    "options": ["A) 提高微程序的执行速度", "B) 提供程序设计的灵活性", "C) 缩短微指令的长度", "D) 增大控制存储器的容量"],
    "answer": "C"
  },
  {
    "id": 59,
    "question": "微程序控制器的速度比硬布线控制器慢，主要是因为()。",
    "options": ["A) 增加了从磁盘存储器读取微指令的时间", "B) 增加了从主存读取微指令的时间", "C) 增加了从指令寄存器读取微指令的时间", "D) 增加了从控制存储器读取微指令的时间"],
    "answer": "C"
  },
  {
    "id": 60,
    "question": "下列关于微指令的说法中，错误的是()。",
    "options": ["A) 字段直接编码方式可用较少的二进制位数表示较多的微操作命令", "B) 直接编码方式不用进行译码操作，微命令字段中的每一位都代表一个微命令", "C) 垂直型微指令用较长的微程序结构换取较短的微指令结构，所以在执行效率和灵活性两方面都高于水平型微指令", "D) 在字段间接编码方式中，某个字段的译码输出需要依靠另外某个字段的输入"],
    "answer": "C"
  },
  {
    "id": 61,
    "question": "微程序控制存储器属于()的一部分。",
    "options": ["A) 主存", "B) 外存", "C) CPU", "D) 缓存"],
    "answer": "C"
  },
  {
    "id": 62,
    "question": "以下说法中，正确的是()。",
    "options": ["A) 采用微程序控制器是为了提高速度", "B) 控制存储器由高速RAM电路组成", "C) 微指令计数器决定指令执行顺序", "D) 一条指令存放在控制器的一个控制存储器单元中"],
    "answer": "C"
  },
  {
    "id": 63,
    "question": "硬布线控制器与微程序控制器相比()。",
    "options": ["A) 硬布线控制器的时序系统比较简单", "B) 微程序控制器的时序系统比较简单", "C) 两者的时序系统复杂程度相同", "D) 可能是硬布线控制器的时序系统比较简单，也可能是微程序控制器的时序系统比较简单"],
    "answer": "C"
  },
  {
    "id": 64,
    "question": "在微程序控制器中，控制部件向执行部件发出的某个控制信号称为()。",
    "options": ["A) 微程序", "B) 微指令", "C) 微操作", "D) 微命令"],
    "answer": "C"
  },
  {
    "id": 65,
    "question": "在微程序控制器中，机器指令与微指令的关系是()。",
    "options": ["A) 每条机器指令由一条微指令来执行", "B) 每条机器指令由若干微指令组成的微程序来解释执行", "C) 若干机器指令组成的程序可由一个微程序来执行", "D) 每条机器指令由若干微程序执行"],
    "answer": "C"
  },
  {
    "id": 66,
    "question": "水平型微指令与垂直型微指令相比，()。",
    "options": ["A) 前者一次只能完成一个基本操作", "B) 后者一次只能完成一个基本操作", "C) 两者都是一次只能完成一个基本操作", "D) 两者都能一次完成多个基本操作"],
    "answer": "C"
  },
  {
    "id": 67,
    "question": "垂直型微指令的特点是()。",
    "options": ["A) 控制信号经过编码产生", "B) 强调并行控制功能", "C) 采用微操作码", "D) 指令格式垂直表示"],
    "answer": "C"
  },
  {
    "id": 68,
    "question": "下列关于微命令的描述中，正确的是()。",
    "options": ["A) 同一CPU周期中，可以同时出现的微命令叫相容性微命令", "B) 同一CPU周期中，可以同时出现的微命令叫互斥性微命令", "C) 在执行过程中可能会引起总线冲突的微命令叫互斥性微命令", "D) 同一CPU周期中，不允许同时出现的微命令叫相容性微命令"],
    "answer": "C"
  },
  {
    "id": 69,
    "question": "在微程序控制方式中，以下说法正确的是()。",
    "options": ["A) 采用微程序控制器的处理器称为微处理器", "B) 每条机器指令由一段微程序来解释执行", "C) 在微指令的编码中，效率最低的是直接编码方式", "D) 水平型微指令能充分利用数据通路的并行结构"],
    "answer": "C"
  },
  {
    "id": 70,
    "question": "下列说法中，正确的是()。",
    "options": ["A) 微程序控制方式和硬布线方式相比较，前者可以使指令的执行速度更快", "B) 若采用微程序控制方式，则可用μPC取代PC", "C) 控制存储器可以用ROM实现", "D) 指令周期也称CPU周期"],
    "answer": "C"
  },
  {
    "id": 71,
    "question": "通常一条指令对应一个微程序，一个微程序的周期对应一个()。",
    "options": ["A) 指令周期", "B) 主频周期", "C) 机器周期", "D) 工作周期"],
    "answer": "C"
  },
  {
    "id": 72,
    "question": "下列部件中属于控制部件的是()。",
    "options": ["A) 指令寄存器、操作控制器、程序计数器", "B) 指令寄存器、程序计数器、状态条件寄存器", "C) 指令寄存器、操作控制器、状态条件寄存器", "D) 指令寄存器、操作控制器、程序计数器、状态条件寄存器"],
    "answer": "C"
  },
  {
    "id": 73,
    "question": "为了确定下一条微指令的地址，通常采用断定方式，其基本思想是()。",
    "options": ["A) 用程序计数器(PC)来产生后继微指令地址", "B) 用微程序计数器(μPC)来产生后继微指令地址", "C) 通过微指令的后继地址字段由设计者指定或转移控制字段控制产生后继微指令地址", "D) 通过指令中指定一个专门字段来控制产生后继微指令地址"],
    "answer": "C"
  },
  {
    "id": 74,
    "question": "【2009统考真题】相对于微程序控制器，硬布线控制器的特点是()。",
    "options": ["A) 指令执行速度慢，指令功能的修改和扩展容易", "B) 指令执行速度慢，指令功能的修改和扩展难", "C) 指令执行速度快，指令功能的修改和扩展容易", "D) 指令执行速度快，指令功能的修改和扩展难"],
    "answer": "C"
  },
  {
    "id": 75,
    "question": "【2012统考真题】某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有()。",
    "options": ["A) 5位", "B) 6位", "C) 15位", "D) 33位"],
    "answer": "C"
  },
  {
    "id": 76,
    "question": "【2014统考真题】某计算机采用微程序控制器，共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定法（后继地址字段法）确定下条微指令地址，则微指令中后继地址字段的位数至少是()。",
    "options": ["A) 5", "B) 6", "C) 8", "D) 9"],
    "answer": "C"
  },
  {
    "id": 77,
    "question": "【2017统考真题】下列关于主存储器(MM)和控制存储器(CS)的叙述，错误的是()。",
    "options": ["A) MM在CPU外，CS在CPU内", "B) MM按地址访问，CS按内容访问", "C) MM存储指令和数据，CS存储微指令", "D) MM用RAM和ROM实现，CS用ROM实现"],
    "answer": "C"
  },
  {
    "id": 78,
    "question": "【2019统考真题】下列有关处理器时钟脉冲信号的叙述中，错误的是()。",
    "options": ["A) 时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成", "B) 时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频", "C) 时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定", "D) 处理器总是在每来一个时钟脉冲信号时就开始执行一条新的指令"],
    "answer": "C"
  },
  {
    "id": 79,
    "question": "【2019统考真题】某指令的功能为R[r2]←R[r1]+M[R[r0]]，其两个源操作数分别采用寄存器、寄存器间接寻址方式，对于下列给定部件，该指令在取数及执行过程中需要用到的是()。",
    "options": ["A) 仅I、Ⅱ", "B) 仅I、Ⅱ、Ⅲ", "C) 仅Ⅱ、Ⅲ、Ⅳ", "D) 仅I、Ⅱ、Ⅳ"],
    "answer": "C"
  },
  {
    "id": 80,
    "question": "【2021统考真题】下列寄存器中，汇编语言程序员可见的是()。",
    "options": ["A) 仅I、Ⅱ", "B) 仅I、Ⅳ", "C) 仅Ⅲ、Ⅳ", "D) 仅Ⅲ、Ⅳ"],
    "answer": "C"
  },
  {
    "id": 81,
    "question": "以下关于“自陷”（Trap）异常的叙述中，错误的是()。",
    "options": ["A) “自陷”是人为预先设定的一种特定处理事件", "B) 可由访管指令或自陷指令的执行进入“自陷”", "C) 一定是出现某种异常情况才会发生“自陷”", "D) “自陷”发生后CPU将进入操作系统内核程序并执行"],
    "answer": "C"
  },
  {
    "id": 82,
    "question": "指令执行结果出现异常而引起的中断是()。",
    "options": ["A) I/O中断", "B) 机器校验中断", "C) 故障", "D) 外部中断"],
    "answer": "C"
  },
  {
    "id": 83,
    "question": "访问主存时发生的校验错误属于()。",
    "options": ["A) 故障", "B) 自陷", "C) 终止", "D) 外中断"],
    "answer": "C"
  },
  {
    "id": 84,
    "question": "下列关于异常和中断响应的叙述中，错误的是()。",
    "options": ["A) 异常事件检测由CPU在执行每一条指令的过程中进行", "B) 中断请求检测由CPU在每条指令执行结束、取下条指令之前进行", "C) CPU检测到异常事件后所做的处理和检测到中断请求后所做的处理完全相同", "D) CPU在中断响应时会关中断、保存断点和程序状态并转到相应的中断服务程序"],
    "answer": "C"
  },
  {
    "id": 85,
    "question": "以下给出的事件中，无须异常处理程序进行处理的是()。",
    "options": ["A) 缺页故障", "B) Cache缺失", "C) 地址越界", "D) 除数为0"],
    "answer": "C"
  },
  {
    "id": 86,
    "question": "CPU响应中断的时间是()。",
    "options": ["A) 一条指令执行结束", "B) I/O设备提出中断", "C) 取指周期结束", "D) 指令周期结束"],
    "answer": "C"
  },
  {
    "id": 87,
    "question": "下列选项中，不属于外部中断事件的是()。",
    "options": ["A) 采样定时到", "B) 无效操作码", "C) 打印机缺纸", "D) 键盘缓冲满"],
    "answer": "C"
  },
  {
    "id": 88,
    "question": "下列关于异常/中断机制与进程上下文切换机制的叙述中，错误的是()。",
    "options": ["A) 进程上下文切换和异常/中断响应两者都会产生异常控制流", "B) 进程上下文切换后，CPU执行的是另一个进程的代码", "C) 响应异常/中断请求后，CPU执行的是内核程序的代码", "D) 进程上下文切换和异常/中断响应处理都通过执行内核程序实现"],
    "answer": "C"
  },
  {
    "id": 89,
    "question": "异常或中断处理结束后，返回到被中断原程序继续执行的指令地址称为“断点”，以下关于“断点”的说法中，错误的是()。",
    "options": ["A) “陷阱”类异常的断点为陷阱指令下一条指令的地址", "B) “故障”类异常的断点为当前发生异常的指令的地址", "C) 外部中断的断点总是当前刚执行完的指令的地址", "D) “终止”类异常的断点可以是当前指令或下一条指令的地址"],
    "answer": "C"
  },
  {
    "id": 90,
    "question": "【2015统考真题】内部异常（内中断）可分为故障(fault)、陷阱(trap)和终止(abort)三类。下列有关内部异常的叙述中，错误的是()。",
    "options": ["A) 内部异常的产生与当前执行指令相关", "B) 内部异常的检测由CPU内部逻辑实现", "C) 内部异常的响应发生在指令执行过程中", "D) 内部异常处理后返回到发生异常的指令继续执行"],
    "answer": "C"
  },
  {
    "id": 91,
    "question": "【2016统考真题】异常是指令执行过程中在处理器内部发生的特殊事件，中断是来自处理器外部的请求事件。下列关于中断或异常情况的叙述中，错误的是()。",
    "options": [
      "A) “访存时缺页”属于中断",
      "B) “整数除以0”属于异常",
      "C) “DMA传送结束”属于中断",
      "D) “存储保护错”属于异常"
    ],
    "answer": "C"
  },
  {
    "id": 92,
    "question": "下列关于“自陷”（Trap，也称陷阱）的叙述中，错误的是()。",
    "options": [
      "A) 自陷是通过陷阱指令预先设定的一类外部中断事件",
      "B) 自陷可用于实现程序调试时的断点设置和单步跟踪",
      "C) 自陷发生后CPU将转去执行操作系统内核相应程序",
      "D) 自陷处理完成后返回到陷阱指令的下一条指令执行"
    ],
    "answer": "C"
  },
  {
    "id": 93,
    "question": "【2021统考真题】异常事件在当前指令执行过程中进行检测，中断请求则在当前指令执行后进行检测。下列事件中，相应处理程序执行后，必须回到当前指令重新执行的是()。",
    "options": [
      "A) 系统调用",
      "B) 页缺失",
      "C) DMA传送结束",
      "D) 打印机缺纸"
    ],
    "answer": "C"
  },
  {
    "id": 94,
    "question": "下列关于流水CPU基本概念的描述中，正确的是()。",
    "options": [
      "A) 流水CPU是以空间并行性为原理构造的处理器",
      "B) 流水CPU一定是RISC机器",
      "C) 流水CPU一定是多媒体CPU",
      "D) 流水CPU是一种非常经济而实用的时间并行技术"
    ],
    "answer": "C"
  },
  {
    "id": 95,
    "question": "流水CPU是由一系列称为“段”的处理电路组成的。一个m段流水线稳定时的CPU的吞吐能力，与m个并行部件的CPU的吞吐能力相比，()。",
    "options": [
      "A) 具有同等水平的吞吐能力",
      "B) 不具备同等水平的吞吐能力",
      "C) 吞吐能力大于前者的吞吐能力",
      "D) 吞吐能力小于前者的吞吐能力"
    ],
    "answer": "C"
  },
  {
    "id": 96,
    "question": "设指令由取指、分析、执行3个子部件完成，并且每个子部件的时间均为t，若采用常规标量单流水线处理机（即处理机的度为1），连续执行12条指令，共需()。",
    "options": [
      "A) 12t",
      "B) 14t",
      "C) 16t",
      "D) 18t"
    ],
    "answer": "C"
  },
  {
    "id": 97,
    "question": "设指令由取指、分析、执行3个子部件完成，并且每个子部件的时间均为t，若采用度为4的超标量流水线处理机，连续执行20条指令，只需()。",
    "options": [
      "A) 6t",
      "B) 7t",
      "C) 8t",
      "D) 9t"
    ],
    "answer": "C"
  },
  {
    "id": 98,
    "question": "设指令流水线把一条指令分为取指、分析、执行3部分，3部分执行时间不等长，且3部分的时间分别是取指=2ns，分析=2ns，执行=1ns，则100条指令全部执行完毕需()。",
    "options": [
      "A) 163ns",
      "B) 183ns",
      "C) 203ns",
      "D) 223ns"
    ],
    "answer": "C"
  },
  {
    "id": 99,
    "question": "下列关于指令流水线设计的叙述中，错误的是()。",
    "options": [
      "A) 指令执行过程中的各个子功能都需要包含在某个流水段中",
      "B) 所有子功能都必须按一定的顺序经过流水段",
      "C) 虽然各子功能所用实际时间可能不同，但经过每个流水段的时间都一样",
      "D) 任何时候各个流水段的功能部件都不可能执行空操作"
    ],
    "answer": "C"
  },
  {
    "id": 100,
    "question": "下列关于流水段寄存器的叙述中，正确的是()。",
    "options": [
      "A) 指令译码得到的控制信号需通过流水段寄存器传递到下一个流水段",
      "B) 每个流水段之间的流水段寄存器位数一定相同",
      "C) 每个流水段之间的流水段寄存器存放的信息一定相同",
      "D) 用户程序可以通过指令指定访问哪个流水段寄存器"
    ],
    "answer": "C"
  },
  {
    "id": 101,
    "question": "下列关于流水线数据通路的描述中，错误的是()。",
    "options": [
      "A) 每个流水段由执行指令子功能的功能部件和流水段寄存器组成",
      "B) 控制信号仅作用在功能部件上，时钟信号仅作用在流水段寄存器上",
      "C) 在没有阻塞的情况下，PC的值在每个时钟周期都会改变",
      "D) 取指令阶段和指令译码阶段不需要控制信号的控制"
    ],
    "answer": "C"
  },
  {
    "id": 102,
    "question": "下列关于结构冒险的叙述中，正确的是()。",
    "options": [
      "A) 结构冒险是指同时有多条指令使用同一个资源",
      "B) 避免结构冒险的基本做法是使每个指令在相同流水段中使用相同的部件",
      "C) 重复设置功能部件可以避免结构冒险",
      "D) 数据Cache和指令Cache分离可解决两条指令同时分别取数据和取指令的冒险"
    ],
    "answer": "C"
  },
  {
    "id": 103,
    "question": "指令流水线中出现数据相关时流水线将受阻，()可解决数据相关问题。",
    "options": [
      "A) 增加硬件资源",
      "B) 采用旁路技术",
      "C) 采用分支预测技术",
      "D) 以上都可以"
    ],
    "answer": "C"
  },
  {
    "id": 104,
    "question": "下列关于数据冒险和转发技术的叙述中，正确的是()。",
    "options": [
      "A) 并非所有数据冒险都能通过转发技术解决",
      "B) 五段流水线中load-use数据冒险会引起至少一个时钟周期的阻塞",
      "C) 前面的分支指令和后面的ALU运算指令之间肯定不会发生数据冒险",
      "D) 以上说法都正确"
    ],
    "answer": "C"
  },
  {
    "id": 105,
    "question": "下列关于数据冒险的叙述中，正确的是()。",
    "options": [
      "A) 数据冒险是指后面指令用到的数据还未来得及由前面的指令产生",
      "B) 在发生数据冒险的指令之间插入空操作指令能避免数据冒险",
      "C) 采用转发（旁路）技术可以解决一部分数据冒险现象",
      "D) 通过编译器调整指令顺序可解决部分数据冒险"
    ],
    "answer": "C"
  },
  {
    "id": 106,
    "question": "下列指令序列中，指令I1和I3、I2和I3之间发生数据相关。假定采用“取指、译码/取数、执行、访存、写回”五段流水线方式，那么采用转发技术时，需要在指令I3之前加入()条空操作指令才能使这段程序不发生数据冒险。\n\nI1: add r1, r0, 1\nI2: load r3, 12(r2)\nI3: add r5, r3, r1",
    "options": [
      "A) 3",
      "B) 2",
      "C) 1",
      "D) 0"
    ],
    "answer": "C"
  },
  {
    "id": 107,
    "question": "下面有关控制冒险的描述中，错误的是()。",
    "options": [
      "A) 无条件转移指令不会发生控制冒险",
      "B) 在分支指令加入若干空操作可以避免控制冒险",
      "C) 采用转发（旁路）技术，可以解决部分控制冒险",
      "D) 流水段的数量与控制冒险引发的开销无关"
    ],
    "answer": "C"
  },
  {
    "id": 108,
    "question": "下列关于分支预测的叙述中，正确的是()。",
    "options": [
      "A) 分支预测技术可用于处理控制冒险和数据冒险",
      "B) 使用静态预测技术时，每次的预测结果是一样的",
      "C) 动态预测技术通常比静态预测技术的预测成功率高",
      "D) 若预测错误，已被错误放入流水线执行的指令必须被舍弃"
    ],
    "answer": "C"
  },
  {
    "id": 109,
    "question": "下列关于指令流水线和指令执行效率的叙述中，错误的是()。",
    "options": [
      "A) 加倍增加流水段个数不能成倍提高指令执行效率",
      "B) 为了提高指令吞吐率，流水段个数应无限制地增加",
      "C) 增加流水段个数，可以提高处理器的时钟频率",
      "D) 随着流水段个数的增加，流水段之间缓存开销的比例增大"
    ],
    "answer": "C"
  },
  {
    "id": 110,
    "question": "设指令由取指、分析、执行三个子部件完成，并且每个子部件的时间均为t，若采用常规标量单流水线处理机，连续执行8条指令，则该流水线的加速比为()。",
    "options": [
      "A) 3",
      "B) 4",
      "C) 5",
      "D) 6"
    ],
    "answer": "C"
  },
{
    "id": 111,
    "question": "下列关于超标量流水线的描述中，不正确的是()。",
    "options": [
      "A) 在一个时钟周期内一条流水线可执行一条以上的指令",
      "B) 一条指令分为多段指令由不同电路单元完成",
      "C) 超标量通过内置多条流水线来同时执行多个处理器，其实质是以空间换取时间",
      "D) 超标量流水线仅仅是指运算操作并行"
    ],
    "answer": "C"
  },
  {
    "id": 112,
    "question": "关于流水线技术的说法中，错误的是()。",
    "options": [
      "A) 超标量技术需要配置多个功能部件和指令译码电路等",
      "B) 与超标量技术和超流水线技术相比，超长指令字技术对优化编译器要求更高，而无其他硬件要求",
      "C) 在按序流动的流水线中，只可能出现RAW相关",
      "D) 超流水线技术相当于将流水线再分段，从而提高每个周期内功能部件的使用次数"
    ],
    "answer": "C"
  },
  {
    "id": 113,
    "question": "【2009统考真题】某计算机的指令流水线由4个功能段组成，指令流经各功能段的时间（忽略各功能段之间的缓存时间）分别为90ns、80ns、70ns和60ns，则该计算机的CPU周期至少是()。",
    "options": [
      "A) 90ns",
      "B) 80ns",
      "C) 70ns",
      "D) 60ns"
    ],
    "answer": "C"
  },
  {
    "id": 114,
    "question": "【2010统考真题】下列不会引起指令流水线阻塞的是()。",
    "options": [
      "A) 数据旁路",
      "B) 数据相关",
      "C) 条件转移",
      "D) 资源冲突"
    ],
    "answer": "C"
  },
  {
    "id": 115,
    "question": "【2011统考真题】下列指令系统的特点中，有利于实现指令流水线的是()。\nI. 指令格式规整且长度一致\nII. 指令和数据按边界对齐存放\nIII. 只有LOAD/STORE指令才能对操作数进行存储访问",
    "options": [
      "A) 仅I、II",
      "B) 仅II、III",
      "C) 仅I、III",
      "D) I、II、III"
    ],
    "answer": "C"
  },
  {
    "id": 116,
    "question": "【2013统考真题】某CPU主频为1.03GHz，采用4级指令流水线，每个流水段的执行需要1个时钟周期。假定CPU执行了100条指令，在其执行过程中，没有发生任何流水线阻塞，则流水线的吞吐率为()。",
    "options": [
      "A) 0.25×10⁹条指令/秒",
      "B) 0.97×10⁹条指令/秒",
      "C) 1.0×10⁹条指令/秒",
      "D) 1.03×10⁹条指令/秒"
    ],
    "answer": "C"
  },
  {
    "id": 117,
    "question": "【2014统考真题】采用指令Cache与数据Cache分离的主要目的是()。",
    "options": [
      "A) 降低Cache的缺失损失",
      "B) 提高Cache的命中率",
      "C) 降低CPU平均访存时间",
      "D) 减少指令流水线资源冲突"
    ],
    "answer": "C"
  },
  {
    "id": 118,
    "question": "【2016统考真题】在无转发机制的五段基本流水线（取指、译码/读寄存器、运算、访存、写回寄存器）中，下列指令序列存在数据冒险的指令对是()。\n\nI1: add R1, R2, R3\nI2: add R5, R2, R4\nI3: add R4, R5, R3\nI4: add R5, R2, R6",
    "options": [
      "A) I1和I2",
      "B) I2和I3",
      "C) I2和I4",
      "D) I3和I4"
    ],
    "answer": "C"
  },
  {
    "id": 119,
    "question": "【2017统考真题】下列关于超标量流水线特性的叙述中，正确的是()。\nI. 能缩短流水线功能段的处理时间\nII. 能在一个时钟周期内同时发射多条指令\nIII. 能结合动态调度技术提高指令执行并行性",
    "options": [
      "A) 仅II",
      "B) 仅I、III",
      "C) 仅II、III",
      "D) I、II、III"
    ],
    "answer": "C"
  },
  {
    "id": 120,
    "question": "【2017统考真题】下列关于指令流水线数据通路的叙述中，错误的是()。",
    "options": [
      "A) 包含生成控制信号的控制部件",
      "B) 包含算术逻辑运算部件(ALU)",
      "C) 包含通用寄存器组和取指部件",
      "D) 由组合逻辑电路和时序逻辑电路组合而成"
    ],
    "answer": "C"
  },
  {
    "id": 121,
    "question": "【2018统考真题】若某计算机最复杂指令的执行需要完成5个子功能，分别由功能部件A～E实现，各功能部件所需时间分别为80ps、50ps、50ps、70ps和50ps，采用流水线方式执行指令，流水段寄存器延时为20ps，则CPU时钟周期至少为()。",
    "options": [
      "A) 60ps",
      "B) 70ps",
      "C) 80ps",
      "D) 100ps"
    ],
    "answer": "C"
  },
  {
    "id": 122,
    "question": "【2019统考真题】在采用“取指、译码/取数、执行、访存、写回”5段流水线的处理器中，执行如下指令序列，其中s0、s1、s2、s3和t2表示寄存器编号。\n\nI1: add s2, s1, s0\nI2: load s3, 0(t2)\nI3: add s2, s2, s3\nI4: store s2, 0(t2)\n\n下列指令对中，不存在数据冒险的是()。",
    "options": [
      "A) I1和I3",
      "B) I2和I3",
      "C) I2和I4",
      "D) I3和I4"
    ],
    "answer": "C"
  },
  {
    "id": 123,
    "question": "【2020统考真题】下列给出的处理器类型中，理想情况下，CPI为1的是()。\nI. 单周期CPU\nII. 多周期CPU\nIII. 基本流水线CPU\nIV. 超标量流水线CPU",
    "options": [
      "A) 仅I、II",
      "B) 仅I、III",
      "C) 仅II、IV",
      "D) 仅III、IV"
    ],
    "answer": "C"
  },
  {
    "id": 124,
    "question": "【2023统考真题】在采用“取指、译码/取数、执行、访存、写回”5段流水线的RISC处理器中，执行如下指令序列（第一列为指令序号），其中s0、s1、s2、s3和t2表示寄存器编号。\n\nI1: add s2, s1, s0\nI2: load s3, 0(s2)\nI3: beq t2, s3, L1\nI4: addi t2, t2, 20\nI5: L1: ...\n\n若采用转发（旁路）技术处理数据冒险，采用硬件阻塞方式处理控制冒险，则在指令I1～I4的执行过程中，发生流水线阻塞的指令有()。",
    "options": [
      "A) 仅I3",
      "B) 仅I2、I4",
      "C) 仅I3、I4",
      "D) 仅I2、I3、I4"
    ],
    "answer": "C"
  },
  {
    "id": 125,
    "question": "按照Flynn提出的计算机系统分类方法，多处理机属于()。",
    "options": [
      "A) SISD",
      "B) SIMD",
      "C) MISD",
      "D) MIMD"
    ],
    "answer": "C"
  },
  {
    "id": 126,
    "question": "从体系结构的角度来看，阵列处理机属于()结构。",
    "options": [
      "A) SISD",
      "B) SIMD",
      "C) MIMD",
      "D) MISD"
    ],
    "answer": "C"
  },
  {
    "id": 127,
    "question": "以下机器中，不属于SIMD结构的是()。",
    "options": [
      "A) 并行处理机",
      "B) 阵列处理机",
      "C) 向量处理机",
      "D) 标量流水线处理机"
    ],
    "answer": "C"
  },
  {
    "id": 128,
    "question": "具有一个控制部件和多个处理单元的计算机系统属于()结构。",
    "options": [
      "A) SISD",
      "B) SIMD",
      "C) MISD",
      "D) MIMD"
    ],
    "answer": "C"
  },
  {
    "id": 129,
    "question": "下列关于超线程（HT）技术的描述中，正确的是()。",
    "options": [
      "A) 超线程技术可以让四核的Intel Core i7处理器变成八核",
      "B) 超线程是一项硬件技术，能使系统性能大幅提升，与操作系统和应用软件无关",
      "C) 含有超线程技术的CPU需要芯片组的支持才能发挥技术优势",
      "D) 超线程模拟出的每个CPU核都具有独立的资源，各自工作互不干扰"
    ],
    "answer": "C"
  },
  {
    "id": 130,
    "question": "双核CPU和超线程CPU的共同点是()。",
    "options": [
      "A) 都有两个内核",
      "B) 都能同时执行两个运算",
      "C) 都包含两个CPU",
      "D) 都不会出现争抢资源的现象"
    ],
    "answer": "C"
  },
  {
    "id": 131,
    "question": "下列关于双核技术的叙述中，正确的是()。",
    "options": [
      "A) 双核是指主板上有两个CPU",
      "B) 双核是利用超线程技术实现的",
      "C) 双核是指在CPU上集成两个运算核心",
      "D) 双核CPU是时间并行的并行计算"
    ],
    "answer": "C"
  },
  {
    "id": 132,
    "question": "下列有关多核CPU和单核CPU的描述中，错误的是()。",
    "options": [
      "A) 双核的频率为2.4GHz，那么其中每个核心的频率也是2.4GHz",
      "B) 采用双核CPU可以降低计算机系统的功耗和体积",
      "C) 多核CPU共用一组内存，数据共享",
      "D) 所有程序在多核CPU上运行速度都快"
    ],
    "answer": "C"
  },
  {
    "id": 133,
    "question": "下列关于多核CPU的描述中，正确的是()。",
    "options": [
      "A) 各核心完全对称，拥有各自的Cache",
      "B) 任何程序都可以同时在多个核心上运行",
      "C) 一颗CPU中集成了多个完整的执行内核，可同时进行多个运算",
      "D) 只有使用了多核CPU的计算机，才支持多任务操作系统"
    ],
    "answer": "C"
  },
  {
    "id": 134,
    "question": "下列关于多处理器的说法中，正确的是()。\nI. 通常采用偶数路CPU，如2路、4路、6路等\nII. NUMA架构比UMA架构的运算扩展性要强\nIII. UMA架构需要解决的重要问题是Cache一致性",
    "options": [
      "A) I、II",
      "B) II、III",
      "C) I、III",
      "D) I、II、III"
    ],
    "answer": "C"
  },
  {
    "id": 135,
    "question": "下列关于多核处理器的说法中，不正确的是()。",
    "options": [
      "A) 多核处理器并不能使单线程程序的执行速度加快",
      "B) 多核处理器在Flynn分类法中属于MIMD系统",
      "C) 多核处理器实际上就是在一个CPU上集成了多个控制核心",
      "D) 多核处理器通常比单核处理器的能耗更高"
    ],
    "answer": "C"
  },
  {
    "id": 136,
    "question": "下列关于并行处理技术的叙述中，不正确的是()。",
    "options": [
      "A) 多核处理器属于MIMD结构",
      "B) 向量处理器属于SIMD结构",
      "C) 硬件多线程技术只可用于多核处理器",
      "D) SMP中所有处理器共享单一物理地址空间"
    ],
    "answer": "C"
  },
  {
    "id": 137,
    "question": "下列关于指令周期的叙述中，错误的是()。",
    "options": [
      "A) 指令周期的第一个阶段一定是取指令阶段",
      "B) 乘法指令和加法指令的指令周期总是一样长",
      "C) 一个指令周期可由若干时钟周期组成",
      "D) 单周期CPU中的指令周期就是一个时钟周期"
    ],
    "answer": "C"
  },
  {
    "id": 138,
    "question": "下列关于CPU时钟信号的叙述中，错误的是()。",
    "options": [
      "A) 处理器总是每来一个时钟信号就开始执行一条新的指令",
      "B) 边沿触发指状态单元总在时钟上升沿或下降沿开始改变状态",
      "C) 时钟周期以相邻状态单元之间最长组合逻辑延迟为基准确定",
      "D) 每个时钟周期称为一个节拍，机器的主频就是时钟周期的倒数"
    ],
    "answer": "C"
  },
  {
    "id": 139,
    "question": "数据通路是由操作元件和状态元件通过总线或分散方式连接而成的进行数据存储、处理和传送的路径，下列部件中属于状态元件的是()。\nI. 算术逻辑部件\nII. 译码器\nIII. 移位寄存器\nIV. 存储器数据寄存器",
    "options": [
      "A) I、III",
      "B) II、III、IV",
      "C) III、IV",
      "D) I、IV"
    ],
    "answer": "C"
  },
  {
    "id": 140,
    "question": "假设计算机A要求应用在实时性要求较高的场合，计算机B要求有较好的灵活性和可修改性，则两台计算机的控制器应采用的设计方式分别是()。",
    "options": [
      "A) 计算机A和B都采用硬布线控制器",
      "B) 计算机A和B都采用微程序控制器",
      "C) 计算机A应采用硬布线控制器，计算机B应采用微程序控制器",
      "D) 计算机A应采用微程序控制器，计算机B应采用硬布线控制器"
    ],
    "answer": "C"
  },
  {
    "id": 141,
    "question": "【2024统考真题】对于采用“取指、译码/取数、执行、访存、写回”5段流水线的RISC数据通路，下列关于指令流水线数据冒险处理的叙述中，错误的是()。",
    "options": [
      "A) 相邻两条指令中的操作数相关可能引起数据冒险",
      "B) 在数据相关的指令间插入“气泡”能避免数据冒险",
      "C) 所有数据冒险都可以通过加入转发（旁路）电路解决",
      "D) 所有数据冒险都能通过调整指令顺序和插入nop指令解决"
    ],
    "answer": "C"
  }
]


,
          chapter6: [
    {
        "id": 1,
        "question": "挂接在总线上的多个部件（ ）。",
        "options": [
            "A) 只能分时向总线发送数据，并只能分时从总线接收数据",
            "B) 只能分时向总线发送数据，但可同时从总线接收数据",
            "C) 可同时向总线发送数据，并同时从总线接收数据",
            "D) 可同时向总线发送数据，但只能分时从总线接收数据"
        ],
        "answer": "C"
    },
    {
        "id": 2,
        "question": "在总线上，同一时刻（ ）。",
        "options": [
            "A) 只能有一个主设备控制总线传输操作",
            "B) 只能有一个从设备控制总线传输操作",
            "C) 只能有一个主设备和一个从设备控制总线传输操作",
            "D) 可以有多个主设备控制总线传输操作"
        ],
        "answer": "C"
    },
    {
        "id": 3,
        "question": "在计算机系统中，多个系统部件之间信息传送的公共通路称为总线，就其所传送的信息的性质而言，下列（ ）不是在公共通路上传送的信息。",
        "options": [
            "A) 数据信息",
            "B) 地址信息",
            "C) 系统信息",
            "D) 控制信息"
        ],
        "answer": "C"
    },
    {
        "id": 4,
        "question": "系统总线用来连接（ ）。",
        "options": [
            "A) 寄存器和运算器部件",
            "B) 运算器和控制器部件",
            "C) CPU、主存和外设部件",
            "D) 接口和外部设备"
        ],
        "answer": "C"
    },
    {
        "id": 5,
        "question": "计算机使用总线结构便于增减外设，同时（ ）。",
        "options": [
            "A) 减少信息传输量",
            "B) 提高信息的传输速度",
            "C) 减少信息传输线的条数",
            "D) 提高信息传输的并行性"
        ],
        "answer": "C"
    },
    {
        "id": 6,
        "question": "间址寻址第一次访问内存所得到的信息经系统总线的（ ）传送到CPU。",
        "options": [
            "A) 数据总线",
            "B) 地址总线",
            "C) 控制总线",
            "D) 总线控制器"
        ],
        "answer": "A"
    },
    {
        "id": 7,
        "question": "系统总线中地址线的功能是（ ）。",
        "options": [
            "A) 选择主存单元地址",
            "B) 选择进行信息传输的设备",
            "C) 选择外存地址",
            "D) 指定主存和I/O设备接口电路的地址"
        ],
        "answer": "D"
    },
    {
        "id": 8,
        "question": "系统总线中控制线的主要功能是（ ）。",
        "options": [
            "A) 提供时序信号",
            "B) 提供主存和I/O模块的回答信号",
            "C) 提供定时信号、操作命令和各种请求/回答信号等",
            "D) 提供数据信息"
        ],
        "answer": "C"
    },
    {
        "id": 9,
        "question": "在单机系统中，三总线结构计算机的总线系统组成是（ ）。",
        "options": [
            "A) 片内总线、系统总线和通信总线",
            "B) 数据总线、地址总线和控制总线",
            "C) DMA总线、主存总线和I/O总线",
            "D) ISA总线、VESA总线和PCI总线"
        ],
        "answer": "C"
    },
    {
        "id": 10,
        "question": "不同信号在同一条信号线上分时传输的方式称为（ ）。",
        "options": [
            "A) 总线复用方式",
            "B) 并串行传输方式",
            "C) 并行传输方式",
            "D) 串行传输方式"
        ],
        "answer": "A"
    },
    {
        "id": 11,
        "question": "主存通过（ ）来识别信息是地址还是数据。",
        "options": [
            "A) 总线的类型",
            "B) 存储器数据寄存器(MDR)",
            "C) 存储器地址寄存器(MAR)",
            "D) 控制单元(CU)"
        ],
        "answer": "C"
    },
    {
        "id": 12,
        "question": "在32位总线系统中，若时钟频率为500MHz，传送一个32位字需要5个时钟周期，则该总线的数据传输速率是（ ）。",
        "options": [
            "A) 200MB/s",
            "B) 400MB/s",
            "C) 600MB/s",
            "D) 800MB/s"
        ],
        "answer": "B"
    },
    {
        "id": 13,
        "question": "传输一幅分辨率为640×480像素、颜色数量为65536的照片（采用无压缩方式），假设有效数据的传输速率为56kb/s，则大约需要的时间是（ ）。",
        "options": [
            "A) 34.82s",
            "B) 43.86s",
            "C) 85.71s",
            "D) 87.77s"
        ],
        "answer": "C"
    },
    {
        "id": 14,
        "question": "某总线有104根信号线，其中数据线(DB)为32根，若总线工作频率为33MHz，则其理论最大传输速率为（ ）。",
        "options": [
            "A) 33MB/s",
            "B) 64MB/s",
            "C) 132MB/s",
            "D) 164MB/s"
        ],
        "answer": "C"
    },
    {
        "id": 15,
        "question": "在一个16位的总线系统中，若时钟频率为100MHz，总线周期为5个时钟周期传输一个字，则总线带宽是（ ）。",
        "options": [
            "A) 4MB/s",
            "B) 40MB/s",
            "C) 16MB/s",
            "D) 64MB/s"
        ],
        "answer": "B"
    },
    {
        "id": 16,
        "question": "微机中控制总线上完整传输的信号有（ ）。",
        "options": [
            "A) 仅I",
            "B) Ⅱ和Ⅲ",
            "C) 仅Ⅱ",
            "D) Ⅰ、Ⅱ和Ⅲ"
        ],
        "answer": "C"
    },
    {
        "id": 17,
        "question": "下列信号中，可在系统总线中的控制总线上传输的有（ ）。",
        "options": [
            "A) Ⅰ和Ⅳ",
            "B) Ⅱ和Ⅲ",
            "C) Ⅰ、Ⅱ和Ⅲ",
            "D) Ⅱ、Ⅲ和Ⅳ"
        ],
        "answer": "B"
    },
    {
        "id": 18,
        "question": "总线中，有些信息是单向传输的，有些信息是双向传输的，下列说法中正确的是（ ）。",
        "options": [
            "A) 数据信息是单向传输的，由内存或外设传送至CPU",
            "B) 地址信息是单向传输的，由CPU发送至内存或外设",
            "C) 控制信息是双向传输的，由CPU发送至内存或外设，也可反向",
            "D) 状态信息是双向传输的，由CPU发送至内存或外设，也可反向"
        ],
        "answer": "B"
    },
    {
        "id": 19,
        "question": "按连接部件不同，总线通常可以分为以下哪几种？（ ）",
        "options": [
            "A) Ⅰ、Ⅱ和Ⅲ",
            "B) Ⅰ、Ⅲ和Ⅳ",
            "C) Ⅰ、Ⅱ和Ⅳ",
            "D) Ⅱ、Ⅲ和Ⅳ"
        ],
        "answer": "C"
    },
    {
        "id": 20,
        "question": "假设某系统总线在一个总线周期中并行传输4字节信息，一个总线周期占用2个时钟周期，总线时钟频率为10MHz，则总线带宽是（ ）。",
        "options": [
            "A) 10MB/s",
            "B) 20MB/s",
            "C) 40MB/s",
            "D) 80MB/s"
        ],
        "answer": "B"
    },
    {
        "id": 21,
        "question": "下列选项中的英文缩写均为总线标准的是（ ）。",
        "options": [
            "A) PCI、CRT、USB、EISA",
            "B) ISA、CPI、VESA、EISA",
            "C) ISA、SCSI、RAM、MIPS",
            "D) ISA、EISA、PCI、PCI-Express"
        ],
        "answer": "D"
    },
    {
        "id": 22,
        "question": "在系统总线的数据线上，不可能传输的是（ ）。",
        "options": [
            "A) 指令",
            "B) 操作数",
            "C) 握手（应答）信号",
            "D) 中断类型号"
        ],
        "answer": "C"
    },
    {
        "id": 23,
        "question": "下列关于USB总线特性的描述中，错误的是（ ）。",
        "options": [
            "A) 可实现外设的即插即用和热拔插",
            "B) 可通过级联方式连接多台外设",
            "C) 是一种通信总线，连接不同外设",
            "D) 同时可传输2位数据，数据传输速率高"
        ],
        "answer": "D"
    },
    {
        "id": 24,
        "question": "下列选项中，用于设备和设备控制器之间互连的接口标准是（ ）。",
        "options": [
            "A) PCI",
            "B) USB",
            "C) AGP",
            "D) PCI-Express"
        ],
        "answer": "B"
    },
    {
        "id": 25,
        "question": "某同步总线采用数据线和地址线复用方式，其中地址/数据线有32根，总线时钟频率为66MHz，每个时钟周期传送两次数据（上升沿和下降沿各传送一次数据），该总线的最大数据传输速率（总线带宽）是（ ）。",
        "options": [
            "A) 132MB/s",
            "B) 264MB/s",
            "C) 528MB/s",
            "D) 1056MB/s"
        ],
        "answer": "B"
    },
    {
        "id": 26,
        "question": "某计算机采用3通道存储器总线，配套的内存条型号为DDR3-1333，即内存条所接插的存储器总线的工作频率为1333MHz，总线宽度为64位，则存储器总线的总带宽大约是（ ）。",
        "options": [
            "A) 10.66GB/s",
            "B) 32GB/s",
            "C) 64GB/s",
            "D) 96GB/s"
        ],
        "answer": "B"
    },
    {
        "id": 27,
        "question": "QPI总线是一种点对点全双工同步串行总线，总线上的设备可同时接收和发送信息，每个方向可同时传输20位信息（16位数据+4位校验位），每个QPI数据包有80位信息，分2个时钟周期传送，每个时钟周期传递2次。因此，QPI总线带宽为：每秒传送次数×2B×2。若QPI时钟频率为2.4GHz，则总线带宽为（ ）。",
        "options": [
            "A) 4.8GB/s",
            "B) 9.6GB/s",
            "C) 19.2GB/s",
            "D) 38.4GB/s"
        ],
        "answer": "B"
    },
    {
        "id": 28,
        "question": "在不同速度的设备之间传送数据，（ ）。",
        "options": [
            "A) 必须采用同步控制方式",
            "B) 必须采用异步控制方式",
            "C) 可以选用同步控制方式，也可选用异步控制方式",
            "D) 必须采用应答方式"
        ],
        "answer": "C"
    },
    {
        "id": 29,
        "question": "某机器I/O设备采用异步串行传送方式传送字符信息，字符信息格式为1位起始位、7位数据位、1位校验位和1位停止位。若要求每秒传送480个字符，则该设备的数据传输速率为（ ）。",
        "options": [
            "A) 380b/s",
            "B) 4800B/s",
            "C) 480B/s",
            "D) 4800b/s"
        ],
        "answer": "D"
    },
    {
        "id": 30,
        "question": "假设某存储器总线采用同步通信方式，时钟频率为50MHz，总线以突发方式传输8个字，以支持块长为8字（每字4B）的Cache行的读/写。若全部访问都为读操作，访问顺序是1个时钟周期接收地址，3个时钟周期等待存储器读数，8个时钟周期用于传输8个字。则该存储器的数据传输速率为（ ）。",
        "options": [
            "A) 114.3MB/s",
            "B) 126MB/s",
            "C) 133.3MB/s",
            "D) 144.3MB/s"
        ],
        "answer": "C"
    },
    {
        "id": 31,
        "question": "同步控制方式是（ ）。",
        "options": [
            "A) 只适用于CPU控制的方式",
            "B) 只适用于外部设备控制的方式",
            "C) 由统一的时序信号控制的方式",
            "D) 所有指令执行时间都相同的方式"
        ],
        "answer": "C"
    },
    {
        "id": 32,
        "question": "同步通信之所以比异步通信具有较高的传输速率，是因为（ ）。",
        "options": [
            "A) 同步通信不需要应答信号且总线长度较短",
            "B) 同步通信用一个公共的时钟信号进行同步",
            "C) 同步通信中，各部件的存取时间较接近",
            "D) 以上各项因素的综合结果"
        ],
        "answer": "D"
    },
    {
        "id": 33,
        "question": "以下各项中，（ ）是同步传输的特点。",
        "options": [
            "A) 需要应答信号",
            "B) 各部件的存取时间比较接近",
            "C) 总线长度较长",
            "D) 总线周期长度可变"
        ],
        "answer": "B"
    },
    {
        "id": 34,
        "question": "在异步总线中，传送操作（ ）。",
        "options": [
            "A) 由设备控制器控制",
            "B) 由CPU控制",
            "C) 由统一时序信号控制",
            "D) 按需分配时间"
        ],
        "answer": "D"
    },
    {
        "id": 35,
        "question": "总线的异步通信方式是（ ）。",
        "options": [
            "A) 既不采用时钟信号，又不采用“握手”信号",
            "B) 只采用时钟信号，不采用“握手”信号",
            "C) 不采用时钟信号，只采用“握手”信号",
            "D) 既采用时钟信号，又采用“握手”信号"
        ],
        "answer": "C"
    },
    {
        "id": 36,
        "question": "在各种异步通信方式中，（ ）的速度最快。",
        "options": [
            "A) 全互锁",
            "B) 半互锁",
            "C) 不互锁",
            "D) 速度均相等"
        ],
        "answer": "C"
    },
    {
        "id": 37,
        "question": "在下列各种情况下，最应采用异步传输方式的是（ ）。",
        "options": [
            "A) I/O接口与打印机交换信息",
            "B) CPU与主存交换信息",
            "C) CPU和PCI总线交换信息",
            "D) 由统一时序信号控制方式下的设备"
        ],
        "answer": "A"
    },
    {
        "id": 38,
        "question": "在手术过程中，医生将手伸出，等护士将手术刀递上，待医生握紧后，护士才松手。若把医生和护士视为两个通信模块，上述动作相当于（ ）。",
        "options": [
            "A) 同步通信",
            "B) 异步通信的全互锁方式",
            "C) 异步通信的半互锁方式",
            "D) 异步通信的不互锁方式"
        ],
        "answer": "B"
    },
    {
        "id": 39,
        "question": "一个总线传输周期依次包括以下几个阶段（ ）。",
        "options": [
            "A) ①②③④",
            "B) ②③④①",
            "C) ③②④①",
            "D) ②④③①"
        ],
        "answer": "C"
    },
    {
        "id": 40,
        "question": "某同步总线的时钟频率为100MHz，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发（Burst）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是（ ）。",
        "options": [
            "A) 20ns",
            "B) 40ns",
            "C) 50ns",
            "D) 80ns"
        ],
        "answer": "C"
    },
    {
        "id": 41,
        "question": "一次总线事务中，主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据。这种总线事务方式称为（ ）。",
        "options": [
            "A) 并行传输",
            "B) 串行传输",
            "C) 突发传输",
            "D) 同步传输"
        ],
        "answer": "C"
    },
    {
        "id": 42,
        "question": "下列有关总线定时的叙述中，错误的是（ ）。",
        "options": [
            "A) 异步通信方式中，全互锁协议最慢",
            "B) 异步通信方式中，非互锁协议的可靠性最差",
            "C) 同步通信方式中，同步时钟信号可由各设备提供",
            "D) 半同步通信方式中，握手信号的采样由同步时钟控制"
        ],
        "answer": "C"
    },
    {
        "id": 43,
        "question": "下列关于总线设计的叙述中，错误的是（ ）。",
        "options": [
            "A) 并行总线传输比串行总线传输速度快",
            "B) 采用信号线复用技术可减少信号线数量",
            "C) 采用突发传输方式可提高总线数据传输速率",
            "D) 采用分离事务通信方式可提高总线利用率"
        ],
        "answer": "A"
    },
    {
        "id": 44,
        "question": "下列关于多总线结构的叙述中，错误的是（ ）。",
        "options": [
            "A) 靠近CPU的总线速度较快",
            "B) 存储器总线可支持突发传送方式",
            "C) 总线之间须通过桥接器相连",
            "D) PCI-Express×16采用并行传输方式"
        ],
        "answer": "D"
    },
    {
        "id": 45,
        "question": "下列选项中，可提高同步总线数据传输速率的是（ ）。",
        "options": [
            "A) 仅Ⅰ、Ⅱ",
            "B) 仅Ⅰ、Ⅱ、Ⅲ",
            "C) 仅Ⅰ、Ⅳ",
            "D) Ⅰ、Ⅱ、Ⅲ和Ⅳ"
        ],
        "answer": "B"
    },
    {
        "id": 46,
        "question": "下列关于总线的叙述中，错误的是（ ）。",
        "options": [
            "A) 总线是在两个或多个部件之间进行数据交换的传输介质",
            "B) 同步总线由时钟信号定时，时钟频率不一定等于工作频率",
            "C) 异步总线由握手信号定时，一次握手过程完成一位数据交换",
            "D) 突发(Burst)传送总线事务可以在总线上连续传送多个数据"
        ],
        "answer": "C"
    },
    {
        "id": 47,
        "question": "某存储器总线宽度为64位，总线时钟频率为1GHz，在总线上传输一个数据或地址需要一个时钟周期，不支持突发传送方式。若通过该总线连接CPU和主存，主存每次准备一个64位数据需要6ns，主存块大小为32B，则读取一个主存块所需的时间是（ ）。",
        "options": [
            "A) 8ns",
            "B) 11ns",
            "C) 26ns",
            "D) 32ns"
        ],
        "answer": "C"
    }
]
              
          ,
          chapter7: [
    {
        "id": 1,
        "question": "在微型机系统中，I/O设备通过（　）与主板的系统总线相连接。",
        "options": ["A) DMA控制器", "B) 设备控制器", "C) 中断控制器", "D) I/O端口"],
        "answer": "C"
    },
    {
        "id": 2,
        "question": "显示汉字采用点阵字库，若每个汉字用16×16的点阵表示，7500个汉字的字库容量是（　）",
        "options": ["A) 16KB", "B) 240KB", "C) 320KB", "D) 1MB"],
        "answer": "C"
    },
    {
        "id": 3,
        "question": "CRT的分辨率为1024×1024像素，像素的颜色数为256，则刷新存储器的每单元字长为（　），总容量为（　）。",
        "options": ["A) 8B，256MB", "B) 8bit，1MB", "C) 8bit，256KB", "D) 8B，32MB"],
        "answer": "C"
    },
    {
        "id": 4,
        "question": "假定一台计算机的显示存储器用DRAM芯片实现，若要求显示分辨率为1600×1200，颜色深度为24位，帧频为85Hz，显存总带宽的50%用来刷新屏幕，则需要的显存总带宽至少约为（　）",
        "options": ["A) 245Mb/s", "B) 979Mb/s", "C) 1958Mb/s", "D) 7834Mb/s"],
        "answer": "C"
    },
    {
        "id": 5,
        "question": "在统一编址的方式下，区分存储单元和I/O设备是靠（　）",
        "options": ["A) 不同的地址码", "B) 不同的地址线", "C) 不同的控制线", "D) 不同的数据线"],
        "answer": "C"
    },
    {
        "id": 6,
        "question": "下列功能中，属于I/O接口的功能的是（　）<br>Ⅰ. 数据格式的转换<br>Ⅱ. I/O过程中错误与状态检测<br>Ⅲ. I/O操作的控制与定时<br>Ⅳ. 与主机和外设通信",
        "options": ["A) Ⅰ、Ⅱ和Ⅳ", "B) Ⅰ、Ⅲ和Ⅳ", "C) Ⅰ、Ⅱ和Ⅳ", "D) Ⅰ、Ⅱ、Ⅲ和Ⅳ"],
        "answer": "C"
    },
    {
        "id": 7,
        "question": "下列关于I/O端口和接口的说法中，正确的是（　）",
        "options": ["A) 按照不同的数据传送格式，可将接口分为同步传送接口和异步传送接口", "B) 在统一编址方式下，存储单元和I/O设备是靠不同的地址线来区分的", "C) 在独立编址方式下，存储单元和I/O设备是靠不同的地址线来区分的", "D) 在独立编址方式下，CPU需要设置专门的输入/输出指令访问端口"],
        "answer": "C"
    },
    {
        "id": 8,
        "question": "下列属于I/O接口中寄存器的有（　）<br>Ⅰ. 指令寄存器<br>Ⅱ. 控制寄存器<br>Ⅲ. 状态寄存器<br>Ⅳ. 地址寄存器<br>Ⅴ. 数据缓冲寄存器",
        "options": ["A) Ⅰ、Ⅱ、Ⅲ和Ⅴ", "B) Ⅰ、Ⅲ、Ⅳ", "C) Ⅱ、Ⅲ和Ⅴ", "D) Ⅱ、Ⅲ、Ⅳ和Ⅴ"],
        "answer": "C"
    },
    {
        "id": 9,
        "question": "I/O的编址方式采用统一编址方式时，进行输入/输出的操作的指令是（　）",
        "options": ["A) 控制指令", "B) 访存指令", "C) 输入/输出指令", "D) 都不对"],
        "answer": "C"
    },
    {
        "id": 10,
        "question": "下列关于I/O指令的说法中，错误的是（　）",
        "options": ["A) I/O指令是CPU系统指令的一部分", "B) I/O指令是机器指令的一类", "C) I/O指令反映CPU和I/O设备交换信息的特点", "D) I/O指令的格式和通用指令的格式相同"],
        "answer": "C"
    },
    {
        "id": 11,
        "question": "下列叙述中，正确的是（　）",
        "options": ["A) 只有I/O指令可以访问I/O设备", "B) 在统一编址下，不能直接访问I/O设备", "C) 访问存储器的指令一定不能访问I/O设备", "D) 只有在具有专门I/O指令的计算机中，I/O设备才可以单独编址"],
        "answer": "C"
    },
    {
        "id": 12,
        "question": "在内存地址空间与接口地址空间统一编址的计算机中，不需要的指令是（　）",
        "options": ["A) 数据传送类（如MOV指令）", "B) 算术、逻辑运算类（如ADD、SUB、AND和OR指令）", "C) 输入/输出类（如IN和OUT指令）", "D) 程序控制类(如条件转移指令和子程序调用指令)"],
        "answer": "C"
    },
    {
        "id": 13,
        "question": "在统一编址的情况下，就I/O设备而言，其对应的I/O地址不可取的是（　）",
        "options": ["A) 要求固定在地址高端", "B) 要求固定在地址低端", "C) 要求相对固定在地址的某部分", "D) 可以随意在地址的任何地方"],
        "answer": "C"
    },
    {
        "id": 14,
        "question": "磁盘驱动器向盘片磁道记录数据时采用（　）方式写入。",
        "options": ["A) 并行", "B) 串行", "C) 并行-串行", "D) 串行-并行"],
        "answer": "C"
    },
    {
        "id": 15,
        "question": "程序员进行系统调用访问设备使用的是（　）",
        "options": ["A) 逻辑地址", "B) 物理地址", "C) 主设备地址", "D) 从设备地址"],
        "answer": "C"
    },
    {
        "id": 16,
        "question": "采用中断方式进行打印控制时，在打印控制接口和打印机之间交换的信息不包括（　）",
        "options": ["A) 打印字符点阵信息", "B) 打印控制信息", "C) 打印机状态信息", "D) 中断请求信号"],
        "answer": "C"
    },
    {
        "id": 17,
        "question": "主机和外设之间的正确连接通路是（　）",
        "options": ["A) CPU和主存→I/O总线→通信总线（电缆）→I/O接口→外设", "B) CPU和主存→I/O总线→I/O接口→通信总线（电缆）→外设", "C) CPU和主存→I/O接口→I/O总线→通信总线（电缆）→外设", "D) CPU和主存→I/O接口→通信总线（电缆）→I/O总线→外设"],
        "answer": "C"
    },
    {
        "id": 18,
        "question": "下列有关I/O接口功能和结构的叙述中，错误的是（　）",
        "options": ["A) I/O接口中主机侧数据宽度与设备侧数据宽度总是一样的", "B) I/O接口是像显卡或网卡之类的一种外设控制逻辑", "C) CPU可以从I/O接口读取状态信息，以了解接口和外设的状态", "D) CPU可以向I/O接口传送用来对设备进行控制的命令"],
        "answer": "C"
    },
    {
        "id": 19,
        "question": "下列选项中，在I/O总线的数据线上传输的信息包括（　）<br>Ⅰ. I/O接口中的命令字<br>Ⅱ. I/O接口中的状态字<br>Ⅲ. 中断类型号",
        "options": ["A) 仅Ⅰ、Ⅱ", "B) 仅Ⅰ、Ⅲ", "C) 仅Ⅱ、Ⅲ", "D) Ⅰ、Ⅱ、Ⅲ"],
        "answer": "C"
    },
    {
        "id": 20,
        "question": "下列有关I/O接口的叙述中，错误的是（　）",
        "options": ["A) 状态端口和控制端口可以合用同一个寄存器", "B) I/O接口中CPU可访问的寄存器称为I/O端口", "C) 采用独立编址方式时，I/O端口地址和主存地址可能相同", "D) 采用统一编址方式时，CPU不能用访存指令访问I/O端口"],
        "answer": "C"
    },
    {
        "id": 21,
        "question": "I/O指令实现的数据传送通常发生在（　）",
        "options": ["A) I/O设备和I/O端口之间", "B) 通用寄存器和I/O设备之间", "C) I/O端口和I/O端口之间", "D) 通用寄存器和I/O端口之间"],
        "answer": "C"
    },
    {
        "id": 22,
        "question": "下列选项中，不属于I/O接口的是（　）",
        "options": ["A) 磁盘驱动器", "B) 打印机适配器", "C) 网络控制器", "D) 可编程中断控制器"],
        "answer": "C"
    },
    {
        "id": 23,
        "question": "设置中断排队判优逻辑的目的是（　）",
        "options": ["A) 产生中断源编码", "B) 使同时提出的请求中的优先级别最高者得到及时响应", "C) 使CPU能方便地转入中断服务子程序", "D) 提高中断响应速度"],
        "answer": "C"
    },
    {
        "id": 24,
        "question": "以下说法中，错误的是（　）",
        "options": ["A) 中断服务程序一般是操作系统模块", "B) 中断向量方法可提高中断源的识别速度", "C) 中断向量地址是中断服务程序的入口地址", "D) 重叠处理中断的现象称为中断嵌套"],
        "answer": "C"
    },
    {
        "id": 25,
        "question": "当有中断源发出请求时，CPU可执行相应的中断服务程序，可以提出中断（包括内中断和外中断）的有（　）<br>Ⅰ. 外部事件<br>Ⅱ. Cache<br>Ⅲ. 虚拟存储器失效<br>Ⅳ. 浮点数运算下溢<br>Ⅴ. 浮点数运算上溢",
        "options": ["A) Ⅰ、Ⅲ和Ⅳ", "B) Ⅰ、Ⅲ和Ⅴ", "C) Ⅰ、Ⅱ和Ⅴ", "D) Ⅰ、Ⅲ和Ⅴ"],
        "answer": "C"
    },
    {
        "id": 26,
        "question": "关于程序中断方式和DMA方式的叙述，错误的是（　）<br>Ⅰ. DMA的优先级比程序中断的优先级要高<br>Ⅱ. 程序中断方式需要保护现场，DMA方式在传输过程中不需要保护现场<br>Ⅲ. 程序中断方式的中断请求是为了报告CPU数据的传输结束，而DMA方式的中断请求完全是为了传送数据",
        "options": ["A) 仅Ⅱ", "B) Ⅱ、Ⅲ", "C) 仅Ⅲ", "D) Ⅰ、Ⅱ、Ⅲ"],
        "answer": "C"
    },
    {
        "id": 27,
        "question": "下列说法中，错误的是（　）<br>Ⅰ. 程序中断过程是由硬件和中断服务程序共同完成的<br>Ⅱ. 在每条指令的执行过程中，每个总线周期要检查一次有无中断请求<br>Ⅲ. 检测有无DMA请求，一般安排在一条指令执行过程的末尾<br>Ⅳ. 中断服务程序的最后指令是无条件转移指令",
        "options": ["A) Ⅲ、Ⅳ", "B) Ⅰ、Ⅱ、Ⅲ", "C) Ⅱ、Ⅳ", "D) Ⅰ、Ⅱ、Ⅲ、Ⅳ"],
        "answer": "C"
    },
    {
        "id": 28,
        "question": "能产生DMA请求的总线部件是（　）<br>Ⅰ. 高速外设<br>Ⅱ. 需要与主机批量交换数据的外设<br>Ⅲ. 具有DMA接口的设备",
        "options": ["A) 仅Ⅰ", "B) 仅Ⅲ", "C) Ⅱ、Ⅲ", "D) Ⅰ、Ⅱ、Ⅲ"],
        "answer": "C"
    },
    {
        "id": 29,
        "question": "在具有中断向量表的计算机中，中断向量地址是（　）",
        "options": ["A) 子程序入口地址", "B) 中断服务程序的入口地址", "C) 中断服务程序入口地址的地址", "D) 中断程序断点"],
        "answer": "C"
    },
    {
        "id": 30,
        "question": "中断响应是在（　）",
        "options": ["A) 一条指令执行开始", "B) 一条指令执行中间", "C) 一条指令执行之末", "D) 一条指令执行的任何时刻"],
        "answer": "C"
    },
    {
        "id": 31,
        "question": "在下列情况下，可能不发生中断请求的是（　）",
        "options": ["A) DMA操作结束", "B) 一条指令执行完毕", "C) 机器出现故障", "D) 执行“软中断”指令"],
        "answer": "C"
    },
    {
        "id": 32,
        "question": "在配有通道的计算机系统中，用户程序需要输入/输出时，引起的中断是（　）",
        "options": ["A) 访管中断", "B) I/O中断", "C) 故障", "D) 外中断"],
        "answer": "C"
    },
    {
        "id": 33,
        "question": "某计算机有4级中断，优先级从高到低为1→2→3→4。若将优先级顺序修改，改后1级中断的屏蔽字为1101，2级中断的屏蔽字为0100，3级中断的屏蔽字为1111，4级中断的屏蔽字为0101，则修改后的优先顺序从高到低为（　）",
        "options": ["A) 1→2→3→4", "B) 3→1→4→2", "C) 1→3→4→2", "D) 2→1→3→4"],
        "answer": "C"
    },
    {
        "id": 34,
        "question": "下列不属于程序控制指令的是（　）",
        "options": ["A) 无条件转移指令", "B) 有条件转移指令", "C) 中断隐指令", "D) 循环指令"],
        "answer": "C"
    },
    {
        "id": 35,
        "question": "在中断响应周期中，CPU主要完成的工作是（　）",
        "options": ["A) 关中断，保护断点，发中断响应信号并形成向量地址", "B) 开中断，保护断点，发中断响应信号并形成向量地址", "C) 关中断，执行中断服务程序", "D) 开中断，执行中断服务程序"],
        "answer": "C"
    },
    {
        "id": 36,
        "question": "下列关于中断I/O方式的叙述中，错误的是（　）",
        "options": ["A) CPU对外部中断的响应不可能发生在一条指令的执行过程中", "B) 在中断I/O方式下，外设接口中的寄存器和CPU中的寄存器直接交换数据", "C) 中断请求的是CPU时间，要求CPU执行程序来处理发生的相关事件", "D) 只要有中断请求发生，一条指令执行结束后CPU就进入中断响应周期"],
        "answer": "C"
    },
    {
        "id": 37,
        "question": "当CPU响应中断时，进入“中断响应周期”，采用硬件方法保护并更新程序计数器(PC)内容，而不是由软件完成的，主要是为了（　）",
        "options": ["A) 能进入中断处理程序，并能正确返回源程序", "B) 节省主存空间", "C) 提高处理机速度", "D) 易于编制中断处理程序"],
        "answer": "C"
    },
    {
        "id": 38,
        "question": "在I/O接口中设置中断触发器保存外设发出的中断请求，是因为（　）",
        "options": ["A) 中断不需要立即处理", "B) 中断设备的处理速度比CPU快", "C) CPU无法对发生的中断请求立即进行处理", "D) 可能有多个中断同时发生"],
        "answer": "C"
    },
    {
        "id": 39,
        "question": "在中断响应周期中，由（　）将允许中断触发器置0。",
        "options": ["A) 关中断指令", "B) 中断隐指令", "C) 开中断指令", "D) 中断服务程序"],
        "answer": "C"
    },
    {
        "id": 40,
        "question": "CPU响应中断时最先完成的步骤是（　）",
        "options": ["A) 开中断", "B) 保存断点", "C) 关中断", "D) 转入中断服务程序"],
        "answer": "C"
    },
    {
        "id": 41,
        "question": "设置中断屏蔽标志可以改变（　）",
        "options": ["A) 多个中断源的中断请求优先级", "B) CPU对多个中断请求响应的优先次序", "C) 多个中断服务程序开始执行的顺序", "D) 多个中断服务程序执行完的次序"],
        "answer": "C"
    },
    {
        "id": 42,
        "question": "在CPU响应中断时，保护两个关键的硬件状态是（　）",
        "options": ["A) PC和IR", "B) PC和PSW", "C) AR和IR", "D) AR和PSW"],
        "answer": "C"
    },
    {
        "id": 43,
        "question": "在各种I/O方式中，中断方式的特点是（　），DMA方式的特点是（　）。",
        "options": ["A) CPU与外设串行工作，传送与主程序串行工作", "B) CPU与外设并行工作，传送与主程序串行工作", "C) CPU与外设串行工作，传送与主程序并行工作", "D) CPU与外设并行工作，传送与主程序并行工作"],
        "answer": "C"
    },
    {
        "id": 44,
        "question": "下列关于程序查询方式及其工作过程的叙述中，正确的是（　）",
        "options": ["A) 按启动查询方式的不同，可分为软件查询方式和硬件查询方式", "B) CPU主要负责启动外设和查询其状态，不参与数据传送", "C) 每完成一次数据传送后，会修改主存地址和计数值", "D) CPU需一直查询外设的状态，直到外设准备就绪时才可去执行其他程序"],
        "answer": "C"
    },
    {
        "id": 45,
        "question": "在DMA传送方式中，由（　）发出DMA请求，在传送期间总线控制权由（　）掌握。",
        "options": ["A) 外部设备、CPU", "B) DMA控制器、DMA控制器", "C) 外部设备、DMA控制器", "D) DMA控制器、内存"],
        "answer": "C"
    },
    {
        "id": 46,
        "question": "下列叙述中，（　）是正确的。",
        "options": ["A) 程序中断方式和DMA方式中实现数据传送都需要中断请求", "B) 程序中断方式中有中断请求，DMA方式中没有中断请求", "C) 程序中断方式和DMA方式中都有中断请求，但目的不同", "D) DMA要等指令周期结束时才可以进行周期窃取"],
        "answer": "C"
    },
    {
        "id": 47,
        "question": "以下关于DMA方式进行I/O的描述中，正确的是（　）",
        "options": ["A) 一个完整的DMA过程，部分由DMA控制器控制，部分由CPU控制", "B) 一个完整的DMA过程，完全由CPU控制", "C) 一个完整的DMA过程，完全由DMA控制器控制，CPU不介入任何控制", "D) 一个完整的DMA过程，完全由CPU采用周期挪用法控制"],
        "answer": "C"
    },
    {
        "id": 48,
        "question": "CPU响应DMA请求的条件是当前（　）执行完。",
        "options": ["A) 机器周期", "B) 总线周期", "C) 机器周期和总线周期", "D) 指令周期"],
        "answer": "C"
    },
    {
        "id": 49,
        "question": "当某五级流水线CPU正在执行某条指令的第二级流水段时，外部设备产生了一个DMA请求，则CPU对该DMA请求响应的时机是（　）",
        "options": ["A) 立即响应", "B) 在该指令的第二级流水段执行完毕后响应", "C) 在该指令的第三级流水段执行完毕后响应", "D) 在该指令执行结束后响应"],
        "answer": "C"
    },
    {
        "id": 50,
        "question": "关于外中断（故障除外）和DMA，下列说法中正确的是（　）",
        "options": ["A) DMA请求和中断请求同时发生时，响应DMA请求", "B) DMA请求、非屏蔽中断、可屏蔽中断都要在当前指令结束之后才能被响应", "C) 非屏蔽中断请求优先级最高，可屏蔽中断请求优先级最低", "D) 若不开中断，所有中断请求就不能响应"],
        "answer": "C"
    },
    {
        "id": 51,
        "question": "以下有关DMA方式的叙述中，错误的是（　）",
        "options": ["A) 在DMA方式下，DMA控制器向CPU请求的是总线使用权", "B) DMA方式可用于键盘和鼠标的数据输入", "C) 在数据传输阶段，不需要CPU介入，完全由DMA控制器控制", "D) DMA方式要用到中断处理"],
        "answer": "C"
    },
    {
        "id": 52,
        "question": "在主机和外设的信息传送中，（　）不是一种程序控制方式。",
        "options": ["A) 直接程序传送", "B) 程序中断", "C) 直接存储器存取(DMA)", "D) 通道控制"],
        "answer": "C"
    },
    {
        "id": 53,
        "question": "中断发生时，程序计数器内容的保护和更新是由（　）完成的。",
        "options": ["A) 硬件自动", "B) 进栈指令和转移指令", "C) 访存指令", "D) 中断服务程序"],
        "answer": "C"
    },
    {
        "id": 54,
        "question": "在DMA方式传送数据的过程中，因为没有破坏（　）的内容，所以CPU可以正常工作（访存除外）。",
        "options": ["A) 程序计数器", "B) 程序计数器和寄存器", "C) 指令寄存器", "D) 堆栈寄存器"],
        "answer": "C"
    },
    {
        "id": 55,
        "question": "在DMA方式下，数据从内存传送到外设经过的路径是（　）",
        "options": ["A) 内存→数据总线→数据通路→外设", "B) 内存→数据总线→DMAC→外设", "C) 内存→数据通路→数据总线→外设", "D) 内存→CPU→外设"],
        "answer": "C"
    },
    {
        "id": 56,
        "question": "采用周期挪用进行DMA数据传送时，每传送一个数据要占用一个（　）的时间。",
        "options": ["A) 指令周期", "B) 机器周期", "C) 时钟周期", "D) 存取周期"],
        "answer": "C"
    },
    {
        "id": 57,
        "question": "启动一次DMA传送，外设和主机之间将完成一个（　）的数据传送。",
        "options": ["A) 字节", "B) 字", "C) 总线宽度", "D) 数据块"],
        "answer": "C"
    },
    {
        "id": 58,
        "question": "在磁盘存储器进行读/写操作之前，CPU需要对磁盘控制器或DMA控制器进行初始化。在下列选项中，不包含在初始化信息中的是（　）",
        "options": ["A) 传送信息所在的主存起始地址", "B) 传送方向（是读磁盘还是写磁盘）", "C) 传送信息所在的通用寄存器编号", "D) 传送数据的字数或字节数"],
        "answer": "C"
    },
    {
        "id": 59,
        "question": "【2009统考真题】下列选项中，能引起外部中断的事件是（　）",
        "options": ["A) 键盘输入", "B) 除数为0", "C) 浮点运算下溢", "D) 访存缺页"],
        "answer": "C"
    },
    {
        "id": 60,
        "question": "【2010统考真题】单级中断系统中，中断服务程序内的执行顺序是（　）",
        "options": ["A) 保护现场→关中断→中断事件处理→恢复现场→中断返回", "B) 保护现场→开中断→中断事件处理→恢复现场→中断返回", "C) 关中断→保护现场→中断事件处理→恢复现场→中断返回", "D) 关中断→保护现场→中断事件处理→开中断→中断返回"],
        "answer": "C"
    },
    {
        "id": 61,
        "question": "【2011统考真题】某计算机有五级中断L4～L0，中断屏蔽字为M4M3M2M1M0，Mi=1(0≤i≤4)表示对Li级中断进行屏蔽。若中断响应优先级从高到低的顺序是L0→L1→L2→L3→L4，且要求中断处理优先级从高到低的顺序为L4→L0→L2→L1→L3，则L1的中断处理程序中设置的中断屏蔽字是（　）",
        "options": ["A) 11110", "B) 01101", "C) 00111", "D) 01010"],
        "answer": "C"
    },
    {
        "id": 62,
        "question": "【2011统考真题】某计算机处理器主频为50MHz，采用定时查询方式控制设备A的I/O，查询程序运行一次所用的时钟周期数至少为500。在设备A工作期间，为保证数据不丢失，每秒需对其查询至少200次，则CPU用于设备A的I/O的时间占整个CPU时间的百分比至少是（　）",
        "options": ["A) 0.02%", "B) 0.05%", "C) 0.20%", "D) 0.50%"],
        "answer": "C"
    },
    {
        "id": 63,
        "question": "【2012统考真题】响应外部中断的过程中，中断隐指令完成的操作，除保护断点外，还包括（　）<br>Ⅰ. 关中断<br>Ⅱ. 保存通用寄存器的内容<br>Ⅲ. 形成中断服务程序入口地址并送PC",
        "options": ["A) 仅Ⅰ、Ⅱ", "B) 仅Ⅰ、Ⅲ", "C) 仅Ⅱ、Ⅲ", "D) Ⅰ、Ⅱ、Ⅲ"],
        "answer": "C"
    },
    {
        "id": 64,
        "question": "【2013统考真题】下列关于中断I/O方式和DMA方式比较的叙述中，错误的是（　）",
        "options": ["A) 中断I/O方式请求的是CPU处理时间，DMA方式请求的是总线使用权", "B) 中断响应发生在一条指令执行结束后，DMA响应发生在一个总线事务完成后", "C) 中断I/O方式下数据传送通过软件完成，DMA方式下数据传送由硬件完成", "D) 中断I/O方式适用于所有外部设备，DMA方式仅适用于快速外部设备"],
        "answer": "C"
    },
    {
        "id": 65,
        "question": "【2014统考真题】若某设备中断请求的响应和处理时间为100ns，每400ns发出一次中断请求，中断响应所允许的最长延迟时间为50ns，则在该设备持续工作过程中，CPU用于该设备的I/O时间占整个CPU时间的百分比至少是（　）",
        "options": ["A) 12.5%", "B) 25%", "C) 37.5%", "D) 50%"],
        "answer": "C"
    },
    {
        "id": 66,
        "question": "【2015统考真题】在采用中断I/O方式控制打印输出的情况下，CPU和打印控制接口中的I/O端口之间交换的信息不可能是（　）",
        "options": ["A) 打印字符", "B) 主存地址", "C) 设备状态", "D) 控制命令"],
        "answer": "C"
    },
    {
        "id": 67,
        "question": "【2017统考真题】下列关于多重中断系统的叙述中，错误的是（　）",
        "options": ["A) 在一条指令执行结束时响应中断", "B) 中断处理期间CPU处于关中断状态", "C) 中断请求的产生与当前指令的执行无关", "D) CPU通过采样中断请求信号检测中断请求"],
        "answer": "C"
    },
    {
        "id": 68,
        "question": "【2018统考真题】下列关于外部I/O中断的叙述中，正确的是（　）",
        "options": ["A) 中断控制器按所接收中断请求的先后次序进行中断优先级排队", "B) CPU响应中断时，通过执行中断隐指令完成通用寄存器的保护", "C) CPU只有在处于中断允许状态时，才能响应外部设备的中断请求", "D) 有中断请求时，CPU立即暂停当前指令执行，转去执行中断服务程序"],
        "answer": "C"
    },
    {
        "id": 69,
        "question": "【2019统考真题】某设备以中断方式与CPU进行数据交换，CPU主频为1GHz，设备接口中的数据缓冲寄存器为32位，设备的数据传输速率为50kB/s。若每次中断开销（包括中断响应和中断处理）为1000个时钟周期，则CPU用于该设备输入/输出的时间占整个CPU时间的百分比最多是（　）",
        "options": ["A) 1.25%", "B) 2.5%", "C) 5%", "D) 12.5%"],
        "answer": "C"
    },
    {
        "id": 70,
        "question": "【2019统考真题】下列关于DMA方式的叙述中，正确的是（　）<br>Ⅰ. DMA传送前由设备驱动程序设置传送参数<br>Ⅱ. 数据传送前由DMA控制器请求总线使用权<br>Ⅲ. 数据传送由DMA控制器直接控制总线完成<br>Ⅳ. DMA传送结束后的处理由中断服务程序完成",
        "options": ["A) 仅Ⅰ、Ⅱ", "B) 仅Ⅰ、Ⅲ、Ⅳ", "C) 仅Ⅱ、Ⅲ、Ⅳ", "D) Ⅰ、Ⅱ、Ⅲ、Ⅳ"],
        "answer": "C"
    },
    {
        "id": 71,
        "question": "【2020统考真题】下列事件中，属于外部中断事件的是（　）<br>Ⅰ. 访存时缺页<br>Ⅱ. 定时器到时<br>Ⅲ. 网络数据包到达",
        "options": ["A) Ⅰ、Ⅱ", "B) 仅Ⅲ", "C) Ⅱ、Ⅲ", "D) Ⅰ、Ⅱ和Ⅲ"],
        "answer": "C"
    },
    {
        "id": 72,
        "question": "【2020统考真题】外部中断包括不可屏蔽中断(NMI)和可屏蔽中断，下列关于外部中断的叙述中，错误的是（　）",
        "options": ["A) CPU处于关中断状态时，也能响应NMI请求", "B) 一旦可屏蔽中断请求信号有效，CPU就立即响应", "C) 不可屏蔽中断的优先级比可屏蔽中断的优先级高", "D) 可通过中断屏蔽字改变可屏蔽中断的处理优先级"],
        "answer": "C"
    },
    {
        "id": 73,
        "question": "【2020统考真题】若设备采用周期挪用DMA方式进行输入和输出，每次DMA传送的数据块大小为512字节，相应的I/O接口中有一个32位数据缓冲寄存器。对于数据输入过程，下列叙述中，错误的是（　）",
        "options": ["A) 每准备好32位数据，DMA控制器就发出一次总线请求", "B) 相对于CPU，DMA控制器的总线使用权的优先级更高", "C) 在整个数据块的传送过程中，CPU不可以访问主存储器", "D) 数据块传送结束时，会产生“DMA传送结束”中断请求"],
        "answer": "C"
    },
    {
        "id": 74,
        "question": "【2021统考真题】下列是关于多重中断系统中CPU响应中断的叙述，错误的是（　）",
        "options": ["A) 仅在用户态（执行用户程序）下，CPU才能检测和响应中断", "B) CPU只有在检测到中断请求信号后，才会进入中断响应周期", "C) 进入中断响应周期时，CPU一定处于中断允许（开中断）状态", "D) 若CPU检测到中断请求信号，则一定存在未被屏蔽的中断源请求信号"],
        "answer": "C"
    },
    {
        "id": 75,
        "question": "【2022统考真题】下列关于中断I/O方式的叙述中，不正确的是（　）",
        "options": ["A) 适用于键盘、针式打印机等字符型设备", "B) 外设和主机之间的数据传送通过软件完成", "C) 外设准备数据的时间应小于中断处理时间", "D) 外设为某进程准备数据时CPU可运行其他进程"],
        "answer": "C"
    },
    {
        "id": 76,
        "question": "【2023统考真题】下列关于硬件和异常/中断关系的叙述中，错误的是（　）",
        "options": ["A) CPU在执行一条指令的过程中检测异常事件", "B) CPU在执行完一条指令时检测中断请求信号", "C) 开中断时CPU检测到中断请求后就进行中断响应", "D) 外部设备通过中断控制器向CPU发中断结束信号"],
        "answer": "C"
    },
    {
        "id": 77,
        "question": "【2023统考真题】下列关于I/O控制方式的叙述中，错误的是（　）",
        "options": ["A) 查询方式下，通过CPU执行查询程序进行I/O操作", "B) 中断方式下，通过CPU执行中断服务程序进行I/O操作", "C) DMA方式下，通过CPU执行DMA传送程序进行I/O操作", "D) 对于SSD、网络适配器等高速设备，采用DMA方式输入/输出"],
        "answer": "C"
    },
    {
        "id": 78,
        "question": "磁盘和主存进行数据交换时，大致可分为四个过程：①寻道；②旋转；③连续读写磁盘块；④结束、校验。则下列关于磁盘读写过程的叙述中，错误的是（　）",
        "options": ["A) 在①②④三个阶段都用到了中断处理", "B) 在第③阶段，DMA控制器向CPU请求的是总线使用权", "C) 在第③阶段，DMA控制器使用总线的优先级比CPU低", "D) 在第③阶段，磁盘的读写和CPU执行其他任务是可以并行执行的"],
        "answer": "C"
    },
    {
        "id": 79,
        "question": "【2024统考真题】下列关于中断I/O方式的叙述中，错误的是（　）",
        "options": ["A) 中断屏蔽字用于确定中断响应的优先级", "B) 保存断点和程序状态字在中断响应阶段完成", "C) 保存通用寄存器和设置新中断屏蔽字由软件实现", "D) 单重中断方式下中断处理时CPU处于关中断状态"],
        "answer": "C"
    },
    {
        "id": 80,
        "question": "【2024统考真题】DMA控制I/O方式下，设备的输入/输出由DMA控制器控制完成，此时，DMA控制器控制的数据传输通路位于（　）",
        "options": ["A) CPU和主存之间", "B) CPU和DMA控制器之间", "C) 设备接口和主存之间", "D) 设备接口和DMA控制器之间"],
        "answer": "C"
    }
]
          
}; 

      // 当前选择的题库和其他变量
      let currentChapter = 'chapter1'; // 当前选择的章节
      let originalQuestions = questionBanks.chapter1; // 默认使用第一章

      // 全局变量
      let shuffledQuestions = [];
      let userAnswers = {};
      let results = {};
      let usedQuestionIndices = [];
      let currentMode = ''; // 当前模式：'exam' 或 'practice'
      
      // 作答计时器变量
      let timerInterval;
      let startTime = null; // 记录考试开始时间

      // 密码保护逻辑
      const password = 'jy5247';
      const passwordProtection = document.getElementById('password-protection');
      const chapterSelection = document.getElementById('chapter-selection');
      const modeSelection = document.getElementById('mode-selection');
      const questionCountSelection = document.getElementById('question-count-selection');
      const passwordInput = document.getElementById('password-input');
      const passwordSubmit = document.getElementById('password-submit');
      const errorMessage = document.getElementById('error-message');

      // 主题切换功能
      const themeToggle = document.getElementById('theme-toggle');
      const themeIcon = themeToggle.querySelector('i');
      
      themeToggle.addEventListener('click', function() {
          document.body.classList.toggle('dark-theme');
          if(document.body.classList.contains('dark-theme')) {
              themeIcon.className = 'fas fa-sun';
          } else {
              themeIcon.className = 'fas fa-moon';
          }
      });
      
      // 中断返回按钮功能
      const interruptBtn = document.getElementById('interrupt-btn');
      
      interruptBtn.addEventListener('click', function() {
          // 停止计时器
          clearInterval(timerInterval);
          timerInterval = null;
          startTime = null;
          
          // 清空状态
          userAnswers = {};
          results = {};
          shuffledQuestions = [];
          usedQuestionIndices = [];
          document.getElementById('exam-form').innerHTML = '';
          document.getElementById('progress-bar').style.width = '0';
          document.getElementById('timer').innerHTML = '<i class="fas fa-clock"></i> 已用时: 00:00';
          document.getElementById('final-time').textContent = "";
          
          // 隐藏所有内容区域
          examContent.classList.add('hidden');
          document.getElementById('calibrate-content').classList.add('hidden');
          document.getElementById('memorize-content').classList.add('hidden');
          
          // 显示章节选择页面
          modeSelection.classList.add('hidden');
          chapterSelection.classList.remove('hidden');
          
          // 隐藏中断按钮
          interruptBtn.classList.remove('show');
      });
      
      // 显示/隐藏中断按钮的函数
      function showInterruptBtn() {
          interruptBtn.classList.add('show');
      }
      
      function hideInterruptBtn() {
          interruptBtn.classList.remove('show');
      }

      // 更新章节题目数量显示
      function updateChapterCounts() {
          for (let i = 1; i <= 7; i++) {
              const chapterKey = `chapter${i}`;
              const count = questionBanks[chapterKey].length;
              const countElement = document.getElementById(`${chapterKey}-count`);
              const btnElement = document.querySelector(`.chapter-btn[data-chapter="${chapterKey}"]`);
              
              if (countElement) {
                  countElement.textContent = `共 ${count} 题`;
              }
              
              // 如果该章节没有题目，禁用按钮
              if (btnElement) {
                  if (count === 0) {
                      btnElement.disabled = true;
                      if (countElement) {
                          countElement.textContent = '暂无题目';
                      }
                  } else {
                      btnElement.disabled = false;
                  }
              }
          }
      }

      passwordSubmit.addEventListener('click', function() {
          if (passwordInput.value === password) {
              passwordProtection.classList.add('hidden');
              chapterSelection.classList.remove('hidden');
              updateChapterCounts(); // 更新章节题目数量
          } else {
              errorMessage.style.display = 'block';
              passwordInput.value = '';
              passwordInput.focus();
          }
      });
      
      // 回车提交密码
      passwordInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
              passwordSubmit.click();
          }
      });

      // 章节选择逻辑
      document.querySelectorAll('.chapter-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              currentChapter = this.dataset.chapter;
              originalQuestions = questionBanks[currentChapter];
              
              // 切换到模式选择页面
              chapterSelection.classList.add('hidden');
              modeSelection.classList.remove('hidden');
          });
      });

      // 章节返回按钮
      document.getElementById('chapter-back-btn').addEventListener('click', function() {
          chapterSelection.classList.add('hidden');
          passwordProtection.classList.remove('hidden');
      });

      // 更新题目数量显示
      function updateQuestionCountDisplay() {
          const countInfo = document.querySelector('#question-count-selection p');
          const questionCountInput = document.getElementById('question-count-input');
          if (countInfo && questionCountInput) {
              const maxCount = originalQuestions.length;
              const chapterName = getChapterName(currentChapter);
              countInfo.textContent = `题库总数：${maxCount}题 (${chapterName})`;
              questionCountInput.max = maxCount;
              questionCountInput.placeholder = `请输入题目数量（1-${maxCount}）`;
          }
      }

      // 获取章节名称
      function getChapterName(chapter) {
          const names = {
              'chapter1': '第一章',
              'chapter2': '第二章',
              'chapter3': '第三章',
              'chapter4': '第四章',
              'chapter5': '第五章',
              'chapter6': '第六章',
              'chapter7': '第七章',
              'ict': 'ICT-昇腾AI题库'
          };
          return names[chapter] || '题库';
      }

      // 更新阶段性练习界面
      function updateStageSelection() {
          const totalCount = originalQuestions.length;
          document.getElementById('stage-total-count').textContent = totalCount;
          document.getElementById('stage-start-input').max = totalCount;
          document.getElementById('stage-end-input').max = totalCount;
          document.getElementById('stage-start-input').value = '';
          document.getElementById('stage-end-input').value = '';
          document.getElementById('stage-error-message').style.display = 'none';
      }

      // 初始化阶段性练习
      function initStageExam(startIndex, endIndex, mode, isRandom = false) {
          currentMode = mode;
          clearInterval(timerInterval);
          startTime = Date.now();
          timerInterval = setInterval(updateElapsedTime, 1000);
          
          // 显示当前模式和题库信息
          const modeIcon = mode === 'practice' ? '<i class="fas fa-book"></i>' : '<i class="fas fa-clipboard-check"></i>';
          const modeName = mode === 'practice' ? '练习模式' : '考试模式';
          const orderText = isRandom ? '随机' : '顺序';
          currentModeDisplay.innerHTML = `${modeIcon} ${modeName} - 阶段练习（第${startIndex}-${endIndex}题·${orderText}）`;
          currentModeDisplay.style.color = mode === 'practice' ? '#2ecc71' : '#3498db';
          
          // 清空状态
          userAnswers = {};
          results = {};
          shuffledQuestions = [];
          usedQuestionIndices = [];
          document.getElementById('exam-form').innerHTML = '';
          document.getElementById('progress-bar').style.width = '0';
          document.getElementById('timer').innerHTML = '<i class="fas fa-clock"></i> 已用时: 00:00';
          document.getElementById('final-time').textContent = "";
          
          // 获取指定区间的题目
          const tempQuestions = [];
          for (let i = startIndex - 1; i < endIndex; i++) {
              if (i < originalQuestions.length) {
                  tempQuestions.push(originalQuestions[i]);
                  usedQuestionIndices.push(i);
              }
          }
          
          // 根据选择决定是否打乱
          if (isRandom) {
              shuffledQuestions = shuffle(tempQuestions.slice());
          } else {
              shuffledQuestions = tempQuestions;
          }
          
          // 生成题目
          const examForm = document.getElementById('exam-form');
          shuffledQuestions.forEach((q, index) => {
              const questionDiv = document.createElement('div');
              questionDiv.className = 'question fade-in';
              questionDiv.id = `question-${q.id}`;
              
              // 判断是否为多选题（使用校准后的答案）
              const finalAnswer = getFinalAnswer(q);
              const isMultipleChoice = finalAnswer && finalAnswer.includes(' ');
              const inputType = isMultipleChoice ? 'checkbox' : 'radio';
              const inputName = `question-${q.id}`;
              
              let optionsHtml = '';
              q.options.forEach(option => {
                  const optionLetter = option.charAt(0);
                  optionsHtml += `
                      <div class="option" data-option="${optionLetter}">
                          <label>
                              <input type="${inputType}" name="${inputName}" value="${optionLetter}">
                              ${option}
                          </label>
                      </div>
                  `;
              });
              
              const questionTypeLabel = isMultipleChoice ? '<span class="question-type">[多选题]</span>' : '';
              
              // 题号显示：乱序时显示序号，顺序时显示实际题号
              const questionNumber = isRandom ? (index + 1) : (startIndex + index);
              
              questionDiv.innerHTML = `
                  <div class="question-title">
                      <span class="question-number">${questionNumber}. </span>
                      ${questionTypeLabel}
                      ${q.question}
                  </div>
                  <div class="options">
                      ${optionsHtml}
                  </div>
                  <div class="answer-feedback" id="feedback-${q.id}"></div>
              `;
              examForm.appendChild(questionDiv);
          });
          
          updateProgressBar();
          
          // 如果是练习模式，添加选项点击事件监听
          if (mode === 'practice') {
              document.querySelectorAll('.option').forEach(option => {
                  option.addEventListener('click', handlePracticeModeSelection);
              });
          }
      }

      // 模式选择逻辑
      const practiceModeBtn = document.getElementById('practice-mode-btn');
      const examModeBtn = document.getElementById('exam-mode-btn');
      const stageModeBtn = document.getElementById('stage-mode-btn');
      const stageSelection = document.getElementById('stage-selection');
      const currentModeDisplay = document.getElementById('current-mode');

      practiceModeBtn.addEventListener('click', function() {
          currentMode = 'practice';
          modeSelection.classList.add('hidden');
          questionCountSelection.classList.remove('hidden');
          currentModeDisplay.innerHTML = '<i class="fas fa-book"></i> 练习模式 - 答题后可立即查看答案';
          currentModeDisplay.style.color = '#27ae60';
          updateQuestionCountDisplay();
          // 隐藏背题模式的顺序选择
          document.getElementById('memorize-order-selection').style.display = 'none';
      });

      examModeBtn.addEventListener('click', function() {
          currentMode = 'exam';
          modeSelection.classList.add('hidden');
          questionCountSelection.classList.remove('hidden');
          currentModeDisplay.innerHTML = '<i class="fas fa-clipboard-check"></i> 考试模式 - 提交后统一查看结果';
          currentModeDisplay.style.color = '#3498db';
          updateQuestionCountDisplay();
          // 隐藏背题模式的顺序选择
          document.getElementById('memorize-order-selection').style.display = 'none';
      });

      stageModeBtn.addEventListener('click', function() {
          modeSelection.classList.add('hidden');
          stageSelection.classList.remove('hidden');
          updateStageSelection();
      });

      // 题目数量选择逻辑
      const questionCountInput = document.getElementById('question-count-input');
      const questionCountSubmit = document.getElementById('question-count-submit');
      const countErrorMessage = document.getElementById('count-error-message');
      const examContent = document.getElementById('exam-content');

      questionCountSubmit.addEventListener('click', function() {
          const count = parseInt(questionCountInput.value);
          if (isNaN(count) || count < 1 || count > originalQuestions.length) {
              countErrorMessage.style.display = 'block';
              return;
          }
          // 确保隐藏考试结果区域，并显示考试区域（考试区域可能保留上次结果）
          document.getElementById('results').style.display = 'none';
          document.getElementById('exam-form').style.display = 'block';
          // 无论什么模式都显示提交按钮
          document.getElementById('submit-btn').style.display = 'block';
          
          questionCountSelection.classList.add('hidden');
          examContent.classList.remove('hidden');
          initExam(count);
          showInterruptBtn(); // 显示中断按钮
      });
      
      // 回车确认题目数量
      questionCountInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
              questionCountSubmit.click();
          }
      });

      // 阶段性练习按钮事件
      const stageStartInput = document.getElementById('stage-start-input');
      const stageEndInput = document.getElementById('stage-end-input');
      const stagePracticeSubmit = document.getElementById('stage-practice-submit');
      const stageExamSubmit = document.getElementById('stage-exam-submit');
      const stageBackBtn = document.getElementById('stage-back-btn');
      const stageErrorMessage = document.getElementById('stage-error-message');

      function validateStageInput() {
          const start = parseInt(stageStartInput.value);
          const end = parseInt(stageEndInput.value);
          const maxCount = originalQuestions.length;
          
          if (isNaN(start) || isNaN(end) || start < 1 || end < 1 || start > maxCount || end > maxCount || start > end) {
              stageErrorMessage.textContent = '请输入有效的题目区间！起始题号需小于等于结束题号';
              stageErrorMessage.style.display = 'block';
              return null;
          }
          
          return { start, end };
      }

      stagePracticeSubmit.addEventListener('click', function() {
          const range = validateStageInput();
          if (!range) return;
          
          // 获取顺序选择
          const orderType = document.querySelector('input[name="stage-order"]:checked').value;
          const isRandom = orderType === 'random';
          
          document.getElementById('results').style.display = 'none';
          document.getElementById('exam-form').style.display = 'block';
          document.getElementById('submit-btn').style.display = 'block';
          
          stageSelection.classList.add('hidden');
          examContent.classList.remove('hidden');
          initStageExam(range.start, range.end, 'practice', isRandom);
          showInterruptBtn(); // 显示中断按钮
      });

      stageExamSubmit.addEventListener('click', function() {
          const range = validateStageInput();
          if (!range) return;
          
          // 获取顺序选择
          const orderType = document.querySelector('input[name="stage-order"]:checked').value;
          const isRandom = orderType === 'random';
          
          document.getElementById('results').style.display = 'none';
          document.getElementById('exam-form').style.display = 'block';
          document.getElementById('submit-btn').style.display = 'block';
          
          stageSelection.classList.add('hidden');
          examContent.classList.remove('hidden');
          initStageExam(range.start, range.end, 'exam', isRandom);
          showInterruptBtn(); // 显示中断按钮
      });

      stageBackBtn.addEventListener('click', function() {
          stageSelection.classList.add('hidden');
          modeSelection.classList.remove('hidden');
          stageStartInput.value = '';
          stageEndInput.value = '';
          stageErrorMessage.style.display = 'none';
      });

      // 回车确认阶段性练习
      stageEndInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
              stagePracticeSubmit.click();
          }
      });

      // 洗牌函数（Fisher-Yates 算法）
      function shuffle(array) {
          let currentIndex = array.length, temporaryValue, randomIndex;
          while (currentIndex !== 0) {
              randomIndex = Math.floor(Math.random() * currentIndex);
              currentIndex -= 1;
              temporaryValue = array[currentIndex];
              array[currentIndex] = array[randomIndex];
              array[randomIndex] = temporaryValue;
          }
          return array;
      }
      
      // 初始化考试：打乱题目、清空旧状态、启动计时器
      function initExam(count) {
          clearInterval(timerInterval);
          startTime = Date.now();
          timerInterval = setInterval(updateElapsedTime, 1000);
          
          // 显示当前模式和题库信息
          const modeIcon = currentMode === 'practice' ? '<i class="fas fa-book"></i>' : '<i class="fas fa-clipboard-check"></i>';
          const modeName = currentMode === 'practice' ? '练习模式' : '考试模式';
          currentModeDisplay.innerHTML = `${modeIcon} ${modeName} - ICT-昇腾AI题库`;
          currentModeDisplay.style.color = currentMode === 'practice' ? '#2ecc71' : '#3498db';
          
          // 清空状态
          userAnswers = {};
          results = {};
          shuffledQuestions = [];
          usedQuestionIndices = [];
          document.getElementById('exam-form').innerHTML = '';
          document.getElementById('progress-bar').style.width = '0';
          document.getElementById('timer').innerHTML = '<i class="fas fa-clock"></i> 已用时: 00:00';
          document.getElementById('final-time').textContent = "";
          
          // 打乱题库并选择题目
          const shuffled = shuffle(originalQuestions.slice());
          const actualCount = Math.min(count, shuffled.length);
          for (let i = 0; i < actualCount; i++) {
              shuffledQuestions.push(shuffled[i]);
              usedQuestionIndices.push(i);
          }
          
          // 生成题目
          const examForm = document.getElementById('exam-form');
          shuffledQuestions.forEach((q, index) => {
              const questionDiv = document.createElement('div');
              questionDiv.className = 'question fade-in';
              questionDiv.id = `question-${q.id}`;
              
              // 判断是否为多选题（使用校准后的答案）
              const finalAnswer = getFinalAnswer(q);
              const isMultipleChoice = finalAnswer && finalAnswer.includes(' ');
              const inputType = isMultipleChoice ? 'checkbox' : 'radio';
              const inputName = `question-${q.id}`;
              
              let optionsHtml = '';
              q.options.forEach(option => {
                  const optionLetter = option.charAt(0);
                  optionsHtml += `
                      <div class="option" data-option="${optionLetter}">
                          <label>
                              <input type="${inputType}" name="${inputName}" value="${optionLetter}">
                              ${option}
                          </label>
                      </div>
                  `;
              });
              
              const questionTypeLabel = isMultipleChoice ? '<span class="question-type">[多选题]</span>' : '';
              
              questionDiv.innerHTML = `
                  <div class="question-title">
                      <span class="question-number">${index + 1}. </span>
                      ${questionTypeLabel}
                      ${q.question}
                  </div>
                  <div class="options">
                      ${optionsHtml}
                  </div>
                  <div class="answer-feedback" id="feedback-${q.id}"></div>
              `;
              examForm.appendChild(questionDiv);
          });
          
          updateProgressBar();
          
          // 如果是练习模式，添加选项点击事件监听
          if (currentMode === 'practice') {
              document.querySelectorAll('.option').forEach(option => {
                  option.addEventListener('click', handlePracticeModeSelection);
              });
          }
      }
      
      // 练习模式下，点击选项后的处理
      function handlePracticeModeSelection(e) {
          const optionDiv = this;
          const questionDiv = optionDiv.closest('.question');
          const questionId = parseInt(questionDiv.id.replace('question-', ''));
          const selectedOption = optionDiv.dataset.option;
          const feedbackDiv = document.getElementById(`feedback-${questionId}`);
          
          // 查找对应的题目和正确答案（使用校准后的答案）
          const question = shuffledQuestions.find(q => q.id === questionId);
          const correctAnswer = getFinalAnswer(question); // 使用校准后的答案
          const isMultipleChoice = correctAnswer && correctAnswer.includes(' ');
          
          if (isMultipleChoice) {
              // 多选题逻辑
              const checkbox = optionDiv.querySelector('input[type="checkbox"]');
              
              // 切换复选框状态
              checkbox.checked = !checkbox.checked;
              
              // 更新UI
              if (checkbox.checked) {
                  optionDiv.classList.add('selected');
              } else {
                  optionDiv.classList.remove('selected');
              }
              
              // 收集所有选中的选项
              const selectedOptions = [];
              questionDiv.querySelectorAll('input[type="checkbox"]:checked').forEach(input => {
                  selectedOptions.push(input.value);
              });
              
              // 保存用户答案（多选答案用空格分隔）
              userAnswers[questionId] = selectedOptions.sort().join(' ');
              
              // 显示反馈（只有选择了选项才显示）
              if (selectedOptions.length > 0) {
                  feedbackDiv.style.display = 'block';
                  const userAnswerStr = selectedOptions.sort().join(' ');
                  const correctAnswerArray = correctAnswer.split(' ').sort();
                  const correctAnswerStr = correctAnswerArray.join(' ');
                  
                  if (userAnswerStr === correctAnswerStr) {
                      // 完全正确 - 显示完整答案
                      feedbackDiv.className = 'answer-feedback correct';
                      feedbackDiv.innerHTML = `<i class="fas fa-check-circle"></i> 全部正确！答案是：${correctAnswer}`;
                  } else {
                      // 检查是否有部分正确
                      const correctCount = selectedOptions.filter(option => correctAnswerArray.includes(option)).length;
                      const incorrectCount = selectedOptions.filter(option => !correctAnswerArray.includes(option)).length;
                      
                      if (incorrectCount > 0) {
                          // 有错误选项 - 显示错误
                          feedbackDiv.className = 'answer-feedback incorrect';
                          feedbackDiv.innerHTML = `<i class="fas fa-times-circle"></i> 答案错误！有选项选择错误`;
                      } else if (correctCount > 0 && correctCount < correctAnswerArray.length) {
                          // 部分正确，但未选全 - 只提示部分正确，不显示完整答案
                          feedbackDiv.className = 'answer-feedback partial';
                          feedbackDiv.innerHTML = `<i class="fas fa-info-circle"></i> 部分正确！还有其他正确选项未选择`;
                      } else {
                          // 完全错误
                          feedbackDiv.className = 'answer-feedback incorrect';
                          feedbackDiv.innerHTML = `<i class="fas fa-times-circle"></i> 答案错误！请重新选择`;
                      }
                  }
              } else {
                  feedbackDiv.style.display = 'none';
              }
          } else {
              // 单选题逻辑（保持原有逻辑）
              const radio = optionDiv.querySelector('input[type="radio"]');
              radio.checked = true;
              
              // 保存用户答案
              userAnswers[questionId] = selectedOption;
              
              // 更新UI：标记所有选项
              questionDiv.querySelectorAll('.option').forEach(opt => {
                  opt.classList.remove('selected');
                  if (opt.dataset.option === selectedOption) {
                      opt.classList.add('selected');
                  }
              });
              
              // 显示反馈
              feedbackDiv.style.display = 'block';
              if (selectedOption === correctAnswer) {
                  feedbackDiv.className = 'answer-feedback correct';
                  feedbackDiv.innerHTML = `<i class="fas fa-check-circle"></i> 正确！答案是：${correctAnswer}`;
              } else {
                  feedbackDiv.className = 'answer-feedback incorrect';
                  feedbackDiv.innerHTML = `<i class="fas fa-times-circle"></i> 错误！正确答案是：${correctAnswer}`;
              }
          }
          
          updateProgressBar();
      }
      
      // 更新时间显示（格式：mm:ss）
      function updateElapsedTime() {
          const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsedSeconds / 60);
          const seconds = elapsedSeconds % 60;
          const formattedTime = 
              (minutes < 10 ? "0" + minutes : minutes) + ":" + 
              (seconds < 10 ? "0" + seconds : seconds);
          document.getElementById('timer').innerHTML = '<i class="fas fa-clock"></i> 已用时: ' + formattedTime;
      }
      
      function updateProgressBar() {
          const answered = Object.keys(userAnswers).length;
          const total = shuffledQuestions.length;
          const percentage = (answered / total) * 100;
          document.getElementById('progress-bar').style.width = `${percentage}%`;
      }
      
      function calculateResults() {
          clearInterval(timerInterval);
          const totalElapsed = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(totalElapsed / 60);
          const seconds = totalElapsed % 60;
          const formattedTotalTime = 
              (minutes < 10 ? "0" + minutes : minutes) + ":" + 
              (seconds < 10 ? "0" + seconds : seconds);
          
          let correct = 0;
          let partiallyCorrect = 0;
          let incorrectQuestions = []; // 收集错题
          shuffledQuestions.forEach(q => {
              const userAnswer = userAnswers[q.id] || '';
              let isCorrect = false;
              let isPartiallyCorrect = false;
              
              // 使用校准后的答案
              const correctAnswer = getFinalAnswer(q);
              
              // 处理多选题和单选题的答案比较
              if (correctAnswer && correctAnswer.includes(' ')) {
                  // 多选题：计算完全正确、部分正确
                  const correctAnswerArray = correctAnswer.split(' ').sort();
                  const userAnswerArray = userAnswer.split(' ').filter(a => a).sort();
                  
                  isCorrect = JSON.stringify(correctAnswerArray) === JSON.stringify(userAnswerArray);
                  
                  if (!isCorrect && userAnswerArray.length > 0) {
                      // 计算交集（选对的选项）
                      const userSet = new Set(userAnswerArray);
                      const correctSet = new Set(correctAnswerArray);
                      const intersection = [...userSet].filter(x => correctSet.has(x));
                      isPartiallyCorrect = intersection.length > 0;
                  }
              } else {
                  // 单选题：直接比较
                  isCorrect = (userAnswer === correctAnswer);
              }
              
              results[q.id] = {
                  question: q,
                  userAnswer: userAnswer,
                  isCorrect: isCorrect,
                  isPartiallyCorrect: isPartiallyCorrect
              };
              
              if (isCorrect) {
                  correct++;
              } else if (isPartiallyCorrect) {
                  partiallyCorrect++;
                  incorrectQuestions.push(q); // 部分正确也算错题，需要加强练习
              } else {
                  incorrectQuestions.push(q); // 添加到错题集
              }
          });
          
          // 保存错题集到sessionStorage
          if (incorrectQuestions.length > 0) {
              sessionStorage.setItem('incorrectQuestions', JSON.stringify(incorrectQuestions));
          } else {
              sessionStorage.removeItem('incorrectQuestions');
          }
          
          const accuracy = ((correct / shuffledQuestions.length) * 100).toFixed(1);
          
          // 更新结果统计
          document.getElementById('score').textContent = correct;
          document.getElementById('total').textContent = shuffledQuestions.length;
          document.getElementById('accuracy').textContent = `${accuracy}%`;
          document.getElementById('final-time').textContent = "总作答用时：" + formattedTotalTime;
          
          // 更新结果统计卡片
          document.getElementById('summary-score').textContent = correct;
          document.getElementById('summary-total').textContent = shuffledQuestions.length;
          document.getElementById('summary-accuracy').textContent = `${accuracy}%`;
          document.getElementById('summary-time').textContent = formattedTotalTime;
          
          displayResults('all');
      }
      
      function submitExam() {
          // 检查是否全部作答，否则滚动定位到未答题目，不再显示提醒弹窗
          for (let i = 0; i < shuffledQuestions.length; i++) {
              const q = shuffledQuestions[i];
              if (!userAnswers[q.id] || userAnswers[q.id] === '') {
                  const questionElem = document.getElementById(`question-${q.id}`);
                  if (questionElem) {
                      document.querySelectorAll('.question').forEach(q => q.classList.remove('current-question'));
                      questionElem.classList.add('current-question');
                      questionElem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  }
                  return;
              }
          }
          
          calculateResults();
          
          // 隐藏考试区域、显示结果区域并自动滚动到页面顶部
          document.getElementById('exam-form').style.display = 'none';
          document.getElementById('submit-btn').style.display = 'none';
          document.getElementById('results').style.display = 'block';
          window.scrollTo({ top: 0, behavior: 'smooth' });
      }
      
      function displayResults(filter) {
          const resultDetails = document.getElementById('result-details');
          resultDetails.innerHTML = '';
          Object.values(results).forEach((result, index) => {
              if (filter === 'incorrect' && result.isCorrect) return;
              
              // 确定题目状态
              let statusClass = 'incorrect';
              let statusText = '<i class="fas fa-times"></i> 错误';
              let divClass = 'incorrect';
              
              if (result.isCorrect) {
                  statusClass = 'correct';
                  statusText = '<i class="fas fa-check"></i> 全部正确';
                  divClass = 'correct';
              } else if (result.isPartiallyCorrect) {
                  statusClass = 'partial';
                  statusText = '<i class="fas fa-exclamation-triangle"></i> 部分正确';
                  divClass = 'partial';
              }
              
              const resultDiv = document.createElement('div');
              resultDiv.className = `question fade-in ${divClass}`;
              resultDiv.innerHTML = `
                  <div class="question-title">
                      <span class="question-number">${index + 1}. </span>
                      ${result.question.question}
                      <span class="status ${statusClass}">
                          ${statusText}
                      </span>
                  </div>
                  <div class="options">
                      ${result.question.options.map(option => {
                          const letter = option.charAt(0);
                          let className = '';
                          let icon = '';
                          
                          // 判断是否为多选题（使用校准后的答案）
                          const finalAnswer = getFinalAnswer(result.question);
                          const isMultipleChoice = finalAnswer && finalAnswer.includes(' ');
                          const correctAnswers = isMultipleChoice ? finalAnswer.split(' ') : [finalAnswer];
                          const userAnswers = result.userAnswer ? (isMultipleChoice ? result.userAnswer.split(' ') : [result.userAnswer]) : [];
                          
                          const isCorrectAnswer = correctAnswers.includes(letter);
                          const isUserAnswer = userAnswers.includes(letter);
                          
                          if (isCorrectAnswer && isUserAnswer) {
                              className = 'correct';
                              icon = '<i class="fas fa-check-circle"></i>';
                          } else if (isCorrectAnswer && !isUserAnswer) {
                              className = 'missed';
                              icon = '<i class="fas fa-circle"></i>';
                          } else if (!isCorrectAnswer && isUserAnswer) {
                              className = 'incorrect';
                              icon = '<i class="fas fa-times-circle"></i>';
                          }
                          
                          return `
                              <div class="option ${className}">
                                  ${option} ${icon}
                              </div>
                          `;
                      }).join('')}
                      <div class="answer-summary">
                          <div class="user-answer">你的答案: ${result.userAnswer || '未作答'}</div>
                          <div class="correct-answer">正确答案: ${getFinalAnswer(result.question)}</div>
                      </div>
                  </div>
              `;
              resultDetails.appendChild(resultDiv);
          });
      }
      
      // 监听考试模式下的答案选项变化
      document.addEventListener('change', function(e) {
          if (currentMode === 'exam' && (e.target.type === 'radio' || e.target.type === 'checkbox') && e.target.name.startsWith('question-')) {
              const questionId = parseInt(e.target.name.replace('question-', ''));
              const questionDiv = e.target.closest('.question');
              
              if (e.target.type === 'radio') {
                  // 单选题逻辑
                  userAnswers[questionId] = e.target.value;
                  
                  // 更新选项UI
                  questionDiv.querySelectorAll('.option').forEach(opt => {
                      opt.classList.remove('selected');
                  });
                  e.target.closest('.option').classList.add('selected');
              } else if (e.target.type === 'checkbox') {
                  // 多选题逻辑
                  const selectedOptions = [];
                  questionDiv.querySelectorAll('input[type="checkbox"]:checked').forEach(input => {
                      selectedOptions.push(input.value);
                  });
                  
                  // 保存用户答案（多选答案用空格分隔）
                  userAnswers[questionId] = selectedOptions.sort().join(' ');
                  
                  // 更新选项UI
                  questionDiv.querySelectorAll('.option').forEach(opt => {
                      const checkbox = opt.querySelector('input[type="checkbox"]');
                      if (checkbox && checkbox.checked) {
                          opt.classList.add('selected');
                      } else {
                          opt.classList.remove('selected');
                      }
                  });
              }
              
              updateProgressBar();
          }
      });
      
      // 提交答案按钮事件
      document.getElementById('submit-btn').addEventListener('click', submitExam);
      
      // "重新测试"按钮：保持原题数重新考试，重新打乱顺序，并自动滚动到第一题
      document.getElementById('restart-btn').addEventListener('click', function() {
          clearInterval(timerInterval);
          document.getElementById('exam-form').style.display = 'block';
          document.getElementById('submit-btn').style.display = 'block'; // 无论什么模式都显示提交按钮
          document.getElementById('results').style.display = 'none';
          
          // 重新初始化考试，打乱题目顺序
          initExam(shuffledQuestions.length);
          
          // 在initExam完成后，滚动到第一题位置
          setTimeout(() => {
              // 如果有题目，获取第一个题目并滚动到它的位置
              const firstQuestion = document.querySelector('.question');
              if (firstQuestion) {
                  firstQuestion.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
          }, 100); // 短暂延迟确保DOM已更新
      });
      
      // "重新选择题库"按钮：完全重置状态后，回到章节选择界面
      document.getElementById('reselect-btn').addEventListener('click', function() {
          clearInterval(timerInterval);
          timerInterval = null;
          startTime = null;
          userAnswers = {};
          results = {};
          shuffledQuestions = [];
          usedQuestionIndices = [];
          document.getElementById('exam-form').innerHTML = '';
          document.getElementById('progress-bar').style.width = '0';
          document.getElementById('timer').innerHTML = '<i class="fas fa-clock"></i> 已用时: 00:00';
          document.getElementById('final-time').textContent = "";
          
          // 回到章节选择界面
          examContent.classList.add('hidden');
          modeSelection.classList.add('hidden');
          chapterSelection.classList.remove('hidden');
          questionCountInput.value = '';
          countErrorMessage.style.display = 'none';
          hideInterruptBtn(); // 隐藏中断按钮
      });
      
      // "错题重新测试"按钮：从错题集重新生成考试
      document.getElementById('retry-incorrect-btn').addEventListener('click', function() {
          const incorrectQuestions = JSON.parse(sessionStorage.getItem('incorrectQuestions') || '[]');
          if (incorrectQuestions.length === 0) {
              alert('没有错题可供重新测试！');
              return;
          }
          
          clearInterval(timerInterval);
          document.getElementById('exam-form').style.display = 'block';
          document.getElementById('submit-btn').style.display = 'block';
          document.getElementById('results').style.display = 'none';
          
          // 直接使用错题集，不再调用洗牌算法
          userAnswers = {};
          results = {};
          shuffledQuestions = [...incorrectQuestions]; // 使用错题集的副本
          
          // 更新模式显示
          if (currentMode === 'practice') {
              currentModeDisplay.innerHTML = `<i class="fas fa-book"></i> 练习模式 - ICT-昇腾AI错题重测`;
              currentModeDisplay.style.color = '#e74c3c';
          } else {
              currentModeDisplay.innerHTML = `<i class="fas fa-clipboard-check"></i> 考试模式 - ICT-昇腾AI错题重测`;
              currentModeDisplay.style.color = '#e74c3c';
          }
          
          // 开始计时
          startTime = Date.now();
          timerInterval = setInterval(updateElapsedTime, 1000);
          
          // 清空旧的考试表单和进度条
          document.getElementById('exam-form').innerHTML = '';
          document.getElementById('progress-bar').style.width = '0';
          document.getElementById('timer').innerHTML = '<i class="fas fa-clock"></i> 已用时: 00:00';
          
          // 生成错题题目
          const examForm = document.getElementById('exam-form');
          shuffledQuestions.forEach((q, index) => {
              const questionDiv = document.createElement('div');
              questionDiv.className = 'question fade-in';
              questionDiv.id = `question-${q.id}`;
              
              // 判断是否为多选题（使用校准后的答案）
              const finalAnswer = getFinalAnswer(q);
              const isMultipleChoice = finalAnswer && finalAnswer.includes(' ');
              const inputType = isMultipleChoice ? 'checkbox' : 'radio';
              const inputName = `question-${q.id}`;
              
              let optionsHtml = '';
              q.options.forEach(option => {
                  const optionLetter = option.charAt(0);
                  optionsHtml += `
                      <div class="option" data-option="${optionLetter}">
                          <label>
                              <input type="${inputType}" name="${inputName}" value="${optionLetter}">
                              ${option}
                          </label>
                      </div>
                  `;
              });
              
              const questionTypeLabel = isMultipleChoice ? '<span class="question-type">[多选题]</span>' : '';
              
              questionDiv.innerHTML = `
                  <div class="question-title">
                      <span class="question-number">${index + 1}. </span>
                      ${questionTypeLabel}
                      ${q.question}
                  </div>
                  <div class="options">
                      ${optionsHtml}
                  </div>
                  <div class="answer-feedback" id="feedback-${q.id}"></div>
              `;
              examForm.appendChild(questionDiv);
          });
          
          // 如果是练习模式，添加选项点击事件监听
          if (currentMode === 'practice') {
              document.querySelectorAll('.option').forEach(option => {
                  option.addEventListener('click', handlePracticeModeSelection);
              });
          }
          
          // 显示错题重测的提示信息
          const noteDiv = document.createElement('div');
          noteDiv.style.textAlign = 'center';
          noteDiv.style.padding = '10px';
          noteDiv.style.marginBottom = '20px';
          noteDiv.style.backgroundColor = 'rgba(231, 76, 60, 0.1)';
          noteDiv.style.borderRadius = '5px';
          noteDiv.style.fontWeight = 'bold';
          noteDiv.style.color = '#e74c3c';
          noteDiv.innerHTML = `<i class="fas fa-exclamation-circle"></i> 当前正在进行错题重测，共 ${shuffledQuestions.length} 道题`;
          examForm.insertBefore(noteDiv, examForm.firstChild);
          
          // 自动滚动到第一题
          window.scrollTo({ top: 0, behavior: 'smooth' });
      });
      
      document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
              this.classList.add('active');
              displayResults(this.getAttribute('data-filter'));
          });
      });
  </script>

  <!-- 答案校准模式 -->
  <div id="calibrate-content" class="hidden fade-in">
      <div class="container">
          <h1>答案校准模式</h1>
          <div style="text-align: center; margin-bottom: 20px;">
              <p style="color: #7f8c8d;">共 <span id="calibrate-total">0</span> 题 | 修改后自动保存</p>
          </div>
          
          <div id="calibrate-form">
              <!-- 所有题目动态生成 -->
          </div>
          
          <div style="text-align: center; margin: 30px 0; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
              <button id="calibrate-reset" class="btn" style="background: linear-gradient(135deg, #f39c12, #e67e22);"><i class="fas fa-undo"></i> 重置为原始答案</button>
              <button id="calibrate-back" class="btn btn-danger"><i class="fas fa-arrow-left"></i> 返回模式选择</button>
          </div>
      </div>
  </div>

  <!-- 背题模式 -->
  <div id="memorize-content" class="hidden fade-in">
      <div class="container">
          <h1>背题模式</h1>
          <div style="text-align: center; margin-bottom: 20px;">
              <p style="color: #7f8c8d;">共 <span id="memorize-total">0</span> 题</p>
          </div>
          
          <div id="memorize-form">
              <!-- 所有题目动态生成 -->
          </div>
          
          <div style="text-align: center; margin: 30px 0;">
              <button id="memorize-back" class="btn btn-danger"><i class="fas fa-arrow-left"></i> 返回模式选择</button>
          </div>
      </div>
  </div>

  <script>
      // 背题模式相关变量
      let memorizeQuestions = [];

      // 从localStorage获取校准后的答案（带章节标识）
      function getCalibratedAnswer(questionId) {
          const storageKey = `calibratedAnswers_${currentChapter}`;
          const calibrated = localStorage.getItem(storageKey);
          if (calibrated) {
              try {
                  const answers = JSON.parse(calibrated);
                  return answers[questionId] || null;
              } catch (e) {
                  console.error('解析校准答案失败:', e);
                  return null;
              }
          }
          return null;
      }

      // 保存校准的答案到localStorage（带章节标识）
      function saveCalibratedAnswer(questionId, answer) {
          const storageKey = `calibratedAnswers_${currentChapter}`;
          let calibrated = localStorage.getItem(storageKey);
          let answers = calibrated ? JSON.parse(calibrated) : {};
          answers[questionId] = answer;
          try {
              localStorage.setItem(storageKey, JSON.stringify(answers));
              console.log(`已保存题目 ${questionId} 的校准答案:`, answer);
          } catch (e) {
              console.error('保存校准答案失败:', e);
              alert('保存失败，可能是浏览器存储空间不足');
          }
      }
      
      // 清除当前章节的所有校准数据
      function clearCalibratedAnswers() {
          const storageKey = `calibratedAnswers_${currentChapter}`;
          localStorage.removeItem(storageKey);
          console.log(`已清除 ${currentChapter} 的校准数据`);
      }

      // 获取题目的最终答案（优先使用校准答案）
      function getFinalAnswer(question) {
          const calibrated = getCalibratedAnswer(question.id);
          return calibrated !== null ? calibrated : question.answer;
      }

      // 渲染答案校准界面（一次性显示所有题目）
      function renderAllCalibrateQuestions() {
          const form = document.getElementById('calibrate-form');
          form.innerHTML = '';
          document.getElementById('calibrate-total').textContent = originalQuestions.length;
          
          console.log('当前章节:', currentChapter);
          console.log('题库数量:', originalQuestions.length);
          
          originalQuestions.forEach((q, index) => {
              const questionDiv = document.createElement('div');
              questionDiv.className = 'question fade-in';
              questionDiv.id = `calibrate-q-${q.id}`;
              
              const finalAnswer = getFinalAnswer(q);
              // 确保答案存在且有效
              const safeAnswer = finalAnswer || q.answer || '';
              
              console.log(`题目${q.id}: 原始答案=${q.answer}, 校准答案=${finalAnswer}, 最终答案=${safeAnswer}`);
              
              const isMultipleChoice = safeAnswer && safeAnswer.includes(' ');
              const inputType = isMultipleChoice ? 'checkbox' : 'radio';
              const inputName = `calibrate-answer-${q.id}`;
              
              let optionsHtml = '';
              q.options.forEach(option => {
                  const optionLetter = option.charAt(0);
                  const isSelected = isMultipleChoice 
                      ? safeAnswer.split(' ').includes(optionLetter)
                      : safeAnswer === optionLetter;
                  const checked = isSelected ? 'checked' : '';
                  
                  optionsHtml += `
                      <div class="option" data-option="${optionLetter}">
                          <label>
                              <input type="${inputType}" name="${inputName}" value="${optionLetter}" ${checked} data-qid="${q.id}" class="answer-option">
                              ${option}
                          </label>
                      </div>
                  `;
              });
              
              const questionTypeLabel = isMultipleChoice ? '<span class="question-type">[多选题]</span>' : '';
              const multipleChoiceChecked = isMultipleChoice ? 'checked' : '';
              
              questionDiv.innerHTML = `
                  <div class="question-title">
                      <span class="question-number">${index + 1}. </span>
                      ${questionTypeLabel}
                      ${q.question}
                  </div>
                  <div style="margin: 10px 0; padding: 10px; background: #fff3cd; border-radius: 6px; border-left: 3px solid #ffc107;">
                      <label style="cursor: pointer; display: flex; align-items: center; gap: 8px;">
                          <input type="checkbox" class="multiple-choice-toggle" data-qid="${q.id}" ${multipleChoiceChecked} style="transform: scale(1.3);">
                          <span style="font-weight: 600; color: #856404;">
                              <i class="fas fa-check-double"></i> 标记为多选题
                          </span>
                      </label>
                  </div>
                  <div class="options" id="options-${q.id}">
                      ${optionsHtml}
                  </div>
                  <div style="margin-top: 15px; padding: 10px; background: #f7f9fc; border-radius: 6px;">
                      <p style="margin: 5px 0;"><strong>原始答案：</strong>${q.answer}</p>
                      <p style="margin: 5px 0;"><strong>当前答案：</strong><span id="current-answer-${q.id}">${safeAnswer}</span></p>
                  </div>
              `;
              form.appendChild(questionDiv);
          });
          
          // 添加多选题切换监听
          document.querySelectorAll('.multiple-choice-toggle').forEach(toggle => {
              toggle.addEventListener('change', function() {
                  const qid = parseInt(this.dataset.qid);
                  const optionsContainer = document.getElementById(`options-${qid}`);
                  const isMultiple = this.checked;
                  const inputName = `calibrate-answer-${qid}`;
                  
                  // 获取当前选中的答案
                  const currentSelected = [];
                  optionsContainer.querySelectorAll('.answer-option:checked').forEach(inp => {
                      currentSelected.push(inp.value);
                  });
                  
                  // 重新生成选项（切换单选/多选）
                  const q = originalQuestions.find(x => x.id === qid);
                  if (!q) return;
                  
                  const inputType = isMultiple ? 'checkbox' : 'radio';
                  let newOptionsHtml = '';
                  
                  q.options.forEach(option => {
                      const optionLetter = option.charAt(0);
                      // 如果切换到单选，只保留第一个选中的答案
                      const isSelected = isMultiple 
                          ? currentSelected.includes(optionLetter)
                          : (currentSelected.length > 0 && currentSelected[0] === optionLetter);
                      const checked = isSelected ? 'checked' : '';
                      
                      newOptionsHtml += `
                          <div class="option" data-option="${optionLetter}">
                              <label>
                                  <input type="${inputType}" name="${inputName}" value="${optionLetter}" ${checked} data-qid="${qid}" class="answer-option">
                                  ${option}
                              </label>
                          </div>
                      `;
                  });
                  
                  optionsContainer.innerHTML = newOptionsHtml;
                  
                  // 重新绑定答案变化监听
                  bindAnswerChangeListeners(qid);
                  
                  // 更新答案显示
                  updateAnswerDisplay(qid);
              });
          });
          
          // 初始绑定所有答案变化监听
          originalQuestions.forEach(q => {
              bindAnswerChangeListeners(q.id);
          });
      }
      
      // 绑定答案变化监听器
      function bindAnswerChangeListeners(qid) {
          const inputName = `calibrate-answer-${qid}`;
          document.querySelectorAll(`input[name="${inputName}"]`).forEach(input => {
              input.addEventListener('change', function() {
                  updateAnswerDisplay(qid);
              });
          });
      }
      
      // 更新答案显示并保存
      function updateAnswerDisplay(qid) {
          const inputName = `calibrate-answer-${qid}`;
          const selected = [];
          document.querySelectorAll(`input[name="${inputName}"]:checked`).forEach(inp => {
              selected.push(inp.value);
          });
          
          if (selected.length > 0) {
              const newAnswer = selected.sort().join(' ');
              saveCalibratedAnswer(qid, newAnswer);
              
              // 更新显示
              const answerDisplay = document.getElementById(`current-answer-${qid}`);
              if (answerDisplay) {
                  answerDisplay.textContent = newAnswer;
              }
          }
      }

      // 答案校准模式按钮
      document.getElementById('calibrate-mode-btn').addEventListener('click', function() {
          modeSelection.classList.add('hidden');
          document.getElementById('calibrate-content').classList.remove('hidden');
          renderAllCalibrateQuestions();
          showInterruptBtn(); // 显示中断按钮
      });

      document.getElementById('calibrate-back').addEventListener('click', function() {
          document.getElementById('calibrate-content').classList.add('hidden');
          modeSelection.classList.add('hidden');
          chapterSelection.classList.remove('hidden');
          hideInterruptBtn(); // 隐藏中断按钮
      });
      
      // 重置校准按钮
      document.getElementById('calibrate-reset').addEventListener('click', function() {
          if (confirm('确定要将当前章节的所有校准答案重置为原始答案吗？\n此操作不可撤销！')) {
              clearCalibratedAnswers();
              alert('已重置为原始答案，页面将刷新。');
              renderAllCalibrateQuestions(); // 重新渲染
          }
      });

      // 渲染背题模式（一次性显示所有题目）
      function renderAllMemorizeQuestions(isRandom = true) {
          const form = document.getElementById('memorize-form');
          form.innerHTML = '';
          document.getElementById('memorize-total').textContent = memorizeQuestions.length;
          
          memorizeQuestions.forEach((q, index) => {
              const questionDiv = document.createElement('div');
              questionDiv.className = 'question fade-in';
              
              const finalAnswer = getFinalAnswer(q);
              const isMultipleChoice = finalAnswer && finalAnswer.includes(' ');
              
              let optionsHtml = '';
              q.options.forEach(option => {
                  const optionLetter = option.charAt(0);
                  const isCorrect = isMultipleChoice 
                      ? finalAnswer.split(' ').includes(optionLetter)
                      : finalAnswer === optionLetter;
                  const className = isCorrect ? 'correct' : '';
                  const icon = isCorrect ? '<i class="fas fa-check-circle"></i>' : '';
                  
                  optionsHtml += `
                      <div class="option ${className}">
                          ${option} ${icon}
                      </div>
                  `;
              });
              
              const questionTypeLabel = isMultipleChoice ? '<span class="question-type">[多选题]</span>' : '';
              
              // 顺序模式显示实际题号，乱序模式显示序号
              const questionNumber = isRandom ? (index + 1) : q.id;
              
              questionDiv.innerHTML = `
                  <div class="question-title">
                      <span class="question-number">${questionNumber}. </span>
                      ${questionTypeLabel}
                      ${q.question}
                  </div>
                  <div class="options">
                      ${optionsHtml}
                  </div>
                  <div class="answer-summary" style="margin-top: 15px;">
                      <div class="correct-answer"><i class="fas fa-lightbulb"></i> 正确答案：${finalAnswer}</div>
                  </div>
              `;
              form.appendChild(questionDiv);
          });
      }

      document.getElementById('memorize-back').addEventListener('click', function() {
          document.getElementById('memorize-content').classList.add('hidden');
          examContent.classList.add('hidden'); // 确保考试区域隐藏
          modeSelection.classList.add('hidden');
          chapterSelection.classList.remove('hidden');
          memorizeQuestions = []; // 清空背题数据
          hideInterruptBtn(); // 隐藏中断按钮
      });

      // 背题模式按钮（需要先选择题目数量）
      document.getElementById('memorize-mode-btn').addEventListener('click', function() {
          currentMode = 'memorize';
          modeSelection.classList.add('hidden');
          questionCountSelection.classList.remove('hidden');
          currentModeDisplay.innerHTML = '<i class="fas fa-brain"></i> 背题模式 - 直接查看答案';
          currentModeDisplay.style.color = '#9b59b6';
          updateQuestionCountDisplay();
          
          // 显示背题模式的顺序选择
          document.getElementById('memorize-order-selection').style.display = 'block';
      });

      // 修改原有的questionCountSubmit逻辑以支持背题模式
      questionCountSubmit.onclick = null; // 清除原有事件
      questionCountSubmit.addEventListener('click', function() {
          const count = parseInt(questionCountInput.value);
          if (isNaN(count) || count < 1 || count > originalQuestions.length) {
              countErrorMessage.style.display = 'block';
              return;
          }
          
          if (currentMode === 'memorize') {
              // 背题模式 - 直接显示答案，不需要答题
              questionCountSelection.classList.add('hidden');
              examContent.classList.add('hidden'); // 确保考试内容区域被隐藏
              document.getElementById('memorize-content').classList.remove('hidden');
              
              // 获取顺序选择
              const orderType = document.querySelector('input[name="memorize-order"]:checked').value;
              const isRandom = orderType === 'random';
              
              if (isRandom) {
                  // 随机乱序
                  const shuffled = shuffle(originalQuestions.slice());
                  memorizeQuestions = shuffled.slice(0, count);
              } else {
                  // 顺序背题
                  memorizeQuestions = originalQuestions.slice(0, count);
              }
              
              renderAllMemorizeQuestions(isRandom);
              showInterruptBtn(); // 显示中断按钮
              
              // 隐藏顺序选择选项
              document.getElementById('memorize-order-selection').style.display = 'none';
          } else {
              // 练习或考试模式（原有逻辑）
              document.getElementById('results').style.display = 'none';
              document.getElementById('exam-form').style.display = 'block';
              document.getElementById('submit-btn').style.display = 'block';
              
              questionCountSelection.classList.add('hidden');
              examContent.classList.remove('hidden');
              initExam(count);
          }
      });
  </script>
</body>
</html>
